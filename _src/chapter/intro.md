---
title: "Introduction"
summary: "“Fast. _Fast_. Last night I cut the light off in my bedroom; hit the switch, was in the bed ’fore the room was dark. _Fast_.” \n—Muhammad Ali"
lede: "The quick and the dead?"
order: 1
---

The year is 1991. I am nine years old, and the computer cheats.

_Ninja Gaiden II: The Dark Sword of Chaos_ was unconcerned by such accusations, of course. It heard no “no fair” protests, it cared not for sticking controller buttons—it knew nothing of mercy nor of malice. The source code that made up _Ninja Gaiden II_ knew but two things during the span of a single moment in 1991, neither of which were sympathy for my young pride: the precise screen position where it would spawn that _one goddamned bird_, and how many lives I will have left after that bird kills me. 

What got you, with the birds, wasn’t— no, shut up, listen, this is important. See, what got you wasn’t the hit itself; the birds did almost no damage. What got you is that they appear while you’re jumping between these little platforms, over an open pit. You 90s kids that also didn’t go outside enough know where this is going: when you get hit by anything in this game, regardless of damage it does, you get knocked back about, oh, about the width of one little platform, opposite whatever direction poor doomed Ryu Hayabusa is facing at the time. So when I’d get nigh-harmlessly grazed by a single pixel representing a dorsal feather: off the platform I’d go, and there wasn’t a thing I could do about it during the split second where my recoiling sprite plummeted off-screen.

Now, there are a couple of ways a person can go when faced with a task designed to frustrate. The reasonable route was, of course: turn the game off. Go ride bikes; get some fresh air. But me, no way, I lived for the “try again,” and this game was made out of it. Hunched over, criss-cross-applesauce on the hardwood floor, brow furrowed with the the maximum amount of stress that could be experienced by a person who did not know—just to pull an example of of thin air, here—the cumulative effects of childhood posture on future spine health. _This_ time I’d get it; _this_ is the one. Every _this_ was the one. Every _this_, I was undaunted by all the previous mistaken _this_-es—steely-eyed, determined, brimming with unearned confidence. And thus, with all the on-screen grace of an actual child attempting to fight an actual bird: I would jump around and flail desperately at it. Into the pit I would go yet again—typically a victim of ornithological homicide, and occasionally hit by a spider’s, uh, fireball, or bumped off a ledge by… a store-brand Jason Voorhees, who is chasing me, a ninja, down a staircase that leads nowhere, over an open pit, inside of a European castle. Listen, games were winging it back then. Put a mummy in there somewhere too, why not—that’s a kind of bad guy.
  
<figure>
  {% respimg "_src/img/gaiden.jpg", "Ninja Gaiden II screenshot.", "200px" %}
  <figcaption>Lot goin’ on here. <a href="https://youtu.be/Q9j6VXf7AqI?t=777">YouTube</a>
</figure>

Me, I had neither the media literacy nor the mental bandwidth to consider such wildly inconsistent theming. One more try—_this_ time I’ll get it—no, _this_ time. The key, surely, was to slow down, _focus_, try _harder_. It was my first brush with a kind of frustration I’ve been stuck revisiting countless times since. Not the “throw a controller” kind, but the feeling that things were more complicated than they were supposed to be, and that I was unwittingly responsible for it, somehow. And me, I was _too_ focused, _too_ determined. I had gotten myself into a tightening spiral where getting frustrated meant I wasn’t trying hard ehough, and trying harder somehow only seemed to make things worse—messier, somehow—and even more frustrating. The things chasing me caught up, the bird became unpredictable, and even when I did manage to scrape by, it somehow felt like I was getting the right answer, but still doing the math wrong.

No, see—it did happen. I got past the bird now and then; even a sticking B-button is right twice a day, or whatever. But on the rare occasion that I did manage to swat down that lousy bird, it only revealed another, more insidious hazard: if I backtracked even a few pixels to regroup, then scrolled to the right again, there it was, the same bird, right back from hell. Well, “heck.” I was nine.

I’d seen this in other games, sure: when the screen hits a certain point, an enemy appears; scroll away and back, there it is again. I had never thought much about it, until that bird—that _bird_—drew my pinpoint focus. Why _did_ that happen, anyway? In fact, why did was _every_ game like that? Games don’t share _mechanics_. Toad couldn’t `GET EQUIPPED WITH METAL BLADE` and go tearing through Super Mario Bros. 2; why would all these disparate games share such a specific behavior?

It was here, in this moment, by the pale light of the “game over” screen, that it occurred to me that this is not part of the _game_. This behavior was part of the _system_—the NES itself. I didn’t understand how, or why, but I realized that that this was the machinery that allows the game to operate bubbling to the surface where I could see it. This was not about the rules inside a game, like how far the little blue ninja could jump—this was about how I, sitting on the living room floor, engaged with a vast, complex, but suddenly _knowable_ system of behaviors.

I mean, not in so many words. Again, nine years old. The realization in the moment was that the computer _doesn’t_ cheat. In fact, the computer isn’t even _playing_. The bird doesn’t just happen to be there, it _will_ be there. Until I start jumping around swinging at it, it always swoops along the exact same path—it has to. If I always start _here_, I can know exactly where it’s going to go. If I’m always moving forward, the timing will always be the same. If I line myself up with where that bird will appear, and mash the B button at exactly the right time—aiming at an empty space—the hit will connects just as the bird appears.

I could see the grain, now. If that’s how it works on this bird, that’s how it will work on the next bird—the entire next screen, and the one after that, and the whole level. If I never stopped moving, there would be a single, knowable path through the entire game, start to finish—a line carved through every level, a drumbeat pattern to every boss fight. The computer has to follow the rules. _I_ get to cheat.

I went on to beat _Ninja Gaiden II: The Dark Sword of Chaos_, as though there were ever any doubt. I mean, I was the chosen whatsit, I had the legendary sword of somesuch, that the evil what’s-his-face should be felled by my hand was foretold in the prophecies of _Nintendo Power_ magazine. The game itself wasn’t that important in the grand scheme of things (though it was, and remains, an absolute start-to-finish banger). What mattered was a feeling I’ve been chasing ever since: _fast_. That moment where the game is suddenly fun again—the line appears, clear as day, and a scramble turns into a flow. The last pin in the tumbler clicks into place. The scissors start their glide through the wrapping paper. 

I wanted to go fast. I wanted to go _faster_—faster than I was supposed to.

Listen. You’ve been patient, humoring me like this. This isn’t a book about misspent youth and the combined powers of determination and blue raspberry quarter waters from the convenience store down the street. This is a book about making websites.

The year is 2011. I am nine years old, and the computer cheats.

In fact, I’m not sure I’d ever been more nine years old than 2010, up to and including the time where I had been on Earth for a sum total of nine chronological years. I was surrounded by absolute web development giants at Filament Group. I’d somehow fooled everyone there into letting me work on the nascent Boston Globe project, despite my entire career being an obvious, if carefully constructed, lie. _The creator of jQuery_ was eating his lunch at a table across from me—several tiny dorks stacked in a trenchcoat—while I struggled to find “home row” on my keyboard.

It was the early days of Responsive Web Design, and everything about web development suddenly felt messier and more complicated than it was supposed to be. 






The key, surely, was to slow down, _focus_, try _harder_. It was my first brush with a kind of frustration I’ve been stuck revisiting countless times since. Not the “throw a controller” kind, but the feeling that things were more complicated than they were supposed to be, and that I was unwittingly responsible for it, somehow—but I was _too_ focused, _too_ determined, and had gotten myself into a tightening spiral where getting frustrated surely meant I wasn’t trying hard ehough, and trying harder somehow only seemed to make things worse—messier, somehow. The things chasing me caught up, the spider flung fireballs at me, the bird became unpredictable, and even when I’d manage to scrape by it would feel like I was getting the right answer, somehow, but still doing the math wrong.


Every time it felt like something had fallen into place, something else fell out of it. I imagine this feeling will be more familiar to most of you than “getting big mad about a Nintendo bird.”


The game sucked; the computer cheats. Everything felt so _slow_.




---

The year is 200X. I still don’t go outside much.

Could I use the knockback I so loathed in my youth to knock myself somewhere I’m not supposed to be, and skip a whole section? If I get hit, I get a split-second of invincibility—can I use that to run across a bed of otherwise-deadly spikes? My momentum builds as I fall, but if I pause, the momentum starts over—if I mash the pause button at the right time, could I nudge myself just a little further to the left and right in mid-air, and clear a jump I’m not meant to? Could I use the rules of the system to break the game—to carve a new line? To go even _faster_?

---







### The Critical Rendering Path

For a long time, my mental model for the sequence of events that play out when you land on a page looked something like: “as the the browser parses the page markup it looks for external files. When it finds them, it transfers them up to two at a time, parses them, and applies whatever they are to the page.” Not _strictly_ wrong—at least, at the time—but a little lacking for nuance.

> The critical rendering path refers to the steps involved until the web page starts rendering in the browser. To render pages, browsers need the HTML document itself as well as all the critical resources necessary for rendering that document.
> …
> The rendering path involves the following steps:

>  - Constructing the Document Object Model (DOM) from the HTML.
>  - Constructing the CSS Object Model (CSSOM) from the CSS.
>  - Applying any JavaScript that alters the DOM or CSSOM.
>  - Constructing the render tree from the DOM and CSSOM.
>  - Perform style and layout operations on the page to see what elements fit where.
>  - Paint the pixels of the elements in memory.
>  - Composite the pixels if any of them overlap.
>  - Physically draw all the resulting pixels to screen.
> https://web.dev/learn/performance/understanding-the-critical-path

> The Critical Rendering Path is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen. Optimizing the critical render path improves render performance. The critical rendering path includes the Document Object Model (DOM), CSS Object Model (CSSOM), render tree and layout. 
> …
> Web performance includes the server requests and responses, loading, scripting, rendering, layout, and the painting of the pixels to the screen.
> 
> A request for a web page or app starts with an HTTP request. The server sends a response containing the HTML. The browser then begins parsing the HTML, converting the received bytes to the DOM tree. The browser initiates requests every time it finds links to external resources, be it stylesheets, scripts, or embedded image references. Some requests are blocking, which means the parsing of the rest of the HTML is halted until the imported asset is handled. The browser continues to parse the HTML making requests and building the DOM, until it gets to the end, at which point it constructs the CSS object model. With the DOM and CSSOM complete, the browser builds the render tree, computing the styles for all the visible content. After the render tree is complete, layout occurs, defining the location and size of all the render tree elements. Once complete, the page is rendered, or 'painted' on the screen.
> https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path


### The Critical Rendering Path
- Measuring Performance
  + Testing tools and fundamentals
    * CWV
      - ~First Contentful Paint (FCP)~ -> Largest Contentful Paint (LCP)
      - First Input Delay (FID)/Total Blocking Time (TBT) 
      - Cumulative Layout Shift (CLS) 
      - Time to Interactive (TTI)
        + Interaction to Next Paint (INP)
    * Lighthouse
    * WebPageTest
  + Setting goals 
