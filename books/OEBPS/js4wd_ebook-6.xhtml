<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
	<head>
		<title>js4wd_ebook-6</title>
		<link href="css/ABA.css" rel="stylesheet" type="text/css" />
	</head>
	<body id="js4wd_ebook-6" lang="en-US" xml:lang="en-US">
		<div id="_idContainer055">
			<h1 id="_idParaDest-3" class="chTitle"><a id="_idTextAnchor003"></a>Chapter 2. Understanding Data<span class="NoBreak"> Types</span></h1>
			
				<div id="_idContainer032" class="ch_open_img _idGenObjectStyle-Disabled">
					<img src="image/2.png" alt="" />
				</div>
			
			<p class="BodyFirstParagraph"><span class="ChapterIntro">THINGS ARE ABOUT TO GET REAL. </span></p>
			<p class="Body">By the end of this chapter, you’ll have a sense for the types of data you’ll encounter during your JavaScript-writing travels. Some types of data will seem self-explanatory, at least on the surface: numbers are numbers, strings of text are strings of text. Some types of data will veer a little more toward the philosophical-sounding: <code class="CodeInline">true</code>, as a keyword in JavaScript, represents the very essence of<span class="NoBreak"> trueness.</span></p>
			<p class="Body">Things go a bit deeper than that, however, and sometimes in particularly confusing ways. Numbers can be <em class="Emphasis">truthy</em> or <em class="Emphasis">falsy</em>, while text will always be truthy. <a id="_idIndexMarker043"></a><code class="CodeInline">NaN</code>—a JavaScript keyword meaning “not a number”—is itself something JavaScript considers to be a number. <code class="CodeInline">({}+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]</code> is perfectly valid JavaScript.<span class="NoBreak"> </span><span class="NoBreak">Really.</span></p>
			<p class="Body">It’s not hard to see where JavaScript gets a reputation for being difficult to understand intuitively—the statements above read more like a riddle than the rules of a scripting language. There are methods to the madness, however, and getting the hang of JavaScript’s data types is how we start learning to think like<span class="NoBreak"> JavaScript.</span></p>
			<p class="Body">JavaScript is a “weakly typed” language, meaning that we don’t have to be explicit about whether something should be treated as a number or a string of text. Unlike a “strongly typed” language—which requires us to define data as a certain type—JavaScript infers the meaning from context. This makes sense, considering that more often than not, we’ll want <code class="CodeInline">7</code> to be treated as a number and not a string of<span class="NoBreak"> text.</span></p>
			<p class="Body">In the event that we <em class="Emphasis">do</em> want something handled as a specific type, there are a number of ways to perform <a id="_idIndexMarker044"></a><em class="Emphasis">type coercion</em>, which changes the way JavaScript interprets data. Fortunately, we don’t need to worry about that yet, so let&apos;s take a look at the data types<span class="NoBreak"> themselves.</span></p>
			<h2 class="AHead">PRIMITIVE TYPES</h2>
			<p class="BodyFirstParagraph">We hold some data types to be self-evident, and <a id="_idIndexMarker045"></a><em class="Emphasis">primitive</em> data types are exactly that. Primitive types can’t be reduced any further than what they already are: a number is a number, <code class="CodeInline">true</code> is true. Primitives are the simplest form of data in JavaScript: numbers, strings, <code class="CodeInline">undefined</code>, <code class="CodeInline">null</code>, and <code class="CodeInline">true</code> and<span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">false</code></span><span class="NoBreak">.</span></p>
			<h3 class="BHead">Numbers</h3>
			<p class="BodyFirstParagraph">The <a id="_idIndexMarker046"></a>number type is a set of all possible number values. JavaScript is pretty good at numbers, up to a point. If you punch <code class="CodeInline">7</code> into your console and hit return, the result shouldn’t be too surprising: the output is <span class="CodeConsoleInline">7</span>. JavaScript has acknowledged that this is the number seven. You and I, we have done strong work with the JavaScript console<span class="NoBreak"> today.</span></p>
			<p class="Body">There are a few special cases under the number umbrella: the “not a number” value (<code class="CodeInline">NaN</code>), and a value representing infinity, which can be either positive (<code class="CodeInline">Infinity</code>) or negative  (<code class="CodeInline">-Infinity</code>). If you type either of these into your console and press return, you’ll get them echoed back to you just like the <span class="CodeConsoleInline">7</span>—which is really just JavaScript saying, “I am aware of this concept.” If you try entering <code class="CodeInline">infinity</code> or <code class="CodeInline">Nan</code>, however, both of those will come back as <span class="CodeConsoleInline">undefined</span>—remember, JavaScript is case-sensitive.</p>
			<p class="Body">Likewise, it shouldn’t come as too much of a surprise that we can use mathematical operators in JavaScript, which play out just the way you might expect. If you enter <code class="CodeInline">2+2</code> in your console, JavaScript will return<span class="NoBreak"> </span><span class="NoBreak"><span class="CodeConsoleInline">4</span></span><span class="NoBreak">.</span></p>
			<p class="Body">A lot of these operators will be familiar, even to those of us that just <em class="Emphasis">barely</em> scraped by in high school algebra classes (ahem); a few operators are more unique to programming (<span class="FigureNumberInline">FIG 2.1</span>).</p>
			
				<div id="_idContainer035" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer033" class="figure grouped">
						<img src="image/3.png" alt="Figure" />
					</div>
					<div id="_idContainer034" class="figure">
						<p class="FigureCaption"><span class="FigureNumber"><span class="FigureNumber">FIG 2.1</span></span><span class="FigureNumber">:</span> There won’t be a quiz, I<span class="NoBreak"> promise.</span></p>
					</div>
				</div>
			
			<p class="Body">The mathematical <a id="_idIndexMarker047"></a>Order of Operations applies here: any expressions wrapped in parentheses are evaluated first, followed by exponents, multiplication, division, addition, and subtraction. I bet you never thought you’d be hearing the phrase “Please Excuse My Dear Aunt Sally” again, but time and math make fools of us<span class="NoBreak"> all</span><span class="NoBreak">.</span></p>
			<pre class="Code">2*2-2</pre>
			<pre class="Code"><span class="CodeConsole">2</span></pre>
			<pre class="Code">2*(2-2)</pre>
			<pre class="Code"><span class="CodeConsole">0</span></pre>
			<p class="Body">You’re not apt to run into <code class="CodeInline">Infinity</code> or <code class="CodeInline">NaN</code> too often during the course of your JavaScript career—at least, not on purpose. If you try out <code class="CodeInline">2/0</code> in the console, assuming your computer doesn&apos;t collapse into a singularity, JavaScript will return<span class="NoBreak"> </span><span class="NoBreak"><span class="CodeConsoleInline">Infinity</span></span><span class="NoBreak">.</span></p>
			<p class="Body"><code class="CodeInline">NaN</code> is a special case we’ll see a bit more frequently. Any time we try to treat non-numbers as numbers, JavaScript will return <span class="CodeConsoleInline">NaN</span>—for example, if we take the phrase <code class="CodeInline">&quot;Hello, World.&quot;</code> that we tried out in <code class="CodeInline">console.log</code> earlier and multiply it by two (<code class="CodeInline">&quot;Hello, World.&quot; * 2</code>), we’ll get <span class="CodeConsoleInline">NaN</span> as a result. JavaScript doesn’t know what you’re supposed to get when you multiply a word by a number, but it knows for sure that whatever you’d end up with wouldn’t be a<span class="NoBreak"> number.</span></p>
			<h3 class="BHead">Strings</h3>
			<p class="BodyFirstParagraph"><a id="_idIndexMarker048"></a>Strings of text are quite possibly the simplest data type to understand. Any set of characters—letters, numbers, symbols, and so on—between a set of double or single quotes is a “string.”</p>
			<p class="Body">As a matter of fact, we’ve already been introduced to strings—when we wrote <code class="CodeInline">console.log(&quot;Hello, </code><code class="CodeInline">World.&quot;);</code> in the console in the previous chapter, <code class="CodeInline">&quot;Hello, </code><code class="CodeInline">World.&quot;</code> was a string. We would see the same result with single quotes, as in <code class="CodeInline">console.log(&apos;Hello, World.&apos;);</code> (<span class="FigureNumberInline">FIG 2.2</span>).</p>
			
				<div id="_idContainer038" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer036" class="figure">
						<img src="image/Fig_2.2_b.png" alt="Figure" />
					</div>
					<div id="_idContainer037" class="figure">
						<p class="FigureCaption"><span class="FigureNumber"><span class="FigureNumber">FIG 2.2</span></span><span class="FigureNumber">:</span><span class="FigureNumber"> </span>Double quotes and single quotes give us the exact same result. In your face, Strunk &amp;<span class="NoBreak"> White.</span></p>
					</div>
				</div>
			
			<p class="Body">Single and double quotes are functionally identical as long as you pair them properly, and a string using double quotes can contain single quotes, or vice-versa (<span class="FigureNumberInline">FIG 2.3</span>).</p>
			
				<div id="_idContainer041" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer039" class="figure">
						<img src="image/Fig_2.3_b.png" alt="Figure" />
					</div>
					<div id="_idContainer040" class="figure">
						<p class="FigureCaption"><span class="FigureNumber">FIG 2.3:</span> All’s well, so long as our quotes are paired<span class="NoBreak"> properly.</span></p>
					</div>
				</div>
			
			<p class="Body">If we <em class="Emphasis">omit</em> the quotes, however, the results are very different. Without quotation marks, JavaScript attempts to read <code class="CodeInline">Hello, World.</code> as part of the script rather than as a string of text, and throws a syntax error (<span class="FigureNumberInline">FIG 2.4</span>).</p>
			
				<div id="_idContainer044" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer042" class="figure">
						<img src="image/Fig_2.4.png" alt="Figure" />
					</div>
					<div id="_idContainer043" class="figure">
						<p class="FigureCaption"><span class="FigureNumber"><span class="FigureNumber">FIG 2.4</span></span><span class="FigureNumber">:</span> Uh-oh.</p>
					</div>
				</div>
			
			<p class="Body">Strings are refreshingly uncomplicated: just some letters and/or numbers inside of a set of quotes. There’s one other important facet to strings, though: we can create new ones by joining them together, or joining them with a<span class="NoBreak"> number.</span></p>
			<p class="Body">Combining multiple sources into a single string is called <a id="_idIndexMarker049"></a><em class="Emphasis">string concatenation</em>. You can join two or more strings by using a plus sign, which pulls double-duty for both mathematical addition and string concatenation, depending on its surrounding context (<span class="FigureNumberInline">FIG 2.5</span>).</p>
			
				<div id="_idContainer047" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer045" class="figure">
						<img src="image/Fig_2.5.png" alt="Figure" />
					</div>
					<div id="_idContainer046" class="figure">
						<p class="FigureCaption"><span class="FigureNumber"><span class="FigureNumber">FIG 2.5</span></span><span class="FigureNumber">:</span> The sequels are never as good as the<span class="NoBreak"> originals.</span></p>
					</div>
				</div>
			
			<p class="Body">When dealing with strings instead of numbers, <code class="CodeInline">+</code> doesn’t attempt to perform mathematical addition. Instead, it concatenates two data types into a single string. Even though the above example contains a number, involving a string at all means JavaScript treats <code class="CodeInline">2</code> as a string as<span class="NoBreak"> well.</span></p>
			<h3 class="BHead"><span class="bHeadCode">undefined</span></h3>
			<p class="BodyFirstParagraph"><a id="_idIndexMarker050"></a><code class="CodeInline">undefined</code>, as you might expect, is the type for anything that isn’t predefined by JavaScript, or defined by us as part of our script. You’ve seen examples of this data type already: when we were playing around with case-sensitivity in our dev consoles, we entered a few things that JavaScript didn’t recognize, and got an error back (<span class="FigureNumberInline">FIG 2.6</span>).</p>
			
				<div id="_idContainer050" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer048" class="figure">
						<img src="image/Fig_2.6.png" alt="Figure" />
					</div>
					<div id="_idContainer049" class="figure">
						<p class="FigureCaption"><span class="FigureNumber"><span class="FigureNumber">FIG 2.6</span></span><span class="FigureNumber">:</span> We haven’t told JavaScript that <code class="FigureCode">sup</code> means anything, and JavaScript<span class="NoBreak"> is </span> lousy at<span class="NoBreak"> slang.</span></p>
					</div>
				</div>
			
			<p class="Body">If we use <code class="CodeInline">typeof</code>—an operator that returns a string indicating the type of unevaluated operand—to determine the type of <code class="CodeInline">sup</code>, we’ll see that it has a type of <span class="CodeConsoleInline">undefined</span>. <code class="CodeInline">sup</code> has no meaning or value, so far as JavaScript knows—we never gave it<span class="NoBreak"> one.</span></p>
			<h3 class="BHead"><span class="bHeadCode">null</span></h3>
			<p class="BodyFirstParagraph"><a id="_idIndexMarker051"></a><code class="CodeInline">null</code> represents a non-value: something that has been <em class="Emphasis">defined</em>, but has no inherent value. For example: we might define a variable as <code class="CodeInline">null</code> with the expectation that it gets assigned a value at some point in a script, or assign the <code class="CodeInline">null</code> value to an existing reference to zero out a previous<span class="NoBreak"> value.</span></p>
			<h3 class="BHead">Booleans</h3>
			<p class="BodyFirstParagraph"><a id="_idIndexMarker052"></a>Boolean values—the keywords <code class="CodeInline">true</code> and <code class="CodeInline">false</code>—represent inherent trueness and falseness. They’re concepts you’ll come across in any programming language. If we ask JavaScript to compare any two values and they come up equal, the entire statement evaluates to <span class="CodeConsoleInline">true</span>—if not,<span class="NoBreak"> </span><span class="NoBreak"><span class="CodeConsoleInline">false</span></span><span class="NoBreak">.</span></p>
			<p class="Body">Let’s take a look at our console again, and in doing so g<em class="Emphasis">aze into the very face of absolute universal</em><span class="NoBreak"><em class="Emphasis"> truth</em></span><span class="NoBreak">:</span></p>
			<pre class="Code">2 + 2 == 4</pre>
			<pre class="Code"><span class="CodeConsole">true</span></pre>
			<p class="Body">And while we’re at it, let’s use our developer console to put some Orwellian newspeak to the<span class="NoBreak"> test:</span></p>
			<pre class="Code">2 + 2 == 5</pre>
			<pre class="Code"><span class="CodeConsole">false</span></pre>
			<p class="Body">Okay, it may not seem quite as dramatic as I wanted it to sound, but these kinds of comparisons are the basis for a tremendous amount of scripting<span class="NoBreak"> logic.</span></p>
			<p class="Body">Note that we’re using <code class="CodeInline">==</code> to perform a comparison here, rather than the <code class="CodeInline">=</code> you might have expected: JavaScript sees a single equals sign as an attempt to <em class="Emphasis">assign</em> something a value, rather than performing a comparison between one value and another. More on this in a bit—and we’ll discuss comparison operators further in the next<span class="NoBreak"> chapter.</span></p>
			<h2 class="AHead"><a id="_idIndexMarker053"></a>OBJECT TYPES</h2>
			<p class="BodyFirstParagraph">The concept of “an object” in JavaScript maps nicely to the concept of an object here in the real world. In both cases, an object is a collection of <em class="Emphasis">properties</em> and <em class="Emphasis">methods</em>—that is, traits belonging to an object, and functions that the object can perform. In the real world, for example, “hammer” is an abstraction of properties (“handle,” “a weighted striking surface”) and purposes (“hitting things”). But the concept of “hammer” is mutable: if we were to change the properties (“MC,” “unusual pants,” “cannot be touched”) and purposes (“breaking it down”), “hammer” comes to mean something altogether<span class="NoBreak"> different.</span></p>
			<p class="Body">An object in JavaScript is the same idea: a named, mutable collection of properties and methods. Outside of the primitive types listed above, every bit of JavaScript we write is an “object,” from the strings and numbers we define, up to the entire document<span class="NoBreak"> itself.</span></p>
			<p class="Body">That sounds a little overwhelming, but the specific types of objects we’re apt to run into day-to-day are clearly<span class="NoBreak"> differentiated</span><span class="NoBreak">.</span></p>
			<h3 class="BHead">Variables</h3>
			<p class="BodyFirstParagraph">A <a id="_idIndexMarker054"></a>variable is a symbolic name for a value. Like so many <em class="Emphasis">x</em>’s in so many eighth-grade algebra classes, variables in JavaScript act as containers for a value that can be any kind of data: strings, numbers, elements we’ve retrieved via the DOM, even entire functions. They give us a single point of reference for that value, to be used in all or part of our script. We can modify the value of that variable at any time and in whatever ways we<span class="NoBreak"> want.</span></p>
			<p class="Body">There are two ways to declare a variable, both of which use the single equals sign, which performs an <em class="Emphasis">assignment</em> rather than making a comparison. The simplest way to declare a variable doesn’t use much else, really: we specify the identifier, and use a single <code class="CodeInline">=</code> to assign it a<span class="NoBreak"> value.</span></p>
			<pre class="Code">foo = 5;</pre>
			<pre class="Code"><span class="CodeConsole">5</span></pre>
			<p class="Body">When we first create a variable, our console acknowledges us by parroting back the new variable’s<span class="NoBreak"> value.</span></p>
			<p class="Body">If we now punch in <code class="CodeInline">foo</code> and hit enter, we get the same result—we’ve made JavaScript aware of a variable named <code class="CodeInline">foo</code>, and defined its value as the number five. Once defined, the behavior of a variable is identical to the data it contains. Checking the type of variable <code class="CodeInline">foo</code> using <code class="CodeInline">typeof</code> is<span class="NoBreak"> revealing</span><span class="NoBreak">:</span></p>
			<pre class="Code">foo = 5;</pre>
			<pre class="Code"><span class="CodeConsole">5</span></pre>
			<pre class="Code">foo;</pre>
			<pre class="Code"><span class="CodeConsole">5</span></pre>
			<pre class="Code">typeof foo;</pre>
			<pre class="Code"><span class="CodeConsole">&quot;number&quot;</span></pre>
			<p class="Body"><code class="CodeInline">foo</code>’s type is now “number,” not “variable.”  As far as Java<span class="NoBreak">Script</span> is concerned, the variable <code class="CodeInline">foo</code> is functionally identical to the number five. That’s not a permanent condition, however: we can reuse a variable by assigning it a new<span class="NoBreak"> value.</span></p>
			<pre class="Code">foo = 5;</pre>
			<pre class="Code"><span class="CodeConsole">5</span></pre>
			<pre class="Code">foo = 10;</pre>
			<pre class="Code"><span class="CodeConsole">10</span></pre>
			<p class="Body">We can even reassign a value to a variable using the variable<span class="NoBreak"> itself:</span></p>
			<pre class="Code">foo = 100;</pre>
			<pre class="Code"><span class="CodeConsole">100</span></pre>
			<pre class="Code">foo = foo * foo;</pre>
			<pre class="Code"><span class="CodeConsole">10000</span></pre>
			<p class="Body">Of course, we won’t always know upfront what value our variable should contain. The whole idea, after all, is that variables can represent any number of values in a predictable, easy-to-reference package. In the event that we don’t need or want our variable to have a starting value, we can still make JavaScript aware of it. Using <code class="CodeInline">var foo;</code>, we declare a new variable (<code class="CodeInline">foo</code>) as <code class="CodeInline">undefined</code>, as confusing as that might sound. So “foo” is now a word that JavaScript identifies as a variable, but without any assigned value. Try this out in your JavaScript console and you’ll see what I<span class="NoBreak"> mean.</span></p>
			<pre class="Code">var bar;</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">bar;</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">whatever;</pre>
			<pre class="Code"><span class="CodeConsole">Uncaught ReferenceError: whatever is not </span><span class="CodeConsole">defined</span></pre>
			<p class="Body">We defined <code class="CodeInline">bar</code> as a variable, so when we enter it into our console, the <a id="_idIndexMarker055"></a>REPL dutifully parrots its value back to us. That value, since we didn’t give it one, is <a id="_idIndexMarker056"></a><span class="CodeConsoleInline">undefined</span>. If we try the same thing with a variable we haven’t defined—<code class="CodeInline">whatever</code>, in this case—JavaScript throws an<span class="NoBreak"> error.</span></p>
			<p class="Body">Note that <code class="CodeInline">var</code> up there? It&apos;s not required that you use the <code class="CodeInline">var</code> keyword to declare a variable if you&apos;re assigning it a value immediately, but for reasons I’ll explain soon, it’s a good idea to always declare your variables with the <code class="CodeInline">var</code> keyword even when it&apos;s not required. Similarly, though it isn’t always required by the rules of JavaScript, it’s best to always end variable assignments with a<span class="NoBreak"> semicolon.</span> </p>
			<pre class="Code">var foo = 5;</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">Don’t sweat your console’s <span class="CodeConsoleInline">undefined</span> response after assigning a value to an identifier—the JavaScript engine doesn’t actually have anything to output in response to tasks like declaring a variable, so we get <span class="CodeConsoleInline">undefined</span> in<span class="NoBreak"> return.</span></p>
			<p class="Body">We can also declare more than one variable at once. As with so many things in JavaScript, we have a couple of options for defining multiple variables, using two different but equivalent syntaxes. The first uses a single <code class="CodeInline">var</code> keyword and splits the sets of variable names and assigned data with commas (ending with a semicolon, of course):</p>
			<pre class="Code">var foo = &quot;hello&quot;,</pre>
			<pre class="Code">bar = &quot;world&quot;,</pre>
			<pre class="Code">baz = 3;</pre>
			<p class="Body">The second method uses individual <code class="CodeInline">var</code><span class="NoBreak"> keywords</span><span class="NoBreak">:</span></p>
			<pre class="Code">var foo = &quot;hello&quot;;</pre>
			<pre class="Code">var bar = &quot;world&quot;;</pre>
			<pre class="Code">var baz = 3;</pre>
			<p class="Body">There are no catches, in this case. These two syntaxes work the exact same way, and choosing one over the other is entirely a matter of personal preference. This, of course, means that it is a <em class="Emphasis">hotly contested</em> subject in JavaScript developer<span class="NoBreak"> circles.</span></p>
			<p class="Body">Now, it would be irresponsible of me to foist my personal opinion on you here, reader, so I’ll leave it at this: always adhere to the existing code conventions of a project, rather than mixing and matching. On a brand-new project, use whichever syntax you find the most comfortable, but keep an open mind—we have trickier problems to solve than fighting over personal preferences. And when in doubt: do the thing that I like best, because I am<span class="NoBreak"> right.</span></p>
			<p class="Body">No, really, use whichever one you find more<span class="NoBreak"> comfortable.</span></p>
			<p class="Body">Pretty sure I’m right,<span class="NoBreak"> though.</span></p>
			<h4 class="CHead">Identifiers</h4>
			<p class="BodyFirstParagraph">The name we give a variable is called an<span class="NoBreak"> </span><span class="NoBreak"><a id="_idIndexMarker057"></a></span><span class="NoBreak"><em class="Emphasis">identifier</em></span><span class="NoBreak">.</span></p>
			<p class="Body">Like everything in JavaScript, identifiers are case-sensitive, and come with a few special rules, as<span class="NoBreak"> well:</span></p>
			<ul>
				<li class="BodyBulletList">They must start with a letter, underscore, or dollar sign—not a number. </li>
				<li class="BodyBulletList">They can’t contain spaces. </li>
				<li class="BodyBulletList">They can’t contain special characters (<code class="CodeInline">! . , / \ + - * =</code>).</li>
			</ul>
			<p class="Body">There are a set of words in JavaScript that can’t be used as identifiers, like null, for example. These are called <a id="_idIndexMarker058"></a><em class="Emphasis">keywords</em>—words that already have an immutable meaning to JavaScript, or are set aside just in case they get added to JavaScript one<span class="NoBreak"> day:</span></p>
			<pre class="Code">abstract boolean break byte case catch char class const continue debugger default delete do double else enum export extends false final finally float for function goto if implements import in instanceof int interface long native new null package private protected public return short static super switch synchronized this throw throws transient true try typeof var void volatile while with</pre>
			<p class="Body">That’s a scary block of words, but this isn’t something you need to have committed to memory—I certainly don’t. It does make a good case for an editor with <a id="_idIndexMarker059"></a>syntax highlighting, though, which can help you avoid mysterious-seeming errors when assigning an identifier to a variable (<span class="FigureNumberInline">FIG 2.7</span>).</p>
			
				<div id="_idContainer054" class="figure _idGenObjectStyle-Disabled">
					
					<div id="_idContainer052" class="figure">
						<img src="image/Fig_2.7.png" alt="Figure" />
					</div>
					<div id="_idContainer053" class="figure">
						<p class="FigureCaption"><span class="FigureNumber"><span class="FigureNumber">FIG 2.7</span></span><span class="FigureNumber">:</span> Syntax highlighting can make it easier to catch errors on the<span class="NoBreak"> fly.</span></p>
					</div>
				</div>
			
			<p class="Body">Outside of these rules, an identifier can contain any combination of letters, digits, and underscores. It’s a good idea to use identifiers that are brief (<code class="CodeInline">totalCost</code> vs. <code class="CodeInline">valueOfAllItemsIncTaxAndShipping</code>) and easy to understand at a glance (<code class="CodeInline">selectedValue</code> vs. <code class="CodeInline">v1</code>). The “foo,” “bar,” and “baz” that I’ve been using in my examples are lousy identifiers—the words have no meaning whatsoever, so coming across them in a script would give you no clues as to the nature of the data they contain. At the same time, we should avoid identifiers that describe their potential values in t<em class="Emphasis">oo much</em> detail, since we may not always be able to immediately predict the values a variable will contain. A variable originally named <code class="CodeInline">miles</code> may need to contain a value in kilometers one day—confusing for the developers who end up maintaining that code, ourselves included. <code class="CodeInline">distance</code> works much<span class="NoBreak"> better.</span></p>
			<h4 class="CHead">Variable<span class="NoBreak"> scope</span></h4>
			<p class="BodyFirstParagraph">We’ll get into this more when we look at functions, but we can’t talk about variables without discussing something called <a id="_idIndexMarker060"></a><em class="Emphasis">variable</em><span class="NoBreak"><em class="Emphasis"> scope</em></span><span class="NoBreak">.</span></p>
			<p class="Body">Think of variable scope as the section of your source code where you’ve assigned something an identifier. Outside of that section, that variable is not defined, and the identifier may be reused for something else. JavaScript applications can be huge, with tens of thousands of lines of code being parsed and executed. Because variables have their own scope, we can elect to make them available to the entire application <em class="Emphasis">or</em> constrained to individual sections of our code, so we don’t have hundreds of variables potentially tripping us up throughout an application. If we had to keep a mental inventory of what identifiers were already in use so we didn’t run the risk of accidentally reusing or redefining a variable, we <em class="Emphasis">would</em> need those special programmer robot-brains we talked about at the<span class="NoBreak"> outset.</span></p>
			<p class="Body">There are two kinds of variable scope: <a id="_idIndexMarker061"></a><em class="Emphasis">local</em> and <a id="_idIndexMarker062"></a><em class="Emphasis">global</em>. A variable defined outside of a function is global. And because global variables are, well, <em class="Emphasis">global</em>, they can be accessed anywhere in the entire<span class="NoBreak"> application.</span></p>
			<p class="Body">A variable defined <em class="Emphasis">inside</em> a function can be either local or global, depending on how we define it—which really comes down to whether we declare it by using the keyword <code class="CodeInline">var</code>. Inside a function, <code class="CodeInline">var</code> declares a variable in that function’s local scope, but omitting <code class="CodeInline">var</code> means that variable should be global—in other words, exposed to the entire<span class="NoBreak"> application.</span></p>
			<pre class="Code">(function() {</pre>
			<pre class="Code">  var foo = 5;</pre>
			<pre class="Code">}());</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">console.log( foo );</pre>
			<pre class="Code"><span class="CodeConsole">Uncaught ReferenceError: foo is</span><span class="CodeConsole"> not defined</span></pre>
			<p class="Body">Variable scope is a complicated topic, and we’ll get into the gritty details when we start learning about functions. For now, just know that it’s a good idea to always define your variables using <code class="CodeInline">var</code>. Always using <code class="CodeInline">var</code> means local variables stay local and global variables stay global—which means we don’t spend hours of debugging time trying to track down the function that unexpectedly changed a global variable’s value. And when the time comes to expose a local variable to the global scope, we’ll talk through better ways of doing it than omitting<span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">var</code></span><span class="NoBreak">.</span></p>
			<h3 class="BHead">Arrays</h3>
			<p class="BodyFirstParagraph"><a id="_idIndexMarker063"></a>Arrays aren’t all that different from variables, with one major exception: while a variable contains a single value, an array can contain multiple values, like a list. The syntax is similar to variables’ syntax,<span class="NoBreak"> </span><span class="NoBreak">too:</span></p>
			<pre class="Code">var myFirstArray = [ &quot;item1&quot;, &quot;item2&quot; ];</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">This should look pretty familiar: a <code class="CodeInline">var</code> keyword, followed by an identifier that we think up, and then a single equals sign to perform an assignment. All the same identifier rules apply here, too—in fact, all the rules of variables apply to arrays, including<span class="NoBreak"> scope.</span></p>
			<p class="Body">Things differ a little beyond that, though: instead<span class="NoBreak"> of </span> pointing the identifier at a single data type, we create<span class="NoBreak"> a </span> list—in this example, a pair of strings—inside a set<span class="NoBreak"> of </span> square brackets and separated by a comma. Remember that spaces inside the array don’t matter—they’re just a matter of personal preference. <code class="CodeInline">var</code><code class="CodeInline"> myFirstArray = [ &quot;item1&quot;, &quot;item2&quot; ];</code> is 100% identical, so far as JavaScript cares,<span class="NoBreak"> to </span> <code class="CodeInline">var myFirstArray=[&quot;item1&quot;,&quot;item2&quot;];</code>. I just find the former a little easier to<span class="NoBreak"> read.</span></p>
			<p class="Body">Just as with variables, arrays can be made up of any data<span class="NoBreak"> types:</span></p>
			<pre class="Code">var myFirstArray = [ &quot;item1&quot;, 2, 3, true, &quot;last item&quot; ];</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">When we punch that identifier into our developer console, the console parrots back the value, just like a<span class="NoBreak"> variable</span><span class="NoBreak">:</span></p>
			<pre class="Code">var myFirstArray = [ &quot;item1&quot;, 2, 3, true, &quot;last item&quot; ];</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">myFirstArray</pre>
			<pre class="Code"><span class="CodeConsole">[&quot;item1&quot;, 2, 3, true, &quot;last item&quot;]</span></pre>
			<p class="Body">We likely won’t need to access the entire array all at once, though. We’re much more likely to use an array to package up several items of related data, with intent to access them individually. We access them using <a id="_idIndexMarker064"></a><em class="Emphasis">indexes</em>: numbers that correspond with the positions within the<span class="NoBreak"> array.</span></p>
			<pre class="Code">var mySecondArray = [ &quot;first&quot;, &quot;second&quot;, &quot;third&quot; ];</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">mySecondArray;</pre>
			<pre class="Code"><span class="CodeConsole">[&quot;first&quot;, &quot;second&quot;, &quot;third&quot;]</span></pre>
			<pre class="Code">mySecondArray[ 0 ];</pre>
			<pre class="Code"><span class="CodeConsole">&quot;first&quot;</span></pre>
			<pre class="Code">mySecondArray[ 1 ];</pre>
			<pre class="Code"><span class="CodeConsole">&quot;second&quot;</span></pre>
			<pre class="Code">mySecondArray[ 2 ];</pre>
			<pre class="Code"><span class="CodeConsole">&quot;third&quot;</span></pre>
			<p class="Body">You may note that JavaScript breaks with an easy assumption here: while you might expect the first item in the array to correspond with the index <code class="CodeInline">1</code>, JavaScript is <a id="_idIndexMarker065"></a><em class="Emphasis">zero-indexed</em>, which means that JavaScript starts indexing at <code class="CodeInline">0</code> and counts up from<span class="NoBreak"> there.</span></p>
			<p class="Body">When we reference a position within an array using an index, it isn’t much different from working with variables: any reference to an array position takes on the data type of the data it contains—and just like a variable, we can reassign data to a given array position using a single equals<span class="NoBreak"> sign.</span></p>
			<pre class="Code">var mySecondArray = [ &quot;first&quot;, &quot;second&quot;, &quot;third&quot; ];</pre>
			<pre class="Code">mySecondArray[ 2 ];</pre>
			<pre class="Code"><span class="CodeConsole">&quot;</span><span class="CodeConsole">third&quot;</span></pre>
			<pre class="Code">typeof mySecondArray[ 2 ];</pre>
			<pre class="Code"><span class="CodeConsole">&quot;string&quot;</span></pre>
			<pre class="Code">mySecondArray[ 2 ] = 3;</pre>
			<pre class="Code"><span class="CodeConsole">3</span></pre>
			<pre class="Code">mySecondArray;</pre>
			<pre class="Code"><span class="CodeConsole">[&quot;first&quot;, &quot;second&quot;, 3]</span></pre>
			<pre class="Code">typeof mySecondArray[ 2 ];</pre>
			<pre class="Code"><span class="CodeConsole">&quot;number&quot;</span></pre>
			<pre class="Code">mySecondArray[ 3 ] = &quot;numero cuatro&quot;;</pre>
			<pre class="Code"><span class="CodeConsole">&quot;numero quattro&quot;</span></pre>
			<pre class="Code">mySecondArray;</pre>
			<pre class="Code"><span class="CodeConsole">[&quot;first&quot;, &quot;</span><span class="CodeConsole">second&quot;, 3, &quot;numero cuatro&quot;]</span></pre>
			<p class="Body">So far, we’ve only used brackets when initializing an array—and we’ll always want to use <a id="_idIndexMarker066"></a>brackets when <em class="Emphasis">accessing</em> information in an array—but there’s an alternative method for initializing an<span class="NoBreak"> array:</span></p>
			<pre class="Code">var myFirstArray = new Array( &quot;item1&quot;, &quot;item2&quot; );</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">myFirstArray;</pre>
			<pre class="Code"><span class="CodeConsole">[&quot;item1&quot;, &quot;item2</span><span class="CodeConsole">&quot;]</span></pre>
			<p class="Body">As we’ve used them here, with strings, there’s really no difference between using brackets and using the <code class="CodeInline">new Array()</code><span class="NoBreak"> syntax.</span></p>
			<p class="Body">Likewise, we can use either the bracket syntax or<span class="NoBreak"> the </span> <code class="CodeInline">new Array()</code> syntax to initialize an array with no defined items, just like we can initialize a variable but leave it undefined. To do this, we use either an empty set of brackets or the <code class="CodeInline">new</code><code class="CodeInline"> Array()</code> syntax with nothing in the<span class="NoBreak"> parentheses:</span></p>
			<pre class="Code">var arrayThree = [];</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">var arrayFour = new Array();</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">Again, these are functionally identical: both syntaxes initialize an empty<span class="NoBreak"> array.</span></p>
			<p class="Body">There <em class="Emphasis">is</em> one thing that the <code class="CodeInline">new Array()</code> syntax can do that brackets can’t, and that’s initialize an array with a set number of items—even when those items are<span class="NoBreak"> undefined:</span></p>
			<pre class="Code">var threeItemArray = new Array( 3 );</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">threeItemArray</pre>
			<pre class="Code"><span class="CodeConsole">[</span><span class="CodeConsole">undefined × 3]</span></pre>
			<p class="Body">All this means is that a new array has been created, with three as-yet-undefined items. Beyond that, the behavior is the same as the arrays we’ve seen so far: you’re not limited to those three items, and you can set and access information the exact same<span class="NoBreak"> way.</span></p>
			<p class="Body">This syntax can get a little confusing, however: you’re passing the <code class="CodeInline">new Array()</code> syntax the number of items you want in the array the same way you’d pass it the data you wanted <em class="Emphasis">in</em> the array. That means you can end up with very different results from the bracket syntax when you’re storing number data types. JavaScript is smart enough to know that <em class="Emphasis">multiple</em> numbers in the <code class="CodeInline">new Array()</code> <a id="_idIndexMarker067"></a>parentheses mean you’re creating an array of<span class="NoBreak"> numbers:</span></p>
			<pre class="Code">var numberArray = [ 777, 42, 13, 289 ];</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">numberArray;</pre>
			<pre class="Code"><span class="CodeConsole">[777, 42, 13, 289]</span></pre>
			<pre class="Code">var otherNumberArray = new Array( 777, 42, 13, 289 );</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">otherNumberArray;</pre>
			<pre class="Code"><span class="CodeConsole">[</span><span class="CodeConsole">777, 42, 13, 289]</span></pre>
			<p class="Body">But if you’re looking to initialize an array containing a single item—and that item is a number type—we get very different results with the two different syntaxes. Bracket notation works as we might expect—an array containing a single item with the value we assigned<span class="NoBreak"> it:</span></p>
			<pre class="Code">var numberArray = [ 777 ];</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">numberArray;</pre>
			<pre class="Code"><span class="CodeConsole">[777</span><span class="CodeConsole">]</span></pre>
			<pre class="Code">numberArray[ 0 ];</pre>
			<pre class="Code"><span class="CodeConsole">777</span></pre>
			<p class="Body">With the <code class="CodeInline">new Array()</code> syntax, things get weird. We end up with an array containing seven hundred seventy-seven <em class="Emphasis">undefined</em><span class="NoBreak"> items.</span></p>
			<pre class="Code">var otherNumberArray = new Array( 777 );</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">otherNumberArray;</pre>
			<pre class="Code"><span class="CodeConsole">Array[777]</span></pre>
			<pre class="Code">otherNumberArray[ 0 ];</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">Now, I’ll be perfectly honest: I’ve never needed to initialize an array with a given number of <code class="CodeInline">undefined</code> items right off the bat—your mileage may vary, of course, but I get by just fine with bracket<span class="NoBreak"> notation.</span></p>
			<p class="Body">Once defined, arrays come with a number of associated methods for navigating and changing their data. For example, the <code class="CodeInline">.length</code> property on an array describes the number of items in that<span class="NoBreak"> array:</span></p>
			<pre class="Code">var theFinalArray = [ &quot;first item&quot;, &quot;second item&quot;, &quot;third item&quot; ];</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">theFinalArray.length;</pre>
			<pre class="Code"><span class="CodeConsole">3</span></pre>
			<p class="Body">And since the index itself is a plain ol’ number data type, we can get a little creative with how we access information in an<span class="NoBreak"> array:</span></p>
			<pre class="Code">var theFinalArray = [ &quot;first item&quot;, &quot;second item&quot;, &quot;third item&quot; ];</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code"><span class="CodeComment">// Get the last item in the array:</span></pre>
			<pre class="Code">theFinalArray[ theFinalArray.length - 1 ];</pre>
			<pre class="Code"><span class="CodeConsole">&quot;third item&quot;</span></pre>
			<p class="Body">Here we’re using the <code class="CodeInline">.length</code> of the array to find the index of the last item. Since an array can be any length, we can’t just use a number to get to the last item. We can use the <code class="CodeInline">.length</code> property to get a count of all the items in the array, so we know how many items it contains. JavaScript is <a id="_idIndexMarker068"></a>zero-indexed, though, so we can’t <em class="Emphasis">just</em> use the array’s length—there are three items in the array, but the indexes start counting at zero. Easy enough to deal with: we just subtract one from the array’s length—a number data type—to get the index of the last<span class="NoBreak"> item.</span></p>
			<h3 class="BHead">Objects and<span class="NoBreak"> Properties</span></h3>
			<p class="BodyFirstParagraph">An object can contain multiple values as <a id="_idIndexMarker069"></a><em class="Emphasis">properties</em>. Unlike an array that accepts a set of data types and assigns each item a numbered index, an object’s properties are named using<span class="NoBreak"> strings.</span></p>
			<pre class="Code">var myDog = {</pre>
			<pre class="Code">  &quot;name&quot; : &quot;Zero&quot;,</pre>
			<pre class="Code">  &quot;color&quot; : &quot;orange&quot;,</pre>
			<pre class="Code">  &quot;ageInYears&quot; : 3.5,</pre>
			<pre class="Code">  &quot;wellBehaved&quot; : false</pre>
			<pre class="Code">};</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">Each property is made of up a <a id="_idIndexMarker070"></a><em class="Emphasis">key/value</em><em class="Emphasis"> pair</em>. The “key” in “key/value” is a string we define that points to a value—as with naming a variable, we want our keys to have names that are predictable, flexible, and easy to understand. In the above example, the keys for each property of the <code class="CodeInline">myDog</code> object are <code class="CodeInline">name</code>, <code class="CodeInline">color</code>, <code class="CodeInline">ageInYears</code>, and <code class="CodeInline">wellBehaved</code>, and the respective values are the strings <code class="CodeInline">Zero</code> and <code class="CodeInline">orange</code>, the number <code class="CodeInline">3.5</code>, and the Boolean<span class="NoBreak"> <code class="CodeInline">false</code>.</span></p>
			<p class="Body">The properties of an object can themselves be treated as objects with properties of their own, allowing us to bundle up a tremendous amount of information in a highly portable<span class="NoBreak"> package.</span></p>
			<pre class="Code">var myDog = {</pre>
			<pre class="Code">  &quot;name&quot; : {</pre>
			<pre class="Code">    &quot;first&quot; :&quot;Zero&quot;,</pre>
			<pre class="Code">    &quot;middle&quot; : &quot;Baskerville&quot;,</pre>
			<pre class="Code">    &quot;last&quot; : &quot;Marquis&quot;</pre>
			<pre class="Code">  },</pre>
			<pre class="Code">  &quot;color&quot; : &quot;orange&quot;,</pre>
			<pre class="Code">  &quot;ageInYears&quot; : 3,</pre>
			<pre class="Code">  &quot;wellBehaved&quot;: false</pre>
			<pre class="Code">};</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">Remember that the <a id="_idIndexMarker071"></a>whitespace in these examples—the indentation, line breaks, and spaces around the colons—won’t matter to JavaScript. Those are just there to keep things human-readable.</p>
			<h4 class="CHead">Defining an<span class="NoBreak"> object</span></h4>
			<p class="BodyFirstParagraph">There are two ways to define a new object. One is with the <code class="CodeInline">new</code> keyword, whose syntax shouldn’t be entirely unfamiliar at this<span class="NoBreak"> point:</span></p>
			<pre class="Code">var myDog = new Object();</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">The second way is with <a id="_idIndexMarker072"></a><em class="Emphasis">object literal</em> notation: </p>
			<pre class="Code">var myDog = {};</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">Both of these work a lot like declaring a variable: we use the <code class="CodeInline">var</code> keyword, followed by an identifier and a single equals<span class="NoBreak"> sign.</span></p>
			<p class="Body">These two methods of defining an object work the same way, except for one major difference. The <code class="CodeInline">new</code> keyword requires us to first define an object, <em class="Emphasis">then</em> start filling it with<span class="NoBreak"> data:</span></p>
			<pre class="Code">var myDog = new Object();</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">myDog.nickname = &quot;Falsy&quot;;</pre>
			<pre class="Code"><span class="CodeConsole">&quot;Falsy&quot;</span></pre>
			<p class="Body">Object literal notation allows us to define <em class="Emphasis">and assign data to</em> an object all at<span class="NoBreak"> </span><span class="NoBreak">once:</span></p>
			<pre class="Code">var myDog = {</pre>
			<pre class="Code">  &quot;nickname&quot;: &quot;Falsy&quot;</pre>
			<pre class="Code">};</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">You’ll find that a lot of developers favor object literal notation for the sake of simplicity, and we’ll be doing the same in this and future<span class="NoBreak"> chapters.</span></p>
			<h4 class="CHead">Accessing and changing<span class="NoBreak"> properties</span></h4>
			<p class="BodyFirstParagraph">Once we’ve defined an object using either of the above methods, there are two ways to access and change the information inside an object: <a id="_idIndexMarker073"></a><em class="Emphasis">dot notation</em> and <a id="_idIndexMarker074"></a><em class="Emphasis">bracket </em><em class="Emphasis">notation</em>. </p>
			<p class="Body">To access information in an object’s property using dot notation, you use a period between the object identifier and the property<span class="NoBreak"> key.</span></p>
			<pre class="Code">var myDog = {</pre>
			<pre class="Code">  &quot;name&quot;: &quot;Zero&quot;</pre>
			<pre class="Code">};</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">myDog.name;</pre>
			<pre class="Code"><span class="CodeConsole">Zero</span></pre>
			<p class="Body">Bracket notation uses a set of brackets and a string that points to the key we’re looking to access, just like the way we’d use an index in an array. Unlike dot notation, we use a string data type to point to our keys—so, we need to wrap <code class="CodeInline">name</code> in<span class="NoBreak"> quotes.</span></p>
			<pre class="Code">var myDog = {</pre>
			<pre class="Code">  &quot;name&quot;: &quot;Zero&quot;</pre>
			<pre class="Code">};</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">myDog[ &quot;name&quot; ];</pre>
			<pre class="Code"><span class="CodeConsole">Zero</span></pre>
			<p class="Body">The reason bracket notation requires a string is the reason bracket notation exists at all: in complex scripts, we might need to programmatically access certain keys based on custom logic that we’ve coded. In order to do that, we may need to put together a custom string from strings, numbers, variables, and so on. Say we had a script that randomly selected one of the keys in the following<span class="NoBreak"> object:</span></p>
			<pre class="Code">var cars = {</pre>
			<pre class="Code">  &quot;car1&quot; : &quot;red&quot;,</pre>
			<pre class="Code">  &quot;car2&quot; : &quot;blue&quot;,</pre>
			<pre class="Code">  &quot;car3&quot; : &quot;green&quot;</pre>
			<pre class="Code">}</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">We might have a variable that contains a number between one and three, and use that to create a string that points to one of those three keys. There are plenty of ways to generate a random number with JavaScript, but for the sake of keeping things uncomplicated: we’ll just use the number two, and create a concatenated string that reads<span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">car2</code></span><span class="NoBreak">.</span></p>
			<pre class="Code">var cars = {</pre>
			<pre class="Code">  &quot;car1&quot; : &quot;red&quot;,</pre>
			<pre class="Code">  &quot;car2&quot; : &quot;blue&quot;,</pre>
			<pre class="Code">  &quot;car3&quot; : &quot;green&quot;</pre>
			<pre class="Code">}</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">var carKey = &quot;car&quot; + 2;</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">carKey</pre>
			<pre class="Code"><span class="CodeConsole">&quot;car2&quot;</span></pre>
			<pre class="Code">cars.carKey</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">We won’t be able to use dot notation in a situation like this, since JavaScript isn’t going to treat <code class="CodeInline">carKey</code> like a variable. Given how dot notation syntax works, JavaScript thinks <code class="CodeInline">carKey</code> is the <em class="Emphasis">identifier</em> of the key that we’re looking for, not the string it<span class="NoBreak"> contains.</span></p>
			<p class="Body">Bracket notation, however, <em class="Emphasis">expects</em> a string—and<span class="NoBreak"> since </span> <code class="CodeInline">carKey</code> contains a string, the following works just<span class="NoBreak"> fine:</span></p>
			<pre class="Code">var cars = {</pre>
			<pre class="Code">  &quot;car1&quot; : &quot;red&quot;,</pre>
			<pre class="Code">  &quot;car2&quot; : &quot;blue&quot;,</pre>
			<pre class="Code">  &quot;car3&quot; : &quot;green&quot;</pre>
			<pre class="Code">}</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">var carKey = &quot;car&quot; + 2;</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">carKey</pre>
			<pre class="Code"><span class="CodeConsole">&quot;car2&quot;</span></pre>
			<pre class="Code">cars[ carKey ];</pre>
			<pre class="Code"><span class="CodeConsole">&quot;blue&quot;</span></pre>
			<p class="Body">You’ll find a lot of ways to get clever with bracket notation during the course of your JavaScripting career. Unless you <em class="Emphasis">need</em> to get clever, though, dot notation is the simpler of the two syntaxes, and I find it much easier to read at a<span class="NoBreak"> glance.</span></p>
			<h3 class="BHead">Functions</h3>
			<p class="BodyFirstParagraph">A <a id="_idIndexMarker075"></a><em class="Emphasis">function</em> is a block of reusable code that allows us to perform repetitive tasks without repeating the same code throughout a script. Instead, we use an identifier to reference a function containing that code, and pass the function any information it needs to perform a task for<span class="NoBreak"> us.</span></p>
			<p class="Body">In fewer words, a function is an object that <em class="Emphasis">does</em> something, rather than just holding a<span class="NoBreak"> value.</span></p>
			<p class="Body">Defining a function involves a little more code than we’re used to, though the first few parts shouldn’t be too surprising. As usual, <code class="CodeInline">var</code> defines the scope, then we define an identifier of our choosing, and use a single equals sign to assign that identifier a value. Instead of a simple string, number, Boolean, etc., we follow the equals sign with the keyword <code class="CodeInline">function</code> and a set of parentheses. Then, between two <em class="Emphasis">curly braces</em>, we put all the code we want that function to execute whenever we call it. As usual, we end the statement with a<span class="NoBreak"> semicolon.</span></p>
			<pre class="Code">var whatup = function() {</pre>
			<pre class="Code">  console.log( &quot;Hello again, world.&quot; );</pre>
			<pre class="Code">};</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">If we paste this code into our console: nothing happens. No <span class="CodeConsoleInline">Hello again, world</span><span class="CodeConsoleInline">.</span>—at least, not yet. So far, all we’ve done is define a function with the identifier <code class="CodeInline">whatup</code> that, when called, will output the sentence, “Hello again, world.”</p>
			<p class="Body">If we type <code class="CodeInline">whatup</code> into our console, your dev console will either respond with <span class="CodeConsoleInline">function whatup()</span> or the entirety of the function’s code, depending on the browser—in either case, this is just the browser acknowledging that it knows about a function with that identifier. In order to actually <em class="Emphasis">execute</em> the function, we have to call it using the identifier and a pair of<span class="NoBreak"> parentheses:</span></p>
			<pre class="Code">var whatup = function() {</pre>
			<pre class="Code">  console.log( &quot;Hello again, world.&quot; );</pre>
			<pre class="Code">};</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">whatup;</pre>
			<pre class="Code"><span class="CodeConsole">function whatup()</span></pre>
			<pre class="Code">whatup();</pre>
			<pre class="Code"><span class="CodeConsole">Hello again, world.</span></pre>
			<p class="Body">In their simplest form, functions might not seem all that useful, since we’ll rarely want to execute the <em class="Emphasis">exact same</em> lines of code—leading to the exact same output—over and over again. The real power of functions lies in passing them information for that code to act upon, leading to different results. The parentheses that follow the function’s identifier can do more than just tell the browser to execute the function we’ve assigned to the identifier <code class="CodeInline">whatup</code>: they can be used pass information along to the code inside the function, in the form of<span class="NoBreak"> </span><span class="NoBreak"><a id="_idIndexMarker076"></a></span><span class="NoBreak"><em class="Emphasis">arguments</em></span><span class="NoBreak">.</span></p>
			<pre class="Code">var greet = function( username ) {</pre>
			<pre class="Code">  console.log( &quot;Hello again, &quot; + username + &quot;.&quot; );</pre>
			<pre class="Code">};</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">By adding <code class="CodeInline">username</code> between the parentheses when defining a function, we’re saying the function should create a variable named <code class="CodeInline">username</code>, and that variable should contain whatever value we pass along between the parentheses when we execute the function. In this case, the function is expecting us to pass along a string that gets concatenated into our “hello again”<span class="NoBreak"> greeting:</span></p>
			<pre class="Code">var greet = function( username ) {</pre>
			<pre class="Code">  console.log( &quot;Hello again, &quot; + username + &quot;.&quot; );</pre>
			<pre class="Code">};</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">greet( &quot;Wilto&quot; );</pre>
			<pre class="Code"><span class="CodeConsole">Hello again, Wilto.</span></pre>
			<p class="Body">Of course, we’re not doing much to validate the data being passed to the function—and we’ll get into that later on—but for now, <a id="_idIndexMarker077"></a>string concatenation is pretty resilient thanks to Java<span class="NoBreak">Script’s</span> <a id="_idIndexMarker078"></a>type coercion. Even if we pass along another data type, things generally work as<span class="NoBreak"> expected</span><span class="NoBreak">.</span></p>
			<pre class="Code">var greet = function( username ) {</pre>
			<pre class="Code">  console.log( &quot;Hello again, &quot; + username + &quot;.&quot; );</pre>
			<pre class="Code">};</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">greet( 8 );</pre>
			<pre class="Code"><span class="CodeConsole">Hello again, 8.</span></pre>
			<pre class="Code">greet( true );</pre>
			<pre class="Code"><span class="CodeConsole">Hello again</span><span class="CodeConsole">, true.</span></pre>
			<p class="Body">Things <em class="Emphasis">do</em> get a little weird if we omit the argument altogether,<span class="NoBreak"> though:</span></p>
			<pre class="Code">var greet = function( username ) {</pre>
			<pre class="Code">  console.log( &quot;Hello again, &quot; + username + &quot;.&quot; );</pre>
			<pre class="Code">};</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">greet();</pre>
			<pre class="Code"><span class="CodeConsole">Hello again, undefined.</span></pre>
			<p class="Body">Since we didn’t populate <code class="CodeInline">username</code> with any information—but JavaScript was aware of the identifier—<code class="CodeInline">username</code> was an undefined data type. Thanks to type coercion, the undefined data type became the <em class="Emphasis">string</em> <span class="CodeConsoleInline">&quot;undefined&quot;</span> Not the most elegant way to phrase things, but not inaccurate either—the function is greeting someone whose name we never defined, after<span class="NoBreak"> all.</span></p>
			<p class="Body">One of the more common—and powerful—uses of functions is to provide you with a packaged, reusable method of <em class="Emphasis">calculating</em> something. I don’t mean that in a strictly mathematical sense, though you can certainly do that as well. By setting a function up to “return” a value, we allow a function to be treated the same way as we would treat a variable: as a container for data that behaves just like the data it contains. </p>
			<p class="Body">Functions can potentially return—and behave like—the final result of infinitely complex logic rather than data that we’ve hand-defined. We don’t cover <em class="Emphasis">infinitely complex logic</em> until next chapter, so for now we’ll have our function return something relatively simple: the sum of two<span class="NoBreak"> values.</span></p>
			<pre class="Code">function addTwoNumbers( num1, num2 ) {</pre>
			<pre class="Code">  return num1 + num2;</pre>
			<pre class="Code">}</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">addTwoNumbers( 4, 9 );</pre>
			<pre class="Code"><span class="CodeConsole">13</span></pre>
			<pre class="Code">typeof addTwoNumbers( 2, 2 );</pre>
			<pre class="Code"><span class="CodeConsole">&quot;number&quot;</span></pre>
			<p class="Body">To go one step further, we can even assign a function with a return value to a<span class="NoBreak"> variable:</span></p>
			<pre class="Code">function addTwoNumbers( num1, num2 ) {</pre>
			<pre class="Code">  return num1 + num2;</pre>
			<pre class="Code">}</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">var sum = addTwoNumbers( 2, 3 );</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">sum</pre>
			<pre class="Code"><span class="CodeConsole">5</span></pre>
			<pre class="Code">typeof sum</pre>
			<pre class="Code"><span class="CodeConsole">&quot;number&quot;</span></pre>
			<p class="Body">It’s important to keep in mind that using the <code class="CodeInline">return</code> keyword means that the final purpose of a function is to return a value. If we include any code inside a function <em class="Emphasis">after</em> a <code class="CodeInline">return</code> statement, that code is never<span class="NoBreak"> executed.</span></p>
			<pre class="Code">function combineStrings( firstString, secondString ) {</pre>
			<pre class="Code">  return firstString + secondString;</pre>
			<pre class="Code">  console.log( &quot;Hello? Can anyone hear me?&quot; );</pre>
			<pre class="Code">}</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">combineStrings( &quot;Test&quot;, &quot; strings&quot; );</pre>
			<pre class="Code"><span class="CodeConsole">&quot;Test strings&quot;</span></pre>
			<p class="Body">Since a <code class="CodeInline">return</code> statement comes before <code class="CodeInline">console.log</code>, the <code class="CodeInline">console.log</code> is never executed. In fact, your editor might even highlight it as an<span class="NoBreak"> error.</span></p>
			<h3 class="BHead">Pretty much everything is an<span class="NoBreak"> object</span></h3>
			<p class="BodyFirstParagraph">These are the common <a id="_idIndexMarker079"></a>object types you’ll run into during your adventures in JavaScripting. While we haven&apos;t used them in terribly complex ways yet, they combine to make up the entirety of JavaScript itself. From top to bottom, JavaScript is made of predefined objects that behave just like the custom ones we’ve been defining<span class="NoBreak"> here.</span></p>
			<p class="Body">Under certain conditions, everything but <code class="CodeInline">null</code> and <code class="CodeInline">undefined</code> can be considered objects—even strings, which are arguably the simplest data type of them all. A new string comes with methods and properties <em class="Emphasis">built in</em>—just like arrays—even though all we did was define a snippet of<span class="NoBreak"> text:</span></p>
			<pre class="Code">&quot;test&quot;.length</pre>
			<pre class="Code"><span class="CodeConsole">4</span></pre>
			<p class="Body">Technically this string itself isn’t an object—it doesn’t have any methods or properties of its own. When we ask for the value of the <code class="CodeInline">length</code> property, though, JavaScript knows what we mean—it has a list of predefined methods and properties that it applies to all<span class="NoBreak"> strings</span><span class="NoBreak">.</span></p>
			<p class="Body">It that a necessary distinction? Not at this point, no; in fact, it’s a little confusing. But the further you dig into the makings of JavaScript itself, the more sense that distinction will start to make. Until then, you’re likely to see this behavior described much more succinctly whenever the subject of what is and isn’t a JavaScript object comes up: “everything is an object...kinda.”</p>
			<p class="Body">Now that we’ve got a feel for some of the building blocks that will make up our scripts, we can start writing some logic around them. In other words: now that we understand the basics, we can start writing scripts that <em class="Emphasis">do things</em>—things apart from blindly chucking text into our developer console, that<span class="NoBreak"> is.</span></p>
			<p class="Body">By default, a browser “reads” a script the same way you would read this page in English: from left to right and from top to bottom. <a id="_idIndexMarker080"></a><em class="Emphasis">Control flow</em> statements are used to control what portions of our code are run at a given time, and whether they’re executed at all. </p>
			<p class="Body">It sounds complicated at first, but it breaks down to a handful of very simple statements that allow us to do amazingly complex things in concert. For our purposes, control flow statements fit pretty neatly into two categories: conditional statements and loops. That&apos;s what we&apos;ll be digging into in the next two<span class="NoBreak"> chapters.</span></p>
		</div>
	</body>
</html>
