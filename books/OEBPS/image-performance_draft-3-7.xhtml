<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
	<head>
		<title>image-performance_draft-3-7</title>
		<link href="css/aba-image_performance.css" rel="stylesheet" type="text/css" />
	</head>
	<body id="image-performance_draft-3-7" lang="en-US" xml:lang="en-US">
		<div id="_idContainer053" style="page-break-after: always;">
			<a id="_idTextAnchor011"></a><a id="_idTextAnchor010"></a><img src="image/ch02.png" alt="Chapter 2. Responsive Images"  id="_idParaDest-4"/>
		</div>
		<div id="_idContainer067">
			<p class="BodyFirstParagraph"><span class="ChapterIntro">I come here not to bury</span> <code class="CodeInline">img</code>, but to p<span class="NoBreak">raise it. </span></p>
			<p class="Body">Wel<span class="NoBreak">l,</span><span class="NoBreak"> mostly.</span></p>
			<p class="Body">Historically, I like <code class="CodeInline">img</code> just fine. It’s refreshingly uncomplicated, on the surface: it fires off a request for the file in its <code class="CodeInline">src</code> attribute, renders the contents of that file, and provides assistive technologies with an alternative narration. It does so quickly, efficiently, and seamlessly. For most of the web’s life, that’s all <code class="CodeInline">img</code> has ever had to do—and thanks to years and years of browsers competing on rendering performance, it keeps getting bet<span class="NoBreak">ter at</span><span class="NoBreak"> it.</span></p>
			<p class="Body">But there’s a fine line between “reliable” and “stubborn,” and I’ve known <code class="CodeInline">img</code> to come down on both sid<span class="NoBreak">es of it. </span></p>
			<p class="Body">Though I admit to inadvertently hedging my bets a <em class="Emphasis">little</em> by contributing to the <a id="_idIndexMarker032"></a>jQuery Mobile Project—a framework originally dedicated to helping produce “mobile sites”—I’ve always come down squarely in the <a id="_idIndexMarker033"></a>responsive web design (RWD) camp. For me, the appeal of RWD wasn’t in building a layout that adapted to any viewport—though I <em class="Emphasis">do</em> still think that’s pretty cool. The real appeal was in finding a technique that could adapt to the unknown-unknowns. RWD felt—and still feels—like a logical and ongoing extension of the web’s strengths: resilience, flexibility, and unpredict<span class="NoBreak">ability.  </span></p>
			<p class="Body">That said, I would like to call attention to one thing that m-dot sites (dedicated mobile versions of sites, usually found at a URL beginning with the letter <em class="Emphasis">m </em>followed by a dot) did have over responsively designed websites, back in the day: specially tailor<span class="NoBreak">ed</span><span class="NoBreak"> assets.</span></p>
			<h2 class="AHead"><a id="_idIndexMarker034"></a>Tailoring Assets</h2>
			<p class="BodyFirstParagraph">In a responsive layout, just setting a <code class="CodeInline">max-width: 100%</code> in your CSS ensures that your images will always <em class="Emphasis">look</em> right—but it also means using image sources that are at least as large as the largest size at which they’ll be displayed. If an image is meant to be displayed anywhere from 300 pixels wide to 2000 pixels wide, that same 2000-pixel-wide image is getting served up to users in all contexts. A user on a small, low-resolution display gets saddled with all of the bandwidth costs of massive, high-resolution images, but ends up with none of the benefits. A high-resolution image on a low-resolution display looks like any other low-resolution image; it just costs more to transfer and takes longer <span class="NoBreak">to</span><span class="NoBreak"> appear.</span></p>
			<p class="Body">Even beyond optimization, it wasn’t uncommon to show or hide entire blocks of content, depending on the current viewport size, during those early days of RWD. Though the practice became less common as we collectively got the hang of working responsively, <code class="CodeInline">img</code> came with unique concerns when serving disparate content across breakpoints: our markup was likely to be parsed long before our CSS, so an <code class="CodeInline">img</code> would have no way of knowing whether it would be displayed at the current viewport size. Even an <code class="CodeInline">img</code> (or its container) set to <code class="CodeInline">display: none</code> would trigger a request, by design. More bandwidth wasted, with no user-facin<span class="NoBreak">g</span><span class="NoBreak"> benefit.</span></p>
			<h3 class="BHead">Our earlies<span class="NoBreak">t</span><span class="NoBreak"> attempts</span></h3>
			<p class="BodyFirstParagraph">I am fortunate enough to have played a tiny part in the history of RWD, having worked alongside Filament Group and <a id="_idIndexMarker035"></a>Ethan Marcotte on the <em class="Emphasis">Boston Globe</em> website back<span class="NoBreak"> in 2011. </span></p>
			<p class="Body">It was, by any measure, a project with <em class="Emphasis">weight</em>. The <em class="Emphasis">Globe</em> website redesign gave us an opportunity to prove that responsive web design was not only a viable approach to development, but that it could scale beyond the “it might be fine for a personal blog” trope—it could work for a massive news organization’s website. It’s hard to imagine that idea has ever needed proving, looking back on it now, but this was a time when standalone m-dot sites were widely considered a best<span class="NoBreak"> practice.</span></p>
			<p class="Body">While working on the <em class="Emphasis">Globe</em>, we tried developing a means of delivering larger images to devices with larger screens, beginning with the philosophy that the technique should err on the side of mobile: start with a mobile-sized and -formatted image, then swap that with a larger version depending on the user’s screen size. This way, if anything should break down, we’re still erring on the side of caution. A smaller—but still perfectly representat<span class="NoBreak">ive—image.</span></p>
			<p class="Body">The key to this was getting the screen’s width in JavaScript, in the <code class="CodeInline">head</code> of the document, and relaying that information to the server in time to defer requests for images farther down the page. At the time, that JavaScript would be executed prior to any requests in <code class="CodeInline">body</code> being made; we used that script to set a cookie about the user’s viewport size, which would be carried along with those <code class="CodeInline">img</code> requests on the same page load. A bit of server-side scripting would read the cookie and determine which asset to send in <span class="NoBreak">response. </span></p>
			<p class="Body">It worked well, but it was squarely in the realm of “clever hack”—that parsing behavior wasn’t explicitly defined in any specifications. And in the end, as even the cleverest hacks are wont to do, <span class="NoBreak">it broke. </span></p>
			<p class="Body">Believe it or not, that was <span class="NoBreak">good</span><span class="NoBreak"> news.</span></p>
			<p class="Body">Prefetching—or “speculative preparsing”—is a huge part of what makes browsers feel fast: before we can even see the page, the browser starts requesting assets so they’re closer to “ready” by the time the page appears. Around the time the <em class="Emphasis">Globe</em>’s site launched, several major browsers made changes to the way they handled prefetching. Part of those changes meant that an image source might be requested before we had a chance to apply any of our cus<span class="NoBreak">tom</span><span class="NoBreak"> logic.</span></p>
			<p class="Body">Now, when browsers compete on performance, users win—those improvements to speculative preparsing were great news for performance, <a href="http://bkaprt.com/ip/02-01/"><span class="URL">improving load times by as much as 20 percent</span></a>. But there was a disconnect here—the <em class="Emphasis">fastest</em> request is the one that never gets made. Good ol’ reliable <code class="CodeInline">img</code> was single-mindedly requesting the contents of its <code class="CodeInline">src</code> faster than ever, but often the contents of those requests were inefficient from the outset, no matter how quickly the browser managed to request, parse, and render them—the assets were bigger than they’d ever need to be. The harm was being done over<span class="NoBreak"> the</span><span class="NoBreak"> wire.</span></p>
			<p class="Body">So we set out to find a new hack. What followed was a sordid tale of <code class="CodeInline">noscript</code> tags and dynamically injected <code class="CodeInline">base</code> tags, of <code class="CodeInline">document.write</code> and <code class="CodeInline">eval</code>—of <em class="Emphasis">rendering all of our page’s markup in a </em><code class="CodeInline">head</code><em class="Emphasis"> element, to break preparsing al</em><span class="NoBreak"><em class="Emphasis">together</em></span><span class="NoBreak">. </span></p>
			<p class="Body">For some of you, the preceding lines will require no explanation, and for that you have my sincerest condolences. For everyone else: know that it was the stuff of scary developer campfire stories (or, I guess, scary GIF-of-a-campfire stories). Messy, hard-to-maintain hacks all the way down, relying entirely on undocumented, unreliable brows<span class="NoBreak">er</span><span class="NoBreak"> quirks.</span></p>
			<p class="Body">Worse than those means, though, were the ends: none of it really <em class="Emphasis">worked</em>. We were always left with compromises we’d be foisting on a whole swath of users—wasted requests for some, blurry images for others. It was a problem we simply couldn’t solve with sufficiently clever JavaScript; even if we had been able to, it would’ve meant working <em class="Emphasis">around</em> browser-level optimizations rather than taking advantage of them. We were trying to subvert browsers’ improvements, rather than work with them. Nothing felt like the wa<span class="NoBreak">y</span><span class="NoBreak"> forward.</span></p>
			<p class="Body">We began hashing out ideas for a native solution: if <span class="LiningFigures">HTML5</span> offered us a way to solve this, what would that way l<span class="NoBreak">ook like? </span></p>
			<h3 class="BHead">A nativ<span class="NoBreak">e</span><span class="NoBreak"> solution</span></h3>
			<p class="BodyFirstParagraph">What began in a shared text file eventually evolved into one of the first and largest of the <a id="_idIndexMarker036"></a><span class="LiningFigures">W3C</span>’s Community Groups—places where developers could build consensus and offer feedback on evolving specifications. Under the banner of the “Responsive Images Community Group,” we—well, at the risk of ruining the dramatic narrative, we argued on mail<span class="NoBreak">ing</span><span class="NoBreak"> lists.</span></p>
			<p class="Body">One such email, from <a id="_idIndexMarker037"></a>Bruce Lawson, proposed a markup pattern for delivering context-appropriate images that fell in line with the existing rich-media elements in <span class="LiningFigures">HTML5</span>—like the <code class="CodeInline">video</code> tag—even borrowing the <code class="CodeInline">media</code> attribute. He called it <code class="CodeInline">picture</code>; <code class="CodeInline">image</code> was already taken as an ancient alias of <code class="CodeInline">img</code>, <span class="NoBreak">after</span><span class="NoBreak"> all.</span></p>
			<p class="Body">What made this proposal special was the way it used our reliable old friend <code class="CodeInline">img</code>. Rather than a standalone element, <code class="CodeInline">picture</code> came to exist as a wrapper—and a decision engine—for an inner <code class="CodeInline">im</code><span class="NoBreak"><code class="CodeInline">g</code></span><span class="NoBreak"> element:</span></p>
			<pre class="Code">&lt;picture&gt;</pre>
			<pre class="Code">  &lt;source …&gt;</pre>
			<pre class="Code">  &lt;img src=&quot;source.jpg&quot; alt=&quot;…&quot;&gt;</pre>
			<pre class="Code">&lt;/picture&gt;</pre>
			<p class="Body">That <code class="CodeInline">img</code> inside <code class="CodeInline">picture</code> would give us an incredibly powerful fallback pattern—it wouldn’t be the sort of standard where we have to wait for browser support to catch up before we could make use of it. Browsers that didn’t understand <code class="CodeInline">picture</code> and its <code class="CodeInline">source</code> elements would ignore it and still render the inner <code class="CodeInline">img</code>. Browsers that <em class="Emphasis">did</em> understand <code class="CodeInline">picture</code> could use criteria attached to <code class="CodeInline">source</code> elements to tell the inner <code class="CodeInline">img</code> which source file to<span class="NoBreak"> request. </span></p>
			<p class="Body">Most important of all, though, it meant we didn’t have to recreate all of the features of <code class="CodeInline">img</code> on a brand-new element: because <code class="CodeInline">picture</code> didn’t render anything in and of itself, we’d still be leaning on the performance and accessibility features of<span class="NoBreak"> that</span><span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">img</code></span><span class="NoBreak">.</span></p>
			<p class="Body">This made a lot of sense to us, so we took it to the <a id="_idIndexMarker038"></a>Web Hypertext Application Technology Working Group (WHATWG), one of the two groups responsible for the ongoing developmen<span class="NoBreak">t of</span><span class="NoBreak"> HTML.</span></p>
			<p class="Body">If you’ve been in the industry for a few years, this part of the story may sound a little familiar. Some of you may have caught whispers of a fight between the WHATWG’s <code class="CodeInline">srcset</code> and the <code class="CodeInline">picture</code> element put forth by a scrappy band of web-standards rebels and their handsome, charismatic, and endlessly humble Chair. Some of you read the various calls to arms, or donated when we raised funds to hire Yoav Weiss to work full-time on native implementations. Some of you have RICG T-shirts, which—I don’t mind saying<span class="NoBreak">—were</span><span class="NoBreak"> </span><span class="NoBreak"><em class="Emphasis">rad</em></span><span class="NoBreak">.</span></p>
			<p class="Body">A lot of dust needed to settle, and when it finally did, we found ourselves with more than just one new element; edge cases begat use cases, and we discovered that <code class="CodeInline">picture</code> alone wouldn’t be enough to suit all of the image needs of our increasingly complex responsive layouts. We got an entire suite of enhancements to the <code class="CodeInline">img</code> element as well: native options for dealing with high-resolution displays, with the size of an image in a layout, with alternate image formats—things we had never been able to do natively, prior to t<span class="NoBreak">hat</span><span class="NoBreak"> point.</span></p>
			<h2 class="AHead">The Four Use Cases</h2>
			<p class="BodyFirstParagraph">Ultimately, those years of experimenting, prototyping, iterating, and arguing with each other impassioned discourse on various mailing lists gave us four mix-and-match use cases—four key problems with image delivery that any proposed solution (or solutions) <em class="Emphasis">must</em> solve to be consider<span class="NoBreak">ed</span><span class="NoBreak"> viable.</span></p>
			<p class="Body">In sum, the term “responsive images” refers to any combination of the following <span class="NoBreak">use</span><span class="NoBreak"> cases:</span></p>
			<ul>
				<li class="BodyBulletList"><strong class="Strong">Art direction:</strong> requesting visually distinct source files at specific viewp<span class="NoBreak">ort</span><span class="NoBreak"> sizes.</span></li>
				<li class="BodyBulletList"><strong class="Strong">Image types:</strong> requesting new image formats with responsible<span class="NoBreak"> </span><span class="NoBreak">fallbacks.</span></li>
				<li class="BodyBulletList"><strong class="Strong">Display density:</strong> requesting image sources appropriate for high-density displays only when<span class="NoBreak"> </span><span class="NoBreak">necessary.</span></li>
				<li class="BodyBulletList"><strong class="Strong">Flexible images:</strong> providing the browser with information about a set of image sources and how they’ll be used in a page’s layout, so it can make the most appropriate request for a user’s browsin<span class="NoBreak">g</span><span class="NoBreak"> context.</span></li>
			</ul>
			<p class="Body">Let’s take a closer look at each of these <span class="NoBreak">use</span><span class="NoBreak"> cases.</span></p>
			<h3 class="BHead"><a id="_idIndexMarker039"></a>Art<span class="NoBreak"> direction</span></h3>
			<p class="BodyFirstParagraph">The art-direction use case comes into pla<span class="NoBreak">y</span><span class="NoBreak"> whenever</span></p>
			<ul>
				<li class="BodyBulletList">you want to specify alternate versions of an image for different viewp<span class="NoBreak">ort</span><span class="NoBreak"> sizes,</span></li>
				<li class="BodyBulletList">you need explicit control over what sources appear<span class="NoBreak"> when,</span><span class="NoBreak"> or </span></li>
				<li class="BodyBulletList">you need different cropping and zooming to best represent the subject of <span class="NoBreak">an image. </span></li>
			</ul>
			<p class="Body">At any viewport size, the subjects of these images are the same—though their proportions may change across layout breakpoints (<span class="FigureNumberInline">Fig 2.1</span>). This sort of “cropping” can be achieved through CSS, certainly—but will still leave a user requesting hundreds of kilobytes of an image they might never end u<span class="NoBreak">p seeing.</span></p>
			<figure id="_idContainer056" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/2-1.png" alt="Figure" /></span></p>
					<figcaption class="FigureCaption"><span class="FigureNumber">Fig 2.1:</span> Different crops of the same image subjects are shown for different viewport sizes.</figcaption>
				</figure>
			<p class="Body">The markup for the <code class="CodeInline">picture</code> element follows a precedent already set by <span class="LiningFigures">HTML5</span>’s <code class="CodeInline">audio</code> and <code class="CodeInline">video</code> elements: a wrapper element containing <code class="CodeInline">source</code> elements, each of which has an attribute defining the conditions for the use of that source (<code class="CodeInline">media</code>) and the asset—or set of assets—to request if that condition is met<span class="NoBreak"> (</span><span class="NoBreak"><code class="CodeInline">srcset</code></span><span class="NoBreak">):</span></p>
			<pre class="Code">&lt;picture&gt;</pre>
			<pre class="Code">  &lt;source media=&quot;(min-width: 800px)&quot; srcset=&quot;pic-big.jpg&quot;&gt;</pre>
			<pre class="Code">  &lt;source media=&quot;(min-width: 400px)&quot; srcset=&quot;pic-med.jpg&quot;&gt;</pre>
			<pre class="Code">  &lt;img src=&quot;small.jpg&quot; alt=&quot;Cubes of tofu simmering in a fiery red sauce.&quot;&gt;</pre>
			<pre class="Code">&lt;/picture&gt;</pre>
			<p class="Body">It’s worth mentioning here that art direction does <em class="Emphasis">not</em> apply to radically different image sources. A good rule of thumb is that you should be able to describe all of your sources with a single <code class="CodeInline">alt</code> attribute—not least of all because you’l<span class="NoBreak">l have</span><span class="NoBreak"> to.</span></p>
			<p class="Body">Similar to the pattern established by <code class="CodeInline">video</code>, the <code class="CodeInline">picture</code> element contains fallback content: an inner <code class="CodeInline">img</code>. If the <code class="CodeInline">picture</code> element isn’t recognized by the user’s browser, it’s ignored. Its associated <code class="CodeInline">source</code> elements are similarly discarded, since the browser doesn’t have any context for them. That inner <code class="CodeInline">img</code> element will be recognized, though—and<span class="NoBreak"> rendered.</span></p>
			<p class="Body">In addition to providing a robust built-in fallback pattern, <code class="CodeInline">img</code> is the heart of the <code class="CodeInline">picture</code> element in browsers that <em class="Emphasis">do</em> support it. Rather than having <code class="CodeInline">picture</code> recreate all of the accessibility features and performance optimizations of <code class="CodeInline">img</code>—and adding a huge barrier to support for both browsers and assistive technologies alike—the <code class="CodeInline">picture</code> element doesn’t actually <em class="Emphasis">render</em> anything on its own. Instead, it acts as a decision engine for the inner <code class="CodeInline">img</code> element, telling it what t<span class="NoBreak">o render. </span></p>
			<p class="Body">The first <code class="CodeInline">source</code> with a <code class="CodeInline">media</code> attribute that matches the viewport size will be the one selected. There’s precedent for this: the <code class="CodeInline">video</code> element uses <code class="CodeInline">source</code> elements, with <code class="CodeInline">media</code> attributes, in the exact<span class="NoBreak"> same</span><span class="NoBreak"> way.</span></p>
			<p class="Body">If we’re using <code class="CodeInline">min-width</code> media queries, we want to have our largest sources first, as illustrated in the example above. When we’re using <code class="CodeInline">max-width</code> media queries, we want to make sure our smallest sources c<span class="NoBreak">ome</span><span class="NoBreak"> first:</span></p>
			<pre class="Code">&lt;picture&gt;</pre>
			<pre class="Code">  &lt;source media=&quot;(max-width: 400px)&quot; srcset=&quot;pic-med.jpg&quot;&gt;</pre>
			<pre class="Code">  &lt;source media=&quot;(max-width: 800px)&quot; srcset=&quot;pic-big.jpg&quot;&gt;</pre>
			<pre class="Code">  &lt;img src=&quot;small.jpg&quot; alt=&quot;Cubes of tofu simmering in a fiery red sauce.&quot;&gt;</pre>
			<pre class="Code">&lt;/picture&gt;</pre>
			<p class="Body">We’ll <em class="Emphasis">always</em> want to specify the inner <code class="CodeInline">img</code> last in the source order—it serves as our default source if <code class="CodeInline">picture</code> is unsupported, or if <em class="Emphasis">none</em> of our <code class="CodeInline">source</code> elements match their <code class="CodeInline">media</code> attribute<span class="NoBreak"> criteria.</span></p>
			<h3 class="BHead"><a id="_idIndexMarker040"></a>I<span class="NoBreak">mage</span><span class="NoBreak"> types</span></h3>
			<p class="BodyFirstParagraph">The image types use case isn’t concerned with viewport size or resolution—it’s concerned with the image <em class="Emphasis">formats</em> supported by the user’s browser. It allows us to use the single-request fallback pattern already built into <code class="CodeInline">picture</code> so we can serve alternate image formats in sma<span class="NoBreak">rter</span><span class="NoBreak"> ways.</span></p>
			<p class="Body">One of the most common suggestions we’d hear from people just joining the responsive-images conversation was that we “just” needed a new format—a single image containing all of the different sources we could possibly need. The browser then would only request the appropriate part of that source file—and, in a vacuum, it’s hard to argue with <span class="NoBreak">the</span><span class="NoBreak"> logic.</span></p>
			<p class="Body">But to make this happen, we would need to not only invent that new format, but also invent a reliable way to serve it to users with browsers that supported it, <em class="Emphasis">and</em> invent a way for browsers to know which specific byte range of the file to load <em class="Emphasis">without</em> requesting the entire “package” of images. The last bit would likely mean throwing together a new protocol for the web to run on. That was usually about the end of thos<span class="NoBreak">e</span><span class="NoBreak"> threads.</span></p>
			<p class="Body">It did get us thinking, though: one of the less impossible stumbling blocks to the introduction of any new format would be to serve it responsibly. A new image format can’t have a fallback pattern in and of itself—if the browser doesn’t recognize a file at all, it can’t take advantage of a baked-in fallback<span class="NoBreak"> pattern. </span></p>
			<p class="Body">At the time, the best solutions all involved requesting and transferring the new image file <em class="Emphasis">before</em> determining whether to throw it away and load a<span class="NoBreak"> fallback:</span></p>
			<pre class="Code">&lt;img src=&quot;image.svg&quot;</pre>
			<pre class="Code"> data-fallback=&quot;image.png&quot; </pre>
			<pre class="Code"> onerror=&quot;this.src=this.getAttribute(‘data-fallback’); this.onerror=null;&quot;</pre>
			<pre class="Code"> alt=&quot;…&quot;&gt;</pre>
			<p class="Body">We were using this approach to contend with spotty browser support for SVG years before formats like <a id="_idIndexMarker041"></a>WebP caught on. With this pattern, the request for <span class="digitalName">image.svg</span> would still be made in every browser. Once a browser had the file, it could figure out whether or not it was capable of <em class="Emphasis">rendering</em> it. Browsers that couldn’t render the SVG would throw an error. That error would trigger a line of JavaScript that did two things: first, it copied the contents of the <code class="CodeInline">data-fallback</code> attribute into the <code class="CodeInline">src</code> attribute, triggering a new request and rendering the PNG instead. Then, the script overwrote itself, to prevent any further errors from creating a loop if the fallback couldn’t be rendered for an<span class="NoBreak">y reason. </span></p>
			<p class="Body">If it sounds a little convoluted, well, that’s because it was—but when it came to making these decisions on the front end, approaches like this one were the only gam<span class="NoBreak">e in</span><span class="NoBreak"> town.</span></p>
			<p class="Body">But with <code class="CodeInline">picture</code>, we were already inventing a decision engine—one explicitly designed to let us avoid redundant requests. Granted, that decision-making could never be completely automated—short of us <em class="Emphasis">telling</em> the browser about a source file, there’s no way for it to recognize a format it doesn’t support without requesting it. We still need to provide the browser with information about the file so it can decide whether or not to make a request in the fi<span class="NoBreak">rst</span><span class="NoBreak"> place.</span></p>
			<p class="Body">We can do that by using a <code class="CodeInline">type</code> attribute on one of our <code class="CodeInline">source</code> elements. In that attribute, we provide the <a id="_idIndexMarker042"></a><em class="Emphasis">Media Type</em> (formerly <a href="http://bkaprt.com/ip/02-02/"><span class="URL">MIME type</span></a>) of the source. These can look a little arcane, but they all follow a predictable <code class="CodeInline">type/subtype</code> format. For example, the Media Type for a PNG is <code class="CodeInline">image/png</code>; for a WebP, it’s <code class="CodeInline">im</code><span class="NoBreak"><code class="CodeInline">age/webp</code></span><span class="NoBreak">. </span></p>
			<p class="Body">With this syntax in place, we tell the browser to disregard a source <em class="Emphasis">unless</em> it recognizes the contents of a <code class="CodeInline">type</code><span class="NoBreak"> </span><span class="NoBreak">attribute:</span></p>
			<pre class="Code">&lt;picture&gt;</pre>
			<pre class="Code">  &lt;source type=&quot;image/webp&quot; srcset=&quot;pic.webp&quot;&gt;</pre>
			<pre class="Code">  &lt;img src=&quot;pic.png&quot; alt=&quot;…&quot;&gt;</pre>
			<pre class="Code">&lt;/picture&gt;</pre>
			<p class="Body">That code, for instance, ensures that any browser that supports WebP will get the WebP source, while every other browser will get the PNG (<span class="FigureNumberInline">F</span><span class="NoBreak"><span class="FigureNumberInline">ig 2.2</span></span><span class="NoBreak">). </span></p>
			<figure id="_idContainer058" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/2-2.png" alt="Figure" /></span></p>
					<figcaption class="FigureCaption"><span class="FigureNumber">Fig 2.2:</span> Users in Chrome (left) receive an 87 KB WebP, while users in Safari (right) receive a 132 KB JPEG.</figcaption>
				</figure>
			<p class="Body">One request; no wasted bandwidth. And this is forward-thinking: as newer and more efficient file formats come along, they’ll come with Media Types of their own, and we’ll be able to take advantage of them thanks to <code class="CodeInline">picture</code>—no scripts, no server-side dependencies. Just good ol’ <code class="CodeInline">img</code> doing what it does best, with a little hel<span class="NoBreak">p from</span><span class="NoBreak"> us.</span></p>
			<h3 class="BHead"><a id="_idIndexMarker043"></a>Displ<span class="NoBreak">ay</span><span class="NoBreak"> density</span></h3>
			<p class="BodyFirstParagraph">The display density use case is about serving image sources that are appropriate to the hardware resolution of a device’s screen—ensuring that only devices with high-resolution displays receive image sources large enough to look sharp, without passing that same bandwidth cost along to users with lower-resolution<span class="NoBreak"> displays.</span></p>
			<p class="Body">This determination hinges on a user’s <a id="_idIndexMarker044"></a><em class="Emphasis">device pixel ratio</em> (DPR). DPR is calculated by dividing a viewport’s CSS pixels by the device’s actual screen resolution, to get the number of real-world hardware pixels that make up a device’s<span class="NoBreak"> display. </span></p>
			<p class="Body">For example, <code class="CodeInline">@media(width: 320px)</code> will match on both an original, non-Retina iPhone and a Retina iPhone 5s—they both have a “normalized” viewport size of 320 × 568 CSS pixels. The actual resolution of the 5s <em class="Emphasis">screen</em> is twice as high as that of the original iPhone, though: 640 × 1136. So, the original iPhone has a DPR of 1, while the Retina iPhone has a <span class="NoBreak">DPR of 2. </span></p>
			<p class="Body">Likewise, the Samsung Galaxy S4 has a 1080 × 1920 display—but has a viewport of 360 × 640 CSS pixels. Because the Galaxy S4’s actual resolution is three times higher than that of its resolution in CSS, it has a<span class="NoBreak"> DPR of</span><span class="NoBreak"> 3.</span></p>
			<p class="Body">You can test this for yourself by opening the developer console of your browser and entering the<span class="NoBreak"> </span><span class="NoBreak">following:</span></p>
			<pre class="Code">&gt; window.devicePixelRatio</pre>
			<pre class="output"><code class="CodeConsole">&lt;- 2</code></pre>
			<p class="Body">In any browsing context, an <code class="CodeInline">img</code> with a width of <code class="CodeInline">100px</code> set via <code class="CodeInline">width</code> attribute or CSS will occupy the same amount of the viewport—a normalized, CSS-pixel width of 100px. But in the devices with a DPR greater than 1, the rendered image has the potential to <em class="Emphasis">look</em> sharper due to the resolution of the screen itself. In order to do so, the image being rendered has to have a natural width of at least 200 pixels. Once scaled down to fit in a 100-pixel space, that 200-pixel image source is rendered with double the pixel density. It won’t look any different on a display with a DPR of 1, since that display can’t make use of the increased density of the image. On a display with a DPR of 2, however, it’ll look nice <span class="NoBreak">and</span><span class="NoBreak"> sharp.</span></p>
			<p class="Body">Once you’ve got the hang of DPR as a concept, the actual syntax that governs serving low-resolution versus high-resolution image sources is pretty<span class="NoBreak"> straig</span><span class="NoBreak">htforward:</span></p>
			<pre class="Code"> &lt;img src=&quot;sd.gif&quot; srcset=&quot;hd.jpg 2x&quot; alt=&quot;…&quot;&gt;</pre>
			<p class="Body">This <code class="CodeInline">x</code> syntax inside the <code class="CodeInline">srcset</code> attribute acts as a suggestion to the browser, pointing out the source most appropriate to the real-world pixel density of the user’s display. I say “suggestion” deliberately—but we’ll get to that<span class="NoBreak"> in a</span><span class="NoBreak"> bit.</span></p>
			<p class="Body">You’ll notice that we also used this new attribute—<code class="CodeInline">srcset</code>—inside the <code class="CodeInline">picture</code> element, because this syntax can be used on those <code class="CodeInline">source</code> element<span class="NoBreak">s as</span><span class="NoBreak"> well:</span></p>
			<pre class="Code">&lt;picture&gt;</pre>
			<pre class="Code">  &lt;source media=&quot;(min-width: 60em)&quot; srcset=&quot;big.jpg 1x, big-hd.jpg 2x&quot;&gt;</pre>
			<pre class="Code">  &lt;source media=&quot;(min-width: 25em)&quot; srcset=&quot;med.jpg 1x, med-hd.jpg 2x&quot;&gt;</pre>
			<pre class="Code">  &lt;img src=&quot;small.jpg&quot; srcset=&quot;small-hd.jpg 2x&quot; alt=&quot;…&quot;&gt;</pre>
			<pre class="Code">&lt;/picture&gt;</pre>
			<p class="Body">That’s a <em class="Emphasis">lot</em> of syntax, but before you panic: know that I’ve never actually needed to use this approach on a project. Not because there isn’t an appeal to tailoring image assets to both viewport size <em class="Emphasis">and</em> density—but because there’s a much easier way. Weirder, maybe, but ultimately much easi<span class="NoBreak">er:</span><span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">sizes</code></span><span class="NoBreak">.</span></p>
			<h3 class="BHead"><a id="_idIndexMarker045"></a>Flexi<span class="NoBreak">ble</span><span class="NoBreak"> images</span></h3>
			<p class="BodyFirstParagraph">So, we have a couple of options for explicit control over sources—and we’ll need that sometimes, for sure. But in <em class="Emphasis">most</em> cases, we want what we’ve always wanted in a responsive layout: an image that stretches to fit a viewport of any size, the way an <code class="CodeInline">img</code> element with a single, gigantic source image would—we just want it to be more<span class="NoBreak"> p</span><span class="NoBreak">erformant.</span></p>
			<p class="Body">The flexible-images use case refers to these situations exactly—situations where we don’t need explicit control over which source is shown when. The <code class="CodeInline">sizes</code> syntax allows us to provide the browser with a couple of sources and some information about them, after which it completely takes the wheel and requests a single source. It’s similar to the <code class="CodeInline">type</code> attribute in that we’re providing the browser with information about image sources up front, but different in that the browser uses a much fuzzier set of rules for determining what to do with that<span class="NoBreak"> in</span><span class="NoBreak">formation.</span></p>
			<p class="Body">Before we get into that syntax and how it works, a caveat: what we’re going to cover here is a peek behind the curtain at the way the browser uses these attributes to make its decisions—it’s not math you’ll ever need to do. Fortunately, the <em class="Emphasis">nature</em> of the math will be familiar to anyone working on a responsive layout: it ultimately comes down to “target divided by context,” the same way we’d size an elemen<span class="NoBreak">t in CSS. </span></p>
			<p class="Body">But still, if you’re as math-averse as I am, take heart: this syntax is strictly declarative. The <code class="CodeInline">sizes</code> attribute is shorthand for “here is the size of the rendered image in the layout,” and the <code class="CodeInline">srcset</code> attribute is shorthand for “here are the source files, and here are their inheren<span class="NoBreak">t widths.”</span></p>
			<p class="Body">So, envision a 1600 × 1200-pixel image uploaded to a CMS, which then generates two more resized versions of that same image on the server: one that is 400 pixels wide, and another that is 800 pixels wide. These sources are identical in appearance, naturally, apart from their dimensions (<span class="NoBreak"><span class="FigureNumberInline">Fig 2.3</span></span><span class="NoBreak">).</span></p>
			<figure id="_idContainer060" class="figFrame">
					<figcaption class="FigureCaption"><span class="FigureNumber"><img src="image/2-3.png" alt="Figure" />Fig 2.3:</span> These image sources are identical apart from their dimensions, which remain proportional.</figcaption>
				</figure>
			<p class="Body">The <code class="CodeInline">sizes</code> attribute specifies the space the image will occupy in our layout—<em class="Emphasis">not</em> the size of the user’s viewport, as with media queries. After all, the size of the user’s viewport doesn’t really tell us anything about how an image is meant to be <em class="Emphasis">displayed</em>, and that’s how we want this decision to be made. Sizing an image meant to occupy 25 percent of a layout based on the width of the user’s viewport would leave us with a much larger image source than the user will need (<span class="NoBreak"><span class="FigureNumberInline">Fig 2.4</span></span><span class="NoBreak">).</span></p>
			<figure id="_idContainer062" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/2-4.png" alt="Figure" /></span></p>
					<figcaption class="FigureCaption"><span class="FigureNumber">Fig 2.4:</span> At this breakpoint, the largest space this image will ever need to occupy is roughly 25 percent of the viewport. Choosing an image source for this position based on viewport size alone would be tremendously wasteful.</figcaption>
				</figure>
			<p class="Body">Let’s assume a fairly common instance: a “hero” image, up at the top of a page, occupying a space that spans the entire viewport (<span class="FigureNumberInline">Fig 2.5</span>). (It makes for easier math, for the sake of di<span class="NoBreak">scussion.)</span></p>
			<pre class="Code">&lt;img</pre>
			<pre class="Code">  sizes=&quot;100vw&quot;</pre>
			<pre class="Code">  srcset=&quot;small.jpg 400w, medium.jpg 800w, large.jpg 1600w&quot;</pre>
			<pre class="Code">  src=&quot;fallback.jpg&quot; </pre>
			<pre class="Code">  alt=&quot;…&quot;&gt;</pre>
			<p class="Body">In this markup, we’re saying <em class="Emphasis">explicitly</em> that the space the image occupies in the layout has a width of <code class="CodeInline">100vw</code>—100 percent of the viewpo<span class="NoBreak">rt width. </span></p>
			<figure id="_idContainer064" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/2-5.png" alt="Figure" /></span></p>
					<figcaption class="FigureCaption"><span class="FigureNumber">Fig 2.5:</span> The hero image for this recipe page occupies 100 percent of the viewport—so <code class="CodeInline">100vw</code>.</figcaption>
				</figure>
			<p class="Body">If we’re looking at this markup on a device with a 320-pixel-wide viewport, 100 percent of that is, predictably enough, 320 pixels. That’s our context. The browser takes that value—<code class="CodeInline">320px</code>—and divides all the image-source sizes ag<span class="NoBreak">ainst it: </span></p>
			<ul>
				<li class="BodyBulletList">Our smallest image has an inherent size of 400 pixels, so: 400 ÷ 3<span class="NoBreak">20 = 1.25.</span></li>
				<li class="BodyBulletList">Our medium image is 800 pixels wide: 800 ÷ 3<span class="NoBreak">20 = 2.5. </span></li>
				<li class="BodyBulletList">Our largest image is 1600 pixels wide: 1600 <span class="NoBreak">÷ 320 =</span><span class="NoBreak"> 5.</span></li>
			</ul>
			<p class="Body">Those final calculations (1.25, 2.5, and 5) are, functionally-speaking, <code class="CodeInline">devicePixelRatio</code> options—meaning that the browser is left with a set of source options that are <em class="Emphasis">specific to the user’s viewport size</em>. On a 320-pixel-wide viewport, <code class="CodeInline">sizes=&quot;100vw&quot;</code> is functionally equivalent to us writing out the<span class="NoBreak"> </span><span class="NoBreak">following:</span></p>
			<pre class="Code">&lt;img src=&quot;small.jpg 1.25x, medium.jpg 2.5x, large.jpg 5x&quot; alt=&quot;…&quot;&gt;</pre>
			<p class="Body">On a device with a <code class="CodeInline">devicePixelRatio</code> of <code class="CodeInline">2</code>, the browser would likely choose <code class="CodeInline">medium.jpg</code>—the closest match to <code class="CodeInline">2x</code> while erring on the side of not serving the user a blurry image. On a device with a <code class="CodeInline">devicePixelRatio</code> of <code class="CodeInline">1</code>, the browser would likely serve us <span class="NoBreak"><code class="CodeInline">small.jpg</code></span><span class="NoBreak">.</span></p>
			<p class="Body">If we were to visit a page using that same <code class="CodeInline">sizes</code>/<code class="CodeInline">srcset</code> syntax, with a viewport 640 pixels wide, the result of all that math would be completely different: <code class="CodeInline">100vw</code> is now <code class="CodeInline">640px</code>. When we divide our sources’ widths against that, we get .625, 1.25, and 2.5. Those newly calculated values would be functionally equivalent to us wri<span class="NoBreak">ting</span><span class="NoBreak"> this:</span></p>
			<pre class="Code">&lt;img srcset=&quot;small.jpg .625x, medium.jpg 1.25x, large.jpg 2.5x&quot; alt=&quot;…&quot;&gt;</pre>
			<p class="Body">On a 640-pixel-wide viewport, our smallest image source will never match; that source is too small for any 640-pixel-wide viewport. Instead, <code class="CodeInline">medium.jpg</code> will be chosen on <code class="CodeInline">1x</code> devices, and <code class="CodeInline">large.jpg</code> will match on <code class="CodeInline">2</code><span class="NoBreak"><code class="CodeInline">x</code></span><span class="NoBreak"> devices.</span></p>
			<p class="Body">If that all makes sense on your first read-through, you’re in better shape than I was the first time I tried to make sense of it—and I helped write the spec. But it’s important to keep in mind that we didn’t have to think any of this math through when we wrote that markup: we only had to know our source files, their sizes, and the amount of space the image would occupy in <span class="NoBreak">the page. </span></p>
			<p class="Body">You can probably already see where that adds up to a more common use case than the explicit breakpoints of <code class="CodeInline">picture</code> when we’re just looking to optimize<span class="NoBreak"> requests.</span></p>
			<h4 class="CHead">Handling<span class="NoBreak"> </span><span class="NoBreak"><a id="_idIndexMarker046"></a></span><span class="NoBreak">b</span><span class="NoBreak">reakpoints</span></h4>
			<p class="BodyFirstParagraph">There’s a little more potential for complication, even when we’re just passing information along to the browser and letting it drive our responsive image decisions: a full-width hero image isn’t the <em class="Emphasis">least</em> common use of an <code class="CodeInline">img</code>, but there’s a much better chance that the space our image occupies in a layout is going to change across our layout’s bre<span class="NoBreak">akpoints. </span></p>
			<p class="Body">In that case, we need to pass a little more detail along to the browser—and since the size of the image is going to change based on the media queries we’re using in our CSS, we’ll use media queries her<span class="NoBreak">e as</span><span class="NoBreak"> well.</span></p>
			<p class="Body">Let’s imagine our hero image occupies 100 percent of the layout—but that layout has a <code class="CodeInline">max-width</code> of <code class="CodeInline">1200px</code> (<span class="FigureNumberInline">F</span><span class="NoBreak"><span class="FigureNumberInline">ig 2.6</span></span><span class="NoBreak">). </span></p>
			<figure id="_idContainer066" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/2-6.png" alt="Figure" /></span></p>
					<figcaption class="FigureCaption"><span class="FigureNumber">Fig 2.6:</span> Our hero image occupies 100 percent of the available viewport width—until the viewport reaches 1200 pixels.</figcaption>
				</figure>
			<p class="Body">If we only used <code class="CodeInline">sizes=&quot;100vw&quot;</code> here, a user visiting the page with a 2000-pixel-wide viewport would get an image source appropriate for rendering <em class="Emphasis">at</em> 2000 pixels wide. So, instead, we’ll use <code class="CodeInline">sizes</code> to tell the browser the following: on viewports up to 1200 pixels, this will occupy 100 percent of the viewport. On viewports at or above 1200 pixels, this image will occupy a space <em class="Emphasis">exactly</em> 1200 pi<span class="NoBreak">xels</span><span class="NoBreak"> wide:</span></p>
			<pre class="Code">&lt;img</pre>
			<pre class="Code">  sizes=&quot;(min-width: 1200px) 1200px, 100vw&quot;</pre>
			<pre class="Code">  srcset=&quot;small.jpg 400w, medium.jpg 800w, large.jpg 1600w, x-large.jpg 2400w&quot;</pre>
			<pre class="Code">  src=&quot;fallback.jpg&quot; </pre>
			<pre class="Code">  alt=&quot;…&quot;&gt;</pre>
			<p class="Body">Let’s break that value down ste<span class="NoBreak">p by</span><span class="NoBreak"> step:</span></p>
			<ul>
				<li class="BodyBulletList"><code class="CodeInline">(min-width: 1200px)</code> we know well enough; in CSS, it means “the following applies on viewports wider than 1200 pixels,” and that’s what it me<span class="NoBreak">ans here. </span></li>
				<li class="BodyBulletList">The <code class="CodeInline">1200px</code> that follows is the size of the space our image will occupy on viewports larger than 1200 pixles: <code class="CodeInline">1200px</code> of the <span class="NoBreak">viewport. </span></li>
				<li class="BodyBulletList">The <code class="CodeInline">100vw</code>, preceded by a comma, isn’t scoped to any media query—and again, just like styles in our CSS that aren’t scoped to a media query, these apply unless that <code class="CodeInline">(min-width: 1200px)</code> criter<span class="NoBreak">ia is</span><span class="NoBreak"> met.</span></li>
			</ul>
			<p class="Body">Now, it’s important to keep in mind that these values are <em class="Emphasis">first match</em>—if <code class="CodeInline">(min-width: 1200px)</code> doesn’t match, the browser moves on to the next comma-separat<span class="NoBreak">ed value. </span></p>
			<p class="Body">Let’s add additional conditions to our <code class="CodeInline">sizes</code> attribute above and step through them the way a brow<span class="NoBreak">ser</span><span class="NoBreak"> would:</span></p>
			<pre class="Code">  sizes=&quot;(min-width: 1200px) 1200px, (min-width: 800px) 80vw, 100vw&quot;</pre>
			<ul>
				<li class="BodyBulletList">For a 600-pixel viewport, the browser asks: “Does <code class="CodeInline">(min-width: 1200px)</code> match? No, moving on. Does <code class="CodeInline">(min-width: 800px)</code> match? No, moving on. No qualifier. This image will occu<span class="NoBreak">py </span><span class="NoBreak"><code class="CodeInline">100vw</code></span><span class="NoBreak">.”</span></li>
				<li class="BodyBulletList">For an 850-pixel viewport, the browser asks: “Does <code class="CodeInline">(min-width: 1200px)</code> match? No, moving on. Does <code class="CodeInline">(min-width: 800px)</code> match? Yes. This image will occ<span class="NoBreak">upy </span><span class="NoBreak"><code class="CodeInline">80vw</code></span><span class="NoBreak">.”</span></li>
				<li class="BodyBulletList">For a 1400-pixel viewport, the browser asks: “Does <code class="CodeInline">(min-width: 1200px)</code> match? Yes. This image will occupy a space that is <code class="CodeInline">120</code><span class="NoBreak"><code class="CodeInline">0px</code></span><span class="NoBreak"> wide.”</span></li>
			</ul>
			<p class="Body">Now, if we had accidentally written that attribute the other way around, we’d have problems. An unqualified <code class="CodeInline">sizes</code> value—one without a media query—is <em class="Emphasis">always</em> going to match, at any viewport size. Once the browser encounters it, it throws the rest of the <code class="CodeInline">sizes</code> attri<span class="NoBreak">bute</span><span class="NoBreak"> away:</span></p>
			<pre class="Code">  sizes=&quot;100vw, (min-width: 800px) 80vw, (min-width: 1200px) 1200px&quot;</pre>
			<ul>
				<li class="BodyBulletList">For a 600-pixel viewport, the browser says: “No qualifier. This image will occu<span class="NoBreak">py </span><span class="NoBreak"><code class="CodeInline">100vw</code></span><span class="NoBreak">.”</span></li>
				<li class="BodyBulletList">For an 850-pixel viewport, the browser says: “No qualifier. This image will occu<span class="NoBreak">py </span><span class="NoBreak"><code class="CodeInline">100vw</code></span><span class="NoBreak">.”</span></li>
				<li class="BodyBulletList">For a 1400-pixel viewport, the browser says: “No qualifier. This image will occu<span class="NoBreak">py </span><span class="NoBreak"><code class="CodeInline">100vw</code></span><span class="NoBreak">.”</span></li>
			</ul>
			<p class="Body">If we had put the <code class="CodeInline">(min-width: 800px)</code> qualifier before <code class="CodeInline">(min-width: 1200px)</code>, we’d run into the same sort of problem. A viewport smaller than 800 pixels wouldn’t qualify for the values scoped to either <code class="CodeInline">(min-width: 800px)</code> or <code class="CodeInline">(min-width: 1200px)</code>, naturally. But a viewport wider than 1200 pixels is <em class="Emphasis">also</em> going to match <code class="CodeInline">(min-width: 800px)</code>—if we put that first, the browser st<span class="NoBreak">ops</span><span class="NoBreak"> there:</span></p>
			<pre class="Code">  sizes=&quot;(min-width: 800px) 80vw, (min-width: 1200px) 1200px, 100vw&quot;</pre>
			<ul>
				<li class="BodyBulletList">For a 600-pixel viewport, the browser asks: “Does <code class="CodeInline">(min-width: 800px)</code> match? No, moving on. Does <code class="CodeInline">(min-width: 1200px)</code> match? No, moving on. No qualifier. This image will occu<span class="NoBreak">py </span><span class="NoBreak"><code class="CodeInline">100vw</code></span><span class="NoBreak">.”</span></li>
				<li class="BodyBulletList">For an 850-pixel viewport, the browser asks: “Does <code class="CodeInline">(min-width: 800px)</code> match? Yes. This image will occ<span class="NoBreak">upy </span><span class="NoBreak"><code class="CodeInline">80vw</code></span><span class="NoBreak">.”</span></li>
				<li class="BodyBulletList">For a 1400-pixel viewport, the browser asks: “Does <code class="CodeInline">(min-width: 800px)</code> match? Yes. This image will occ<span class="NoBreak">upy </span><span class="NoBreak"><code class="CodeInline">80vw</code></span><span class="NoBreak">.”</span></li>
			</ul>
			<h4 class="CHead"><code class="aHeadCode">min-width</code> versus<span class="NoBreak"> </span><span class="NoBreak"><code class="aHeadCode">max-width</code></span></h4>
			<p class="BodyFirstParagraph">When we use <code class="CodeInline">min-width</code> media queries in a stylesheet, our unqualified styles represent our first breakpoint. We then override them with our smallest media query’s styles, then override those with the next breakpoint up, and so on. Our unqualified styles apply on viewports <em class="Emphasis">smaller</em> than the scope of our medi<span class="NoBreak">a</span><span class="NoBreak"> queries.</span></p>
			<p class="Body">We do the opposite when we use <code class="CodeInline">max-width</code> media queries in a stylesheet: our first <code class="CodeInline">max-width</code> media query is our first breakpoint, and we go upward from there. Our unqualified styles apply on viewports <em class="Emphasis">larger</em> than the scope of our medi<span class="NoBreak">a</span><span class="NoBreak"> queries.</span></p>
			<p class="Body">Just like our CSS, <code class="CodeInline">max-width</code> media queries in <code class="CodeInline">sizes</code> will work the<span class="NoBreak"> same</span><span class="NoBreak"> way:</span></p>
			<pre class="Code">  sizes=&quot;(max-width: 720px) 100vw, (max-width: 1250px) 80vw, 1500px&quot;</pre>
			<ul>
				<li class="BodyBulletList">For a 600-pixel viewport, the browser asks: “Does <code class="CodeInline">(max-width: 720px)</code> match? Yes. This image will occu<span class="NoBreak">py </span><span class="NoBreak"><code class="CodeInline">100vw</code></span><span class="NoBreak">.”</span></li>
				<li class="BodyBulletList">For an 850-pixel viewport, the browser asks: “Does <code class="CodeInline">(max-width: 720px)</code> match? No, moving on. Does <code class="CodeInline">(max-width: 1250px)</code> match? Yes. This image will occ<span class="NoBreak">upy </span><span class="NoBreak"><code class="CodeInline">80vw</code></span><span class="NoBreak">.”</span></li>
				<li class="BodyBulletList">For a 1400-pixel viewport, the browser asks: “Does <code class="CodeInline">(max-width: 720px)</code> match? No, moving on. Does <code class="CodeInline">(max-width: 1250px) </code>match? No, moving on. No qualifier. This image will occup<span class="NoBreak">y </span><span class="NoBreak"><code class="CodeInline">1500px</code></span><span class="NoBreak">.”</span></li>
			</ul>
			<p class="Body">Now, I wouldn’t fault you for asking why any of this is happening in an attribute at all. Markup feels like a strange place to encounter media queries, let alone write them—and presumably, the browser knows everything it needs to know about our layout on account of, you know, <em class="Emphasis">rendering ou</em><span class="NoBreak"><em class="Emphasis">r layout</em></span><span class="NoBreak">. </span></p>
			<p class="Body">But at the time the browser initiates requests for images, it has no other information about the site—it may not have made requests for external stylesheets yet, or had a chance to apply them. Waiting until a page is fully rendered would mean introducing huge delays in requesting image sources—and once loaded, those images could then change the layout, causing a need for recalculation, and new requests for sources, and so on unto <span class="NoBreak">infinity. </span></p>
			<p class="Body">In terms of <code class="CodeInline">srcset</code>/<code class="CodeInline">sizes</code>, we can safely say that the browser only knows a few things when it parses our markup and starts making external requests: the contents of that markup, the size of the viewport, and the pixel density of th<span class="NoBreak">e</span><span class="NoBreak"> display.</span></p>
			<p class="Body">I wouldn’t blame you for feeling a little wired after all that. These attributes pack an incredible amount of information into precious few characters. Once you learn the <em class="Emphasis">rules</em> of <code class="CodeInline">srcset</code> and <code class="CodeInline">sizes</code>, though, you don’t actually have to think much about how the browser makes decisions with those attributes. As a matter of fact, we <em class="Emphasis">can’t</em> know how the browser makes its decisions, given all this information. Believe it or not, that’s by design—in fact, it might be the most exciting feature of responsi<span class="NoBreak">ve</span><span class="NoBreak"> images.</span></p>
			<h4 class="CHead">The “explicitly vague” <a id="_idIndexMarker047"></a>source-selection<span class="NoBreak"> algorithm</span></h4>
			<p class="BodyFirstParagraph">You may have noticed that all of the responsive image solutions we’ve discussed only tangentially address the original problem we aimed to solve: serving bandwidth-appropriate assets <span class="NoBreak">to users. </span></p>
			<p class="Body">From a syntax standpoint, telling the browser “use this source on a high-resolution display” or “here’s some information, pick the right one for this viewport” is relatively easy—but knowing when a user <em class="Emphasis">wants</em> high-resolution images is impossible. If I’m on a top-of-the-line MacBook but tethered to my phone’s internet connection, using shaky airplane WiFi, or browsing the web by way of a metered connection, I might want to opt out of high-resolution image sources, regardless of my screen’s<span class="NoBreak"> cap</span><span class="NoBreak">abilities.</span></p>
			<p class="Body">These syntaxes can ensure that we’re serving image assets more efficiently, but they can’t do anything to address bandwidth concerns <em class="Emphasis">directly</em>—and not for lack of trying. Members of the <a id="_idIndexMarker048"></a>RICG and beyond spent a lot of time talking through how we could tailor assets to a user’s bandwidth and what kind of syntax might make the most sense for that, revisiting the subject over and over. A server-side solution could give us an assumption based on the device, but a mobile device can be on anything from EDGE<span class="NoBreak"> to WiFi. </span></p>
			<p class="Body">We came up with what seemed like a perfectly sensible solution: a bandwidth media query. And after our initial excitement wore off, well—we came to hate our<span class="NoBreak"> own</span><span class="NoBreak"> idea.</span></p>
			<p class="Body">We quickly realized we couldn’t possibly ensure a consistent browsing experience for the user this way. Within the scope of a single project, sure—we could maintain a consistent bandwidth-based “breakpoint” for things like high-density images. But across the web, the browsing experience would be wildly inconsistent. Where <em class="Emphasis">I</em> set that bandwidth breakpoint is different from where others might set it—a user could end up with high-resolution images on one site and low-resolution images on <span class="NoBreak">the next. </span></p>
			<p class="Body">Worse still, we’d be making all of this optional: one more thing to test, one more thing to go wrong, one more thing for us developers to keep in mind—or to forget. In cases where that media query was omitted, or set too high, the web would still <em class="Emphasis">feel</em> broken to end users—slow and inconsiderate about bandwidth usage. On other pages, the web would <em class="Emphasis">look</em> broken: unaware of the compromise being made on their behalf, a user would only know that they were seeing grainy images on their high-density display—something that wouldn’t be the case on sites that set their bandwidth breakpoint a litt<span class="NoBreak">le</span><span class="NoBreak"> higher.</span></p>
			<p class="Body">There’s a technical problem, too. Media queries feel like the right fit for bandwidth considerations, seeing as they’re already designed to respond to client-side concerns—viewport height and width, device orientation, hardware features like ambient light level, and OS-level accessibility settings. But media queries are designed to respond to <em class="Emphasis">changes</em> on the client side, and bandwidth can be<span class="NoBreak"> unpr</span><span class="NoBreak">edictable.</span></p>
			<p class="Body">For example, when a user first lands on a page, they might qualify for our high-resolution images, then have their bandwidth drop off as they go through a tunnel. Now we have to send them low-resolution images, because that media query told the browser to listen for client-side bandwidth changes. As their connection speeds back up, we have to send them the high-resolution imag<span class="NoBreak">es again. </span></p>
			<p class="Body">The only way to work around this would be to change the expected behavior of media queries from a guarantee (“if the viewport is smaller than 600 pixels, this will happen”) to a potentiality (“if the viewport is smaller than 600 pixels, this may or may not happen”). That guarantee was the very thing that made media queries a natural fit for the art-direction use case: the <code class="CodeInline">source</code> element that matches the <code class="CodeInline">media</code> attribute we specify is the one that has to be used, full stop. Otherwise, we might end up with an image source that’s inappropriate for the curre<span class="NoBreak">nt</span><span class="NoBreak"> layout.</span></p>
			<p class="Body">But <code class="CodeInline">srcset</code> is a syntax that’s brand-new to the web, with no expected behaviors to redefine. So, the <span class="LiningFigures">HTML5</span> specification defines <code class="CodeInline">srcset</code> as a set of <em class="Emphasis">candidates</em>. Any and all decisions about their use are left up to the browser, due to a critical feature of the selection algorithm encoded in the specification: once all the math has been done, and the sources and their descriptors have been sorted, the browser is free to do whatever<span class="NoBreak"> it</span><span class="NoBreak"> wants.</span></p>
			<p class="Body">The syntaxes certainly <em class="Emphasis">seem</em> declarative, but in practice, we’re saying, “here is a source visually appropriate for devices with a <code class="CodeInline">devicePixelRatio</code> of <code class="CodeInline">2</code>”—not “here is the source to use on devices with a <code class="CodeInline">devicePixelRatio</code> of <code class="CodeInline">2</code>.” The difference is slight in print, but huge in implication: nothing we include in <code class="CodeInline">srcset</code> is a <em class="Emphasis">command</em>, only a<span class="NoBreak"> </span><span class="NoBreak"><em class="Emphasis">candidate</em></span><span class="NoBreak">.</span></p>
			<p class="Body">That lack of explicit control can sound a little scary at face value, but <code class="CodeInline">srcset</code>—using either the <code class="CodeInline">devicePixelRatio</code> or <code class="CodeInline">sizes</code> syntaxes—ultimately comes down to requesting one from a list of identical-looking sources. Because of that, there’s very little room for an experience to seem <em class="Emphasis">broken</em>, regardless of the decisions made by the<span class="NoBreak"> browser. </span></p>
			<p class="Body">By acting as a list of suggestions, <code class="CodeInline">srcset</code> allows browsers to introduce user settings like “always give me low-res images”—something mobile Chrome’s “data saver” mode does today. It paves the way for settings like “give me high-res images as bandwidth permits”—instead of instructing browsers to frantically respond to changes in bandwidth from one site to another, the browser can take an average across a given time frame or browsing session. Instead of developers drawing the line between delivering high- or low-resolution assets, with each of us landing in different places, those decisions can be made <em class="Emphasis">by</em> the user, not <span class="NoBreak"><em class="Emphasis">for</em></span><span class="NoBreak"> them. </span></p>
			<p class="Body">It also means there’s room for the browser to get creative—for example, in some browsers, an <code class="CodeInline">img</code> or <code class="CodeInline">source</code> marked up with the <code class="CodeInline">srcset</code>/<code class="CodeInline">sizes</code> syntax will never fire a request for a smaller source than the user already has in their browser’s cache. After all, what would be the point in making a new request for a source with smaller dimensions, when the browser already has an identical-looking image that works for those viewport sizes? If the user scales their viewport up to the point where a new image is needed, that request will still get made—we want things to look seamless for them, after all, and upscaling a too-small image would l<span class="NoBreak">ook</span><span class="NoBreak"> wrong.</span></p>
			<p class="Body">The fact that we can’t know for certain how <code class="CodeInline">srcset</code>/<code class="CodeInline">sizes</code> will behave to the end user? That’s this use case’s stronges<span class="NoBreak">t</span><span class="NoBreak"> feature.</span></p>
			<h2 class="AHead">Mixing and Matching</h2>
			<p class="BodyFirstParagraph">There’s one last aspect of the four responsive-image use cases I want to go over: combining them. We touched on it briefly early on, with <code class="CodeInline">picture</code> using <code class="CodeInline">srcset</code>’s <code class="CodeInline">devicePixelRatio</code> syntax on its <code class="CodeInline">source</code> elements to provide both art direction <em class="Emphasis">and</em> sources tailored to a user’s display<span class="NoBreak"> density. </span></p>
			<p class="Body">Any and <em class="Emphasis">all</em> of the four use cases can be used i<span class="NoBreak">n</span><span class="NoBreak"> concert:</span></p>
			<pre class="Code">&lt;picture&gt;</pre>
			<pre class="Code">  &lt;source</pre>
			<pre class="Code">    media=&quot;(min-width: 1280px)&quot;</pre>
			<pre class="Code">    sizes=&quot;50vw&quot;</pre>
			<pre class="Code">    srcset=&quot;nomad-wide-200.webp 200w,</pre>
			<pre class="Code">        nomad-wide-400.webp 400w,</pre>
			<pre class="Code">        nomad-wide-800.webp 800w,</pre>
			<pre class="Code">        nomad-wide-1200.webp 1200w,</pre>
			<pre class="Code">        nomad-wide-1600.webp 1600w,</pre>
			<pre class="Code">        nomad-wide-2000.webp 2000w&quot;</pre>
			<pre class="Code">    type=&quot;image/webp&quot;&gt;</pre>
			<pre class="Code">  &lt;source</pre>
			<pre class="Code">    sizes=&quot;(min-width: 640px) 60vw, 100vw&quot;</pre>
			<pre class="Code">    srcset=&quot;nomad-crop-200.webp 200w,</pre>
			<pre class="Code">        nomad-crop-400.webp 400w,</pre>
			<pre class="Code">        nomad-crop-800.webp 800w,</pre>
			<pre class="Code">        nomad-crop-1200.webp 1200w,</pre>
			<pre class="Code">        nomad-crop-1600.webp 1600w,</pre>
			<pre class="Code">        nomad-crop-2000.webp 2000w&quot;</pre>
			<pre class="Code">    type=&quot;image/webp&quot;&gt;</pre>
			<pre class="Code">  &lt;source</pre>
			<pre class="Code">    media=&quot;(min-width: 1280px)&quot;</pre>
			<pre class="Code">    sizes=&quot;50vw&quot;</pre>
			<pre class="Code">    srcset=&quot;nomad-wide-200.jpg 200w,</pre>
			<pre class="Code">        nomad-wide-400.jpg 400w,</pre>
			<pre class="Code">        nomad-wide-800.jpg 800w,</pre>
			<pre class="Code">        nomad-wide-1200.jpg 1200w,</pre>
			<pre class="Code">        nomad-wide-1600.jpg 1800w,</pre>
			<pre class="Code">        nomad-wide-2000.jpg 2000w&quot;&gt;</pre>
			<pre class="Code">  &lt;img</pre>
			<pre class="Code">    src=&quot;nomad-crop-400.jpg&quot; alt=&quot;An orange-coated shiba inu in the snow.&quot;</pre>
			<pre class="Code">    sizes=&quot;(min-width: 640px) 60vw, 100vw&quot;</pre>
			<pre class="Code">    srcset=&quot;nomad-crop-200.jpg 200w,</pre>
			<pre class="Code">        nomad-crop-400.jpg 400w,</pre>
			<pre class="Code">        nomad-crop-800.jpg 800w,</pre>
			<pre class="Code">        nomad-crop-1200.jpg 1200w,</pre>
			<pre class="Code">        nomad-crop-1600.jpg 1600w,</pre>
			<pre class="Code">        nomad-crop-2000.jpg 2000w&quot;&gt;</pre>
			<pre class="Code">&lt;/picture&gt;</pre>
			<p class="Body">This monster of markup tells th<span class="NoBreak">e</span><span class="NoBreak"> browser:</span></p>
			<ul>
				<li class="BodyBulletList">Using <code class="CodeInline">type</code>, determine whether to use the <code class="CodeInline">source</code> elements that reference WebP or standard JP<span class="NoBreak">EG</span><span class="NoBreak"> images.</span></li>
				<li class="BodyBulletList">Within each branch of that decision, use <code class="CodeInline">media</code> as the selection criterion for each art-direct<span class="NoBreak">ed</span><span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">source</code></span><span class="NoBreak">.</span></li>
				<li class="BodyBulletList">Once the final <code class="CodeInline">source</code> has been selected, choose from a list of candidate sources inside the <code class="CodeInline">srcset</code> attribute, with <code class="CodeInline">sizes</code> describing the space the image will occupy within that range of viewp<span class="NoBreak">ort</span><span class="NoBreak"> sizes.</span></li>
				<li class="BodyBulletList">If none of the <code class="CodeInline">source</code> elements apply due to the current viewport size and/or browser’s WebP support, render the inner <code class="CodeInline">img</code> as-is, using <code class="CodeInline">src</code><span class="NoBreak"><code class="CodeInline">set</code></span><span class="NoBreak">/</span><span class="NoBreak"><code class="CodeInline">sizes</code></span><span class="NoBreak">.</span></li>
				<li class="BodyBulletList">If none of the responsive-image markup patterns are supported by the user’s browser, render the <code class="CodeInline">src</code> of the inner <code class="CodeInline">im</code><span class="NoBreak"><code class="CodeInline">g</code></span><span class="NoBreak"> element.</span></li>
				<li class="BodyBulletList">If the user is navigating by way of assistive technologies, narrate “an orange-coated shiba inu in <span class="NoBreak">the snow.”</span></li>
			</ul>
			<p class="Body">Now, I can say with some certainty that you’ll never need to do this—I know I’ve never even come <em class="Emphasis">close</em>. <code class="CodeInline">srcset</code>/<code class="CodeInline">sizes</code> on a single <code class="CodeInline">img</code> is generally all I need, with only the occasional <code class="CodeInline">picture</code> i<span class="NoBreak">nterlude. </span></p>
			<p class="Body">I say all this to point out how much has changed in just a few short years: from a single method of showing a single image source, with no opportunity to apply any conditional logic, to an <em class="Emphasis">incredible</em> number of mix-and-match options for smarter asset delivery, with all of the performance, accessibility, and reliability of our old fr<span class="NoBreak">iend </span><span class="NoBreak"><code class="CodeInline">img</code></span><span class="NoBreak">. </span></p>
			<p class="Body">With so many options at our disposal—and with even the most common single use case being a little unintuitive—I wouldn’t blame you for feeling a bit rattled. I certainly was, seeing the code snippet above for the very first time: not only would I be stuck <em class="Emphasis">using</em> all of this in my day-to-day work, but I would know exactly whom to blame for such a sprawling s<span class="NoBreak">yntax:</span><span class="NoBreak"> me.</span></p>
			<h2 class="AHead">How I Learned to Stop Worrying and Love Responsive Images</h2>
			<p class="BodyFirstParagraph">I’ve mentioned a few times that some of these syntaxes aren’t for <em class="Emphasis">us</em>, so much as they’re for computers. They’re terse by necessity—that much was apparent early on in the specification process. Anything we might have done to make these syntaxes a little less dense—and more easily parsed by us humans—could have made them more complex for a browser to parse. Adding complexity to a parser translates to more potential for bugs, or for unintentional differences in behavior from one browser t<span class="NoBreak">o</span><span class="NoBreak"> another.</span></p>
			<p class="Body">But as much as that density feels like a syntactical weakness when we’re rooting through all this markup by hand, it reveals itself to be a strength in practice: a syntax more easily read by machines is a syntax more easily <em class="Emphasis">written</em><span class="NoBreak"> by them. </span></p>
			<p class="Body">Creating alternate cuts of an image, outside of manual art direction, is a task that <a id="_idIndexMarker049"></a>content management systems (CMS) have been handling for us since time immemorial—you’d be hard-pressed to find a mainstream CMS that doesn’t offer something in the way of “thumbnails” generated from uploaded images, whether natively or via plugin. It isn’t much of a stretch to imagine that pattern extended just a little further, allowing the CMS to generate all of the images we could want to populate a <code class="CodeInline">srcset</code> attribute, and—knowing all of the sizes it was told to generate—the syntax<span class="NoBreak"> to</span><span class="NoBreak"> match.</span></p>
			<p class="Body"><a href="http://bkaprt.com/ip/02-03/"><span class="URL">WordPress was one of the earliest adopters</span></a> of native responsive-images markup, starting in version 4.4, and it does exa<span class="NoBreak">ctly</span><span class="NoBreak"> that:</span></p>
			<blockquote class="ExtractFirstParagraph">A new default intermediate size, <code class="CodeInline">medium_large</code>, has been added to better take advantage of responsive image support. The new size is 768px wide by default, with no height limit, and can be used like any other size available in WordPress. As it is a standard size, it will only be generated when new images are uploaded or sizes are regenerated with third part<span class="NoBreak">y</span><span class="NoBreak"> plugins.</span></blockquote>
			<p class="Body">Whether via CMS, a <a id="_idIndexMarker050"></a>task runner like Grunt or Gulp, or even a third-party service like Cloudinary<span class="URL">,</span> <code class="CodeInline">srcset</code> is a relatively simple case for<span class="NoBreak"> a</span><span class="NoBreak">utomation.</span></p>
			<p class="Body"><code class="CodeInline">sizes</code> is a little harder. Since it should refer to the <em class="Emphasis">displayed</em> size of the image, it doesn’t lend itself well to<span class="NoBreak"> defaults.</span></p>
			<p class="Body">Now, this doesn’t mean <code class="CodeInline">sizes</code> doesn’t have a default <em class="Emphasis">behavior</em>. If that attribute is left empty, or omitted altogether, the browser will assume a <code class="CodeInline">sizes</code> value of <code class="CodeInline">100vw</code>, in order to err on the side of excessively large images rather than images that could appear distorted. This doesn’t <em class="Emphasis">prevent</em> potential visual issues, though: by telling the browser than an image is meant to occupy 100 percent of the available viewport width, the browser will attempt to use it as the image’s natural width. Unless acted on by CSS—using a maximum <code class="CodeInline">width</code> on either the <code class="CodeInline">img</code> or its container—that image could be scaled beyond its source’s max<span class="NoBreak">imum</span><span class="NoBreak"> size.</span></p>
			<p class="Body">This led to a default <code class="CodeInline">sizes</code> attribute in the WordPress<span class="NoBreak"> imple</span><span class="NoBreak">mentation:</span></p>
			<pre class="Code">(max-width: {{image-width}}px) 100vw, {{image-width}}px</pre>
			<p class="Body">In other words: “<code class="CodeInline">100vw</code>, up to a viewport width equal to the width of the uploaded image; beyond that, a fixed width equal to the image’s natural width.” This ensures that the behavior of the <code class="CodeInline">img</code> more or less matches the behavior of an <code class="CodeInline">img</code> with a <code class="CodeInline">src</code> pointing at the uploaded image. And, of course, the WordPress team provided an API hook that allows authors to supply their own <code class="CodeInline">sizes</code> attributes within their<span class="NoBreak"> </span><span class="NoBreak">templates.</span></p>
			<p class="Body">That would still mean <em class="Emphasis">writing</em> that attribute by hand, but tools have popped up to abstract that away, and with an efficiency we could never match by hand: the <a href="http://bkaprt.com/ip/02-04/"><span class="URL">RespImageLint project</span></a>, for example, provides you with a bookmarklet that vets your <code class="CodeInline">sizes</code> attributes for accuracy and efficiency, and provides suggestions for potential improvements. Even as steeped as I am in this topic, I never leave home wi<span class="NoBreak">thout it. </span></p>
			<p class="Body">On a personal site, I recently encountered the following situation: I had written, manually, what I thought to be a perfectly respectable <code class="CodeInline">sizes</code> attribute, based on a little back-of-napkin math, performed by my perfectly average hu<span class="NoBreak">man</span><span class="NoBreak"> brain:</span></p>
			<pre class="Code">(min-width: 1480px) 935px, (min-width: 800px) 64vw, 98vw</pre>
			<p class="Body">Close enough, I figured. A pass through RespImgLint, however, resulted in the<span class="NoBreak"> </span><span class="NoBreak">following:</span></p>
			<pre class="Code"><a id="_idTextAnchor012"></a><a id="_idTextAnchor013"></a>(min-width: 1560px) calc(-1.25vw + 358px), (min-width: 760px) calc(21.03vw + 14px), (min-width: 500px) 47.5vw, 97.22vw</pre>
			<p class="Body">That’s math I could never have hoped to reason through, considering the degree to which I struggle when it comes time to calculate a tip. But by simulating the resizing of a browser window and calculating the precise space each <code class="CodeInline">img</code> element occupies in a page’s layout at each viewport size, RespImageLint suggests an incredibly tailored <code class="CodeInline">sizes</code> attribute—which, in terms of asset delivery, would no doubt be just a hair more efficient than mine. And with countless users loading countless pages, a kilobyte here or there can certainl<span class="NoBreak">y add up. </span></p>
			<p class="Body">But that’s not the entire appeal for me. See, by not writing these attributes by hand—by using a tool like RespImgLint to generate a hyper-optimized <code class="CodeInline">sizes</code> value, plus a task runner or CMS to generate alternate image cuts and a corresponding <code class="CodeInline">srcset</code> value, and with a template engine to bind it all together for me—I barely have to think about responsive images at all t<span class="NoBreak">hese</span><span class="NoBreak"> days.</span></p>
			<p class="Body">They’re no less important, of course. I still get to provide users with an experience that feels tailored, in a completely invisible way—they’ll never know what responsive-image use cases I sought to address for them, or how I went about doing it. Nothing will look any different from any other site they’ve encountered over the years: their images will look as sharp as their display (and their eyes) will allow. Those images will be sized the way our layouts dictate—the way users have come to expect from a well-crafted<span class="NoBreak"> website. </span></p>
			<p class="Body">But our sites will feel faster. And as these techniques propagate more and more, the web <em class="Emphasis">itself</em> will feel faster, with no cost to the people using it—no drawbacks, no compromises, no hacks, and no grain<span class="NoBreak">y images. </span></p>
		</div>
	</body>
</html>
