<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
	<head>
		<title>js4wd_ebook-5</title>
		<link href="css/ABA.css" rel="stylesheet" type="text/css" />
	</head>
	<body id="js4wd_ebook-5" lang="en-US" xml:lang="en-US">
		<div id="_idContainer031">
			<h1 id="_idParaDest-2" class="chTitle"><a id="_idTextAnchor002"></a>Chapter 1. Getting Set<span class="NoBreak"> Up</span></h1>
			
				<div id="_idContainer015" class="ch_open_img _idGenObjectStyle-Disabled">
					<img src="image/1.png" alt="" />
				</div>
			
			<p class="BodyFirstParagraph"><span class="ChapterIntro">BEFORE WE SET FOOT</span> on JavaScript’s turf, let’s get a feel for our development environment. First we’re going to set up a page where we can do a little work, then we’re going to have a look at that page through the lens of our browsers’ built-in JavaScript debugging tools, and finally, we’ll start making sense of the basic rules of JavaScript<span class="NoBreak"> syntax.</span></p>
			<h2 class="AHead">INCLUDING JAVASCRIPT IN A PAGE</h2>
			<p class="BodyFirstParagraph">If you’ve worked with CSS at all, you’ll find that including a script in your page follows more or less the same pattern as including a <a id="_idIndexMarker011"></a>stylesheet, though with a slightly different syntax and a few small<span class="NoBreak"> caveats.</span></p>
			<p class="Body">Just like CSS, you can embed scripts within the document itself—by wrapping it in <code class="CodeInline">&lt;script&gt;&lt;/script&gt;</code>, the same as you’d use <code class="CodeInline">&lt;style&gt;&lt;/style&gt;</code> tags to include your<span class="NoBreak"> CSS.</span></p>
			<pre class="Code">&lt;html&gt;</pre>
			<pre class="Code">&lt;head&gt;</pre>
			<pre class="Code">    ...</pre>
			<pre class="Code">&lt;script&gt;</pre>
			<pre class="Code">    <span class="CodeComment">// Your scripts go here.</span></pre>
			<pre class="Code">&lt;/script&gt;</pre>
			<pre class="Code">&lt;/head&gt;</pre>
			<p class="Body">All the same drawbacks as in-page styles apply here: if an identical script is meant to be used across multiple pages, there’s no sense in copying and pasting it into every document. You’ll end up with maintenance headaches and pages falling out of sync if you’re updating things as you go along. </p>
			<p class="Body">Fortunately, just as we use a single stylesheet across multiple pages, we can easily reference an external script anywhere we need it. It looks a bit different from the way CSS uses <code class="CodeInline">link</code>, instead adding an <code class="CodeInline">src</code> attribute to the <code class="CodeInline">script</code><span class="NoBreak"> tag.</span></p>
			<pre class="Code">&lt;html&gt;</pre>
			<pre class="Code">&lt;head&gt;</pre>
			<pre class="Code">    ...</pre>
			<pre class="Code">&lt;script <em class="CodeEmphasis">src=&quot;js/script.js&quot;</em>&gt;&lt;/script&gt;</pre>
			<pre class="Code">&lt;/head&gt;</pre>
			<p class="Body">If you’ve encountered examples of <a id="_idIndexMarker012"></a>external scripts around the internet, you might have noticed that older examples of <code class="CodeInline">script</code> tags tend to have JavaScript-specific attributes bolted onto them by default, such as <code class="CodeInline">language</code> or <code class="CodeInline">type</code><span class="NoBreak"> attributes:</span></p>
			<pre class="Code">&lt;script <em class="CodeEmphasis">language=&quot;Javascript&quot;</em> src=&quot;js/script.js&quot;&gt;&lt;/script&gt;</pre>
			<pre class="Code">&lt;script <em class="CodeEmphasis">type=&quot;text/javascript&quot;</em> src=&quot;js/script.js&quot;&gt;&lt;/script&gt;</pre>
			<p class="Body">These have all been deprecated or made optional in <a id="_idIndexMarker013"></a><span class="LiningFigures">HTML5</span>. We’re better off not bothering with any of them, and sticking with <code class="CodeInline">&lt;script src=&quot;js/script.js&quot;&gt;&lt;/script&gt;</code>.</p>
			<p class="Body">Naturally, <code class="CodeInline">script</code> accepts any of HTML’s global attributes—<code class="CodeInline">class</code>, <code class="CodeInline">id</code>, <code class="CodeInline">data-</code> attributes, and so on—and <span class="LiningFigures">HTML5</span> has added a few helpful (and optional) attributes to the <code class="CodeInline">script</code> element that we’ll get to in a<span class="NoBreak"> bit.</span></p>
			<p class="Body">Where in a document we choose to include our external stylesheets—whether we use <code class="CodeInline">&lt;link href=&quot;css/all.css&quot; rel=&quot;stylesheet&quot;&gt;</code> in the <code class="CodeInline">head</code> of the document or just before <code class="CodeInline">&lt;/body&gt;</code>—doesn’t make a tremendous difference, so we conventionally include them in <code class="CodeInline">head</code>. When it comes to JavaScript, though, we need to put a little more thought into placement, no matter whether the scripts are external or part of the page<span class="NoBreak"> itself.</span></p>
			<h3 class="BHead"><a id="_idIndexMarker014"></a>Script<span class="NoBreak"> placement</span></h3>
			<p class="BodyFirstParagraph">At the risk of oversimplifying, browsers parse the contents of a file from top to bottom. When we include a script file toward the top of an HTML page, the browser parses, interprets, and executes that script before figuring out what elements are actually on the page. So, if we’re planning on using the DOM to access elements within the page, we need to give the browser time to assemble a map of those elements by looking through the rest of the page—otherwise, when JavaScript goes looking for one in our script, we’re apt to get an error saying that the elements don’t<span class="NoBreak"> exist.</span></p>
			<p class="Body">There are a couple of methods for dealing with this problem within the script itself—the browser has methods for notifying JavaScript when the page has been fully parsed, and we can tell our scripts to wait for that event—but there are other downsides to including script files at the top of a<span class="NoBreak"> page.</span></p>
			<p class="Body">Including too many scripts in the <code class="CodeInline">head</code> can make our pages feel slow. Upon encountering a <a id="_idIndexMarker015"></a>remote script in the <code class="CodeInline">head</code> of the document, the browser completely stops parsing the page while it fetches and parses the script, then moves on to either parsing the next script—unless we intervene, scripts are always run in order—or parsing the page itself. By including a great deal of JavaScript in the <code class="CodeInline">head</code> of the document, we introduce the potential for users to experience a delay before the page<span class="NoBreak"> appears.</span></p>
			<p class="Body">An alternative to this rendering delay and potential for error is to include scripts at the bottom of the page, just<span class="NoBreak"> before </span> <code class="CodeInline">&lt;/body&gt;</code>. Since the page is parsed top-to-bottom, this ensures that all our markup is ready—and the page is rendered—before our scripts are<span class="NoBreak"> requested.</span></p>
			<p class="Body">This means we’re shifting the burden of that <em class="Emphasis">slight</em> delay from the rendering of a page to the request for a script, which isn&apos;t always ideal; there are times when we might want a script to be parsed as quickly as possible, even before the DOM is available. For example, <a id="_idIndexMarker016"></a>Modernizr—a collection of scripts that test browser support for CSS and JavaScript features—recommends you include it in the <code class="CodeInline">head</code> so the results of those tests are available for immediate use (<a href="https://modernizr.com/"><span class="URL">https://modernizr.com/</span></a>). Modernizr is light enough that the rendering delay it causes is very slight, and the results of its feature tests need to be available to any other scripts on the page, so speed is of the essence—it makes sense to block the page render for a fraction of a second to ensure it works<span class="NoBreak"> reliably.</span></p>
			<h4 class="CHead"><span class="cHeadCode">defer</span> and<span class="NoBreak"> </span><span class="NoBreak"><span class="cHeadCode">async</span></span></h4>
			<p class="BodyFirstParagraph">While <span class="LiningFigures">HTML5</span> removed the need for a lot of crufty old attributes on <code class="CodeInline">script</code>, it did add a few new ones to deal with some of the concerns above: <code class="CodeInline">&lt;script async&gt;</code> and <code class="CodeInline">&lt;script defer&gt;</code>.</p>
			<p class="Body">The <a id="_idIndexMarker017"></a><code class="CodeInline">async</code> attribute on a <code class="CodeInline">script</code> element tells the browser that it should—predictably—execute the script asynchronously. Upon encountering <code class="CodeInline">&lt;script src=&quot;script.js&quot; async&gt;</code> at the top of the document, the browser will initiate a request for the file and parse it as soon as it’s available, but go on to parse the rest of the page in the meantime. This handles the issue of “<a id="_idIndexMarker018"></a>blocking” requests for scripts in the <code class="CodeInline">head</code>, but still doesn’t guarantee the page will have been parsed in time for any DOM scripting, so we’ll only want to use this in situations where we’re not going to access the DOM—or where we’re programmatically waiting for the document to finish loading before our script does anything with the DOM. It brings up a new issue, as well: if we’re loading multiple scripts using <code class="CodeInline">async</code>, we no longer know if they’ll be loaded in the order in which they appear in the page, so we shouldn’t use <code class="CodeInline">async</code> for any scripts that are involved in<span class="NoBreak"> dependencies.</span></p>
			<p class="Body"><a id="_idIndexMarker019"></a><code class="CodeInline">defer</code> solves the issue of waiting for the DOM to be fully available by indicating to the browser that it should request these scripts but not parse them until it has finished parsing the DOM. <code class="CodeInline">defer</code> means our scripts at the top of the document are requested in parallel with the parsing of the page itself—so there&apos;s less chance of a perceptible delay for the user, and the scripts don’t fire until the page is ready for modification. And unlike <code class="CodeInline">async</code>, <code class="CodeInline">defer</code> executes our scripts in the order it encounters<span class="NoBreak"> them.</span></p>
			<p class="Body">These two attributes handily solve all our problems with blocking requests and timing, save for one small catch: while <code class="CodeInline">defer</code> has been around for a long time, it was only recently standardized, and <code class="CodeInline">async</code> is brand new, so we can’t guarantee they’ll be available in all<span class="NoBreak"> browsers.</span></p>
			<p class="Body">In A Book Apart’s own <cite class="WorkCited">Responsible Responsive Design,</cite> <a id="_idIndexMarker020"></a>Scott Jehl recommends loading scripts asynchronously using Java<span class="NoBreak">Script</span> itself: a tiny “loader” script in the <code class="CodeInline">head</code> of the document that requests additional scripts as needed (<a href="http://bkaprt.com/jsfwd/01-01/"><span class="URL">http://bkaprt.com/jsfwd/01-01/</span></a>). This not only allows us to load scripts efficiently and asynchronously, but also to decide whether they should be loaded at all: if we detect that a user is on a device that supports touch events, for example, we can load a script that gives our interface custom touch events. If touch events aren’t supported, we never make that request—and the most efficient possible request is the one we never<span class="NoBreak"> make.</span></p>
			<p class="Body">All of this is a lot to take in, and we’re still only scratching the surface of <a id="_idIndexMarker021"></a>script loading. In the examples that follow, though, our needs are simple. We want to make sure the page has been completely parsed before any of our scripts run, so nothing needs to be in the <code class="CodeInline">head</code> of the document—meaning that there’s no need for <code class="CodeInline">defer</code>. An external script outside the <code class="CodeInline">head</code> won’t cause any blocking behavior, so we won’t need <code class="CodeInline">async</code> either. Since there isn’t a strong case for blocking the page render with the scripts we’ll be writing—and we’re going to need the DOM to be available, later on—we’ll include our <a id="_idIndexMarker022"></a>external scripts just before the <code class="CodeInline">&lt;/body&gt;</code><span class="NoBreak"> tag.</span></p>
			<h3 class="BHead">A blank<span class="NoBreak"> slate</span></h3>
			<p class="BodyFirstParagraph">Before we can write any serious JavaScript, we need to set up a blank canvas—a directory with a plain ol’ HTML<span class="NoBreak"> document.</span></p>
			<pre class="Code">&lt;!doctype html&gt;</pre>
			<pre class="Code">&lt;html lang=&quot;en&quot;&gt;</pre>
			<pre class="Code">&lt;head&gt;</pre>
			<pre class="Code">    &lt;meta charset=&quot;utf-8&quot;&gt;</pre>
			<pre class="Code">&lt;/head&gt;</pre>
			<pre class="Code">&lt;body&gt;</pre>
			<pre class="Code">&lt;/body&gt;</pre>
			<pre class="Code">&lt;/html&gt;</pre>
			<p class="Body">For the sake of keeping things simple and consistent, we’re going to load our external script just before we close the <code class="CodeInline">body</code> tag. Since it’s external, our <code class="CodeInline">script</code> element will have an <code class="CodeInline">src</code> attribute pointing to our script file—which, for now, is just an empty file named <span class="digName">script.js</span>. I usually save mine in a <span class="digName">js/</span> subdirectory—it’s not a requirement by any stretch, but it can help keep things<span class="NoBreak"> organized.</span></p>
			<pre class="Code">&lt;!doctype html&gt;</pre>
			<pre class="Code">&lt;html lang=&quot;en&quot;&gt;</pre>
			<pre class="Code">&lt;head&gt;</pre>
			<pre class="Code">    &lt;meta charset=&quot;utf-8&quot;&gt;</pre>
			<pre class="Code">&lt;/head&gt;</pre>
			<pre class="Code">&lt;body&gt;</pre>
			<pre class="Code">    &lt;script src=&quot;js/script.js&quot;&gt;&lt;/script&gt;</pre>
			<pre class="Code">&lt;/body&gt;</pre>
			<pre class="Code">&lt;/html&gt;</pre>
			<h3 class="BHead">Your editor and<span class="NoBreak"> you</span></h3>
			<p class="BodyFirstParagraph">As with HTML and CSS, there isn’t a lot of overhead to get started with JavaScript—any <a id="_idIndexMarker023"></a>plaintext editor will do. <span class="NoBreak">JavaScript</span> syntax can be a little harder to parse with the naked eye, though—at least until you’ve been steeped in it for a while. Having your editor assign colors to keywords, functions, variables, and so on will make a script file a lot easier to understand at a<span class="NoBreak"> glance.</span></p>
			<p class="Body">Fortunately, you’d be hard-pressed to find a modern code editor that doesn’t handle JavaScript <a id="_idIndexMarker024"></a>syntax highlighting right out of the box. It’s a safe bet that your editor of choice handles JavaScript syntax highlighting just as handily as it does markup and CSS, just by merit of our file having the <span class="digName">.js</span><span class="NoBreak"> extension—</span> not that we’d know that from opening up our still-empty <span class="digName">script.js</span><span class="NoBreak"> file.</span></p>
			<p class="Body">We’ll need that for sure once we start assembling JavaScript’s component parts into purposeful, functional script files. While we’re getting the hang of the basics, though, let’s open our preferred browser and start getting a feel for in-browser development<span class="NoBreak"> tools.</span></p>
			<h2 class="AHead">OUR DEV TOOLS</h2>
			<p class="BodyFirstParagraph">There was a time—not all that long ago, honestly—where browsers didn’t give us much help dealing with JavaScript. At best we’d get a heads-up that there was an error of some kind, and a sometimes-accurate guess at the line number where it occurred. Debugging a script meant making a change, reloading the page, hoping nothing blew up, and repeating the process if it did. There was usually no way of getting more details on the issue—at least, no particularly <em class="Emphasis">helpful</em><span class="NoBreak"> details.</span></p>
			<p class="Body">Luckily, our <a id="_idIndexMarker025"></a>development tools grew up as JavaScript got more and more advanced, and modern desktop browsers all come with advanced JavaScript debugging tools built in. We can still approach development that way, of course, but it’s a bit like using the back of a nail gun to pound nails into a board, and just as likely to end with us getting shot in the foot. </p>
			<p class="Body">In the grand scheme, getting a feel for your dev tools will end up saving you a tremendous amount of time tracking down bugs. For our purposes, it gives us a space to start experimenting with JavaScript’s<span class="NoBreak"> syntax.</span></p>
			<p class="Body">We’ll be looking at <a id="_idIndexMarker026"></a>Chrome’s dev tools here, but the basics will apply to whatever browser you most prefer. Browsers’ dev tools are usually similar right down to the command you use to open them up: command+option+i on a <a id="_idIndexMarker027"></a>Mac and control+shift+i on a <a id="_idIndexMarker028"></a>PC. Things will look a little different from browser to browser, but you’ll find that all of them share a very similar<span class="NoBreak"> layout.</span></p>
			<p class="Body">Now, if you’ve already spent some quality time with these tools in your development browser of choice, inspecting elements and debugging CSS issues, then you’ll be familiar with the “elements” tab, showing all the elements on the page and their associated styles. Beyond that, the other tabs will vary a bit from browser to<span class="NoBreak"> browser.</span></p>
			<p class="Body">Most developer tools also feature a “network” tab, allowing you to monitor the number and size of the requests made by a page and the time it takes to load them all, as well as a “resources” tab, to let you look through all the resources associated with a page, from stylesheets to JavaScript files to cookies. Some browsers will also include network information under “resources.” There’s usually some form of “timeline” tab that charts information about how a page is rendered, such as the number of times the browser has to go through and “repaint” the styles throughout the page—you may have to reload the page with this tab open before you see much (<span class="FigureNumberInline">FIG 1.1</span>).</p>
			
				<div id="_idContainer018" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer016" class="figure">
						<img src="image/Fig_1.1.png" alt="Figure" />
					</div>
					<div id="_idContainer017" class="figure">
						<p class="FigureCaption"><span class="FigureNumber">FIG 1.1:</span> Chrome’s dev tools open to the “console”<span class="NoBreak"> tab.</span></p>
					</div>
				</div>
			
			<p class="Body">We’ll be spending most of our debugging time in the “console” tab, which allows you to run JavaScript in what’s known as a <a id="_idIndexMarker029"></a>REPL, or <em class="Emphasis">read-eval-print loop</em> (<a href="http://bkaprt.com/jsfwd/01-02/"><span class="URL">http://bkaprt.com/jsfwd/01-02/</span></a>). You can write JavaScript into the console and execute it the same way the browser’s JavaScript engine would if it lived in the page. This has a couple of benefits: first, we can start tinkering with JavaScript on any page we want, without worrying too much about a dev environment. Second, anything we write in the console is designed to be ephemeral: by default, any changes you’ve made in JavaScript will be wiped out if you reload the<span class="NoBreak"> page.</span></p>
			<h3 class="BHead">The JavaScript<span class="NoBreak"> </span><span class="NoBreak"><a id="_idIndexMarker030"></a></span><span class="NoBreak">console</span></h3>
			<p class="BodyFirstParagraph">The JavaScript console has two main functions when it comes to testing and <a id="_idIndexMarker031"></a>debugging: it provides us with a place to log errors and information, and a JavaScript prompt for interacting with the page and our scripts<span class="NoBreak"> directly.</span></p>
			<p class="Body">In its simplest form, the JavaScript console serves to show you any <a id="_idIndexMarker032"></a>syntax errors in your scripts—if a typo should sneak into your script or part of the script references something that doesn’t exist, you’re no longer left wondering what’s keeping your script from<span class="NoBreak"> running.</span></p>
			<p class="Body">Most dev consoles go further than only showing outright errors, providing you with warnings about features that browsers might be removing soon, failed requests, and so on. It’s very rare that I do any development without the console open, just to be on the safe<span class="NoBreak"> side.</span></p>
			<p class="Body">Oftentimes, though, we’ll encounter a situation where there aren’t any outright <em class="Emphasis">errors</em> in our scripts, but things still don’t seem to be working quite the way we’d expect them to—or we need a simple way to flag for ourselves that certain parts of a script are being executed, since so much of our logic is happening invisibly. In these cases, you can use some methods built into the browser to send up the occasional signal flare—to send yourself messages, inspect the contents of variables, and leave a trail of breadcrumbs showing a path through the logic of a<span class="NoBreak"> script.</span></p>
			<p class="Body">In the olden days, we repurposed a few of JavaScript’s earliest built-in methods to perform some basic debugging—the much-derided <code class="CodeInline">alert()</code>, a method that causes a native modal window to appear bearing our message of choice, in quotes between the parentheses, and an OK button to dismiss<span class="NoBreak"> it </span> (<span class="FigureNumberInline">FIG 1.2</span>).</p>
			
				<div id="_idContainer021" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer019" class="figure">
						<img src="image/Fig_1.2.png" alt="Figure" />
					</div>
					<div id="_idContainer020" class="figure">
						<p class="FigureCaption"><span class="FigureNumber">FIG 1.2:</span> Using <a id="_idIndexMarker033"></a><code class="FigureCode">alert()</code> on a live website is the JavaScript equivalent of shouting “fire” in a crowded theatre: it isn’t illegal, but certainly isn’t going to win you any<span class="NoBreak"> friends.</span></p>
					</div>
				</div>
			
			<p class="Body">There were a few equally exciting variations on this method: <code class="CodeInline">confirm()</code> allows the user to “OK” or “cancel” the text we specify, and <code class="CodeInline">prompt()</code>, which allows the user to input text in the modal window—both of these reported the user’s selection and input back to us for further use in our scripts. If you’ve agreed to an “end-use license agreement” or spent any quality time with <a id="_idIndexMarker034"></a>Geocities in the past, you’ve likely encountered all of these at some point or<span class="NoBreak"> another.</span></p>
			<p class="Body">JavaScript developers learned pretty quickly that this was an obnoxious way to interact with users, and none of these methods see much use these days—at least, not much unironic<span class="NoBreak"> use.</span></p>
			<p class="Body">What we did learn is that it gave us a quick and easy way of communicating things to ourselves while debugging, allowing us a little insight as to what was going on in our scripts. Inefficient as it was, we could set <code class="CodeInline">alert</code>s telling us how far a script had progressed, whether parts of a script were being executed in the right order, and (by seeing which was the last <code class="CodeInline">alert</code> to fire before we ran into an error) track down glaring issues line-by-line. This sort of debugging wouldn’t tell us much, of course—<code class="CodeInline">alert</code> was really only designed to pass along a string of text, which would often mean inscrutable feedback like <code class="CodeInline">[object Object]</code> when we wanted to look closer at what a part of our script<span class="NoBreak"> meant.</span></p>
			<p class="Body">These days, browsers compete on the quality of their dev tools, and we have tons of options for digging into the internals of our scripts—the simplest of which is still to send ourselves a message from inside the script, but with the potential to contain much more information than a simple string of<span class="NoBreak"> text.</span></p>
			<h4 class="CHead">Writing to the<span class="NoBreak"> console</span></h4>
			<p class="BodyFirstParagraph">The simplest way to output something to the console from our script is a method named <code class="CodeInline">console.log()</code>. In its simplest form, <code class="CodeInline">console.log()</code> works just like <code class="CodeInline">alert()</code>—allowing you to pass yourself a note within your<span class="NoBreak"> script.</span></p>
			<p class="Body">We’ve officially reached the point where some things are easier to show than to tell, so let’s open up script.js in our editor and try the following line out for<span class="NoBreak"> ourselves:</span></p>
			<pre class="Code">console.log(&quot;Hello, World.&quot;);</pre>
			<p class="Body">Save the file, switch back over to your browser, reload the page—and we’ve just written our very first line of Java<span class="NoBreak">Script</span> together (<span class="FigureNumberInline">FIG 1.3</span>).</p>
			<p class="Body">Now, I know this doesn’t seem like the most exciting thing in the world just yet, but we can use <code class="CodeInline">console.log</code> to do a tremendous amount of work. It comes in a couple of different flavors, as well: we can use <code class="CodeInline">console.warn</code> and <code class="CodeInline">console.error</code> the same way we use <code class="CodeInline">console.log</code>, to make particular issues and messages stand out (<span class="FigureNumberInline">FIG 1.4</span>).</p>
			
				<div id="_idContainer024" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer022" class="figure">
						<img src="image/Fig_1.3.png" alt="Figure" />
					</div>
					<div id="_idContainer023" class="figure">
						<p class="FigureCaption"><span class="FigureNumber">FIG 1.3:</span> Well, hello to you too, dev<span class="NoBreak"> console.</span></p>
					</div>
				</div>
			
			<p class="Body">One final note on the topic of console.log and its ilk: while writing to a console is supported in every modern browser, support isn’t <em class="Emphasis">universal</em>—some older browsers don’t have a console at all. In particular, <a id="_idIndexMarker035"></a><span class="LiningFigures">IE6</span> and <span class="LiningFigures">IE7</span> are famous for breaking down upon encountering the unrecognized <code class="CodeInline">console.log</code> method, throwing errors that are likely to break your<span class="NoBreak"> scripts.</span></p>
			<p class="Body">Fortunately, these methods have little place in production code—they’re really only something we’ll be using when writing and debugging our scripts, so there’s little risk of it causing any problems for users—unless we leave one in by accident. Be sure to check for any leftover debugging code like <code class="CodeInline">console.log </code>before using a script on a live website, just to be safe.</p>
			
				<div id="_idContainer027" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer025" class="figure">
						<img src="image/Fig_1.4.png" alt="Figure" />
					</div>
					<div id="_idContainer026" class="figure">
						<p class="FigureCaption"><span class="FigureNumber">FIG 1.4:</span> <code class="FigureCode">console.warn</code> and <code class="FigureCode">console.error</code> are both useful when debugging a<span class="NoBreak"> script.</span></p>
					</div>
				</div>
			
			<h4 class="CHead">Working in the<span class="NoBreak"> console</span></h4>
			<p class="BodyFirstParagraph">Now, the JavaScript console is more than just a place to log messages—you likely noticed the blinking prompt below the logs earlier. This input is the <a id="_idIndexMarker036"></a>REPL I mentioned earlier—the <em class="Emphasis">read-eval[uate]-print</em><span class="NoBreak"><em class="Emphasis"> loop</em></span><span class="NoBreak">.</span></p>
			<p class="Body">This short explanation of the REPL is that it allows us to send things directly to the browser’s JavaScript parser, without needing to update our script file and reload the page. If you enter the same <code class="CodeInline">console.log(&quot;Hello, World.&quot;);</code> in this space and hit return, it appears in the<span class="NoBreak"> console.</span></p>
			<p class="Body">We can use this to get information about the current state of elements on the page, check the output of scripts, or even add functionality to the page for the sake of testing. Right now, we can use it to try out new methods and get immediate feedback. If you punch in <code class="CodeInline">alert(&quot;Test&quot;)</code> and hit enter, you’ll see what I mean: no changing files, no reloading the page, no-fuss-no-muss. Just an ol’-fashioned obnoxious modal window, made to<span class="NoBreak"> order.</span></p>
			<p class="Body">It bears repeating that we can’t do any real damage by way of the console. Any changes we make to the page or to our scripts by way of the console REPL will evaporate as soon as you reload the page, with no changes made to any of our<span class="NoBreak"> files.</span></p>
			<p class="Body">Now we have a couple of options for experimenting with JavaScript via the console, and a dev environment where we can start cobbling our first few scripts together. We’re ready to get started learning the rules of<span class="NoBreak"> JavaScript.</span></p>
			<h2 class="AHead">THE FUNDAMENTAL RULES</h2>
			<p class="BodyFirstParagraph">JavaScript is complex for sure, but the global rules of the language are surprisingly simple—and generally pretty forgiving, with a few exceptions. It’s helpful to run through some of these rules upfront, and don’t worry if they don’t all make perfect sense before we have a chance to see them in<span class="NoBreak"> action.</span></p>
			<h3 class="BHead">Case-sensitivity</h3>
			<p class="BodyFirstParagraph">One strict rule—one that occasionally trips me up to this day—is that JavaScript is <a id="_idIndexMarker037"></a>case-sensitive. That means that <code class="CodeInline">avariable</code> and <code class="CodeInline">aVariable</code> are treated as two completely different things. This can seem a little tricky when JavaScript’s built-in methods for accessing the DOM have names like <code class="CodeInline">getElementsByTagName</code>, which doesn’t exactly roll off the tip of one’s<span class="NoBreak"> keyboard.</span></p>
			<p class="Body">For the most part, we can expect built-in methods to use camel case, capitalizing every word after the first, as<span class="NoBreak"> in </span> <code class="CodeInline">querySelector</code> or<span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">getElementById</code></span><span class="NoBreak">.</span></p>
			<p class="Body">You can see this rule in action via the console: try entering <code class="CodeInline">document.getElementById.toString()</code> and you’ll likely get a response that mentions native code—the browser recognizes this as a built-in method for accessing an item in the DOM. Enter <code class="CodeInline">document.getElementByID.toString()</code> however—with the <em class="Emphasis">D</em> in “Id” capitalized—and the browser only returns an error (<span class="FigureNumberInline">FIG 1.5</span>).</p>
			
				<div id="_idContainer030" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer028" class="figure">
						<img src="image/Fig_1.5.png" alt="Figure" />
					</div>
					<div id="_idContainer029" class="figure">
						<p class="FigureCaption"><span class="FigureNumber">FIG 1.5:</span> So close, yet so far<span class="NoBreak"> away.</span></p>
					</div>
				</div>
			
			<h3 class="BHead"><a id="_idIndexMarker038"></a>Semicolons </h3>
			<p class="BodyFirstParagraph">A statement in JavaScript should almost always end in a semicolon, which is a way to tell a JavaScript parser that it has reached the end of a command, the same way a period ends a sentence in English. This rule is a little flexible: a line break can also signal to a parser that it’s the end of a statement, thanks to something called <em class="Emphasis">Automatic Semicolon Insertion,</em> or<span class="NoBreak"> </span><span class="NoBreak"><a id="_idIndexMarker039"></a></span><span class="NoBreak">ASI.</span></p>
			<p class="Body">Now, if you can believe this, programmers are an opinionated group. It won’t take much searching to find endless debates over whether to <em class="Emphasis">always</em> use a semicolon at the end of a statement, or to just save yourself the occasional byte and let ASI do its job. Personally, I’m in the former camp—I’d always rather be explicit by using a semicolon than risk omitting one that I wasn’t supposed to, and I find that it makes code easier to read for the next person who comes along and needs to maintain it. For now, I’d definitely recommend you do the same. It takes a while to get the hang of where semicolons are absolutely necessary and where ASI can fill in the blanks, so we’re better off erring on the side of<span class="NoBreak"> caution.</span></p>
			<h3 class="BHead">White<span class="NoBreak"> space</span></h3>
			<p class="BodyFirstParagraph">Perhaps weirder still, line breaks are the only form of <a id="_idIndexMarker040"></a>white space—which includes tabs and spaces—that has any real significance to JavaScript, and even then it’s only the first one that counts. Whether you use fifty line breaks between lines of code, or start every line with ten tabs and a space for good luck, Java<span class="NoBreak">Script</span> will ignore it all the same. Only the first newline, where ASI comes swooping in to assume you’re between statements, has any real<span class="NoBreak"> significance.</span></p>
			<h3 class="BHead">Comments</h3>
			<p class="BodyFirstParagraph">JavaScript allows you to leave <a id="_idIndexMarker041"></a>comments that are ignored when the script is executed, so you can leave reminders and explanations throughout your code. I find this helpful on a day-to-day basis: leaving myself pointers and reminders of why things are set up a certain way, or comments telling myself that part of the code still needs some work. </p>
			<p class="Body">Far more important than that, however, is keeping in mind that you won’t always be the single owner of a codebase—even if you’re not working on a team, there’s a chance that someone else may end up making changes to your code someday. Well-commented code serves as a roadmap for other developers, and helps them understand what decisions you made and<span class="NoBreak"> why.</span></p>
			<p class="Body">There are two flavors of comment native to JavaScript, one of which will be familiar to anyone who’s spent quality time with CSS. Multiline comments are handled using the same syntax as CSS<span class="NoBreak"> comments:</span></p>
			<pre class="Code"><span class="CodeComment">/* This is a multi-line comment.</span></pre>
			<pre class="Code"><span class="CodeComment">Anything between these sets of characters will be</span></pre>
			<pre class="Code"><span class="CodeComment">ignored when the script is executed. This form of</span></pre>
			<pre class="Code"><span class="CodeComment">comment needs to be closed. */</span></pre>
			<p class="Body">JavaScript also allows for single-line comments, which don’t need to be explicitly closed. Instead, they close as soon as you start a new<span class="NoBreak"> line.</span></p>
			<pre class="Code"><span class="CodeComment">// This is a single-line comment.</span></pre>
			<p class="Body">Unexpectedly, <a id="_idIndexMarker042"></a>single-line comments can wrap to as many lines as necessary in your <em class="Emphasis">editor,</em> so long as they don’t contain a line break—as soon as you press Return to start a new line, the comment is closed, and you’re back into executable code. The wrapping that might be performed by your code editor—depending on the editor itself and your settings—is called “soft wrapping.” Single-line comments won’t be impacted by soft wrapping, since it’s strictly an editor-level<span class="NoBreak"> convenience.</span></p>
			<pre class="Code">console.log(&quot;Hello, World.&quot;); <span class="CodeComment">// Note to self: should “World” be capitalized here?</span></pre>
			<h2 class="AHead">WE’RE READY</h2>
			<p class="BodyFirstParagraph">Now that we know the rules of the game and we’ve set up a couple of places to experiment, we’re ready to start learning about the building blocks that make up JavaScript. In terms of sitting down and writing a script from start to finish, they might not seem like they amount to much on their own—but the things we’re about to cover in the next chapter are critical to understanding how JavaScript treats<span class="NoBreak"> data.</span></p>
		</div>
	</body>
</html>
