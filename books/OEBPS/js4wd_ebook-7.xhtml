<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
	<head>
		<title>js4wd_ebook-7</title>
		<link href="css/ABA.css" rel="stylesheet" type="text/css" />
	</head>
	<body id="js4wd_ebook-7" lang="en-US" xml:lang="en-US">
		<div id="_idContainer061">
			<h1 id="_idParaDest-4" class="chTitle"><a id="_idTextAnchor004"></a>Chapter 3. Conditional<span class="NoBreak"> Statements</span></h1>
			
				<div id="_idContainer056" class="ch_open_img _idGenObjectStyle-Disabled">
					<img src="image/5.png" alt="" />
				</div>
			
			<p class="BodyFirstParagraph"><span class="ChapterIntro"><a id="_idIndexMarker081"></a></span><span class="ChapterIntro">CONDITIONAL STATEMENTS</span> are a type of control flow concerned with logic: they determine when and where to execute code, based on conditions you specify. </p>
			<h2 class="AHead"><span class="aHeadCode">if</span>/<span class="aHeadCode">else</span> STATEMENTS</h2>
			<p class="BodyFirstParagraph">Conditional statements are almost entirely some variation on “given <em class="Emphasis">X</em>, do <em class="Emphasis">Y</em>.” The most common example of this—and one nearly ubiquitous in terms of any programming language—is the <a id="_idIndexMarker082"></a><code class="CodeInline">if</code>/<code class="CodeInline">else</code> statement. Saying “if this, do that” is about as uncomplicated as a logical statement gets, but by the end of this chapter you’ll see how something so simple on the surface can make up the lion’s share of logic in our<span class="NoBreak"> </span><span class="NoBreak">scripts.</span></p>
			<h3 class="BHead"><span class="bHeadCode">if</span></h3>
			<p class="BodyFirstParagraph">In its most simple form, an <code class="CodeInline">if</code> statement will execute whatever code you specify between a set of curly braces, but only if the contents of the parentheses that follow the <code class="CodeInline">if</code> keyword evaluate to<span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">true</code></span><span class="NoBreak">.</span></p>
			<p class="Body">From the previous chapter we know that JavaScript returns <span class="CodeConsoleInline">true</span> for <code class="CodeInline">2 + 2 == 4</code>, if we punch it into our developer console. Instead of putting that alone in our console, let’s try it out in our very first <code class="CodeInline">if</code> statement. Remember that a single equals sign (<code class="CodeInline">=</code>) is used to <em class="Emphasis">assign</em> values, while two (<code class="CodeInline">==</code>) equals signs are used to perform a basic<span class="NoBreak"> comparison.</span></p>
			<pre class="Code">if( 2 + 2 == 4 ) {</pre>
			<pre class="Code">  console.log( &quot;Hi there.&quot; );</pre>
			<pre class="Code">}</pre>
			<pre class="Code"><span class="CodeConsole">Hi there.</span></pre>
			<p class="Body">Nothing too surprising here: “Hi there.” appears in our developer console. If we enter a statement that we know to be false, the line containing <code class="CodeInline">console.log</code>—and <em class="Emphasis">any</em> code we put between those curly braces—will be<span class="NoBreak"> skipped.</span></p>
			<pre class="Code">if( 2 + 2 == 5 ) {</pre>
			<pre class="Code">  console.log( &quot;Hi there.&quot; );</pre>
			<pre class="Code">}</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">Now, this doesn’t seem terribly useful when we’re entering statements that we already know to be true or false, but the purpose of an <code class="CodeInline">if</code> statement isn’t just to periodically make sure the rules of mathematics still apply. Considering that JavaScript objects can contain all manner of complex data that we’ll need to act on in different ways throughout a script—and remembering that objects are treated exactly the same as the data they contain—we can make some incredibly complex decisions about the flow of a script using simple <code class="CodeInline">if</code> statements. For now, let’s just initialize a single variable containing a number data type, so we can experiment a<span class="NoBreak"> little.</span></p>
			<pre class="Code">var maths = 5;</pre>
			<pre class="Code">if( maths == 5 ) {</pre>
			<pre class="Code">  console.log( &quot;This number is five.&quot; );</pre>
			<pre class="Code">}</pre>
			<pre class="Code"><span class="CodeConsole">This number is five.</span></pre>
			<p class="Body">Since <code class="CodeInline">if</code> blindly evaluates the contents of the two parentheses that follow it for truth, we don’t always have to make a specific assertion there—we can use it to check a <a id="_idIndexMarker083"></a>Boolean value the same<span class="NoBreak"> way.</span></p>
			<pre class="Code">var foo = false;</pre>
			<pre class="Code">if( foo ) {</pre>
			<pre class="Code">  <span class="CodeComment">/* Any code placed here will never execute, unless you </span><span class="CodeComment">change `foo` to `true` */</span></pre>
			<pre class="Code">}</pre>
			<h3 class="BHead"><span class="bHeadCode">else</span></h3>
			<p class="BodyFirstParagraph"><code class="CodeInline">else</code> is used to run alternate lines of code, in the event that the contents of an <code class="CodeInline">if</code> evaluate to <code class="CodeInline">false</code>. The <code class="CodeInline">else</code> keyword follows the closing curly brace for the <code class="CodeInline">if</code> statement, and is followed by a set of curly braces that contain whatever code should run in the event that the <code class="CodeInline">if</code> code doesn&apos;t run. We don’t need a set of parentheses here, since we’re not evaluating any new data—we&apos;re just taking a different action, depending on the conditions of the<span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">if</code></span><span class="NoBreak">.</span></p>
			<pre class="Code">var maths = 2;</pre>
			<pre class="Code">if( maths &gt; 5 ) {</pre>
			<pre class="Code">  console.log( &quot;Greater than five.&quot; );</pre>
			<pre class="Code">} else {</pre>
			<pre class="Code">  console.log( &quot;Less than or equal to five.&quot; );</pre>
			<pre class="Code">}<span class="CodeConsole">Less than or equal </span><span class="CodeConsole">to five.</span></pre>
			<h3 class="BHead"><span class="bHeadCode">else</span><span class="NoBreak"><span class="bHeadCode"> if</span></span></h3>
			<p class="BodyFirstParagraph">There’s a shorthand for stringing together a number of <code class="CodeInline">if</code> statements: <code class="CodeInline">else if</code>. While it isn’t necessarily the neatest way of performing complex comparisons, it’s definitely worth<span class="NoBreak"> knowing.</span></p>
			<pre class="Code">if( lunch == &quot;gravel&quot; ) {</pre>
			<pre class="Code">  console.log( &quot;That isn’t food.&quot;);</pre>
			<pre class="Code">} else if ( lunch == &quot;burrito&quot; ) {</pre>
			<pre class="Code">  console.log( &quot;A burrito is an excellent choice.&quot; );</pre>
			<pre class="Code">} else {</pre>
			<pre class="Code">  console.log( &quot;It might not have been a burrito,   but at least it wasn’t gravel.&quot; );</pre>
			<pre class="Code">}</pre>
			<p class="Body">This script performs a series of tests against the variable <code class="CodeInline">lunch</code>: the first <code class="CodeInline">if</code> checks to make sure lunch does not, in fact, have a value of <code class="CodeInline">&quot;gravel&quot;</code>—and having passed this critical lunchtime test, we can now see whether it has a value of <code class="CodeInline">&quot;burrito&quot;</code>, or—with the final <code class="CodeInline">else</code>—none of the<span class="NoBreak"> above.</span></p>
			<p class="Body"><code class="CodeInline">else if</code> isn’t a JavaScript keyword in the same way that <code class="CodeInline">if</code> and <code class="CodeInline">else</code> are individually—<code class="CodeInline">else</code><code class="CodeInline"> if</code> is more of a syntactical workaround, a shorthand for multiple nested <code class="CodeInline">if</code>/<code class="CodeInline">else</code> statements. The code above is structurally identical to the<span class="NoBreak"> following:</span></p>
			<pre class="Code">if( lunch == &quot;gravel&quot; ) {</pre>
			<pre class="Code">  console.log( &quot;That isn’t food.”);</pre>
			<pre class="Code">} else {</pre>
			<pre class="Code">  if ( lunch == &quot;burrito&quot; ) {</pre>
			<pre class="Code">    console.log( &quot;A burrito is an excellent choice.&quot; );</pre>
			<pre class="Code">  } else {</pre>
			<pre class="Code">    console.log( &quot;It might not have been a burrito,     but at least it wasn’t gravel.” );</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">}</pre>
			<p class="Body">Whether using <code class="CodeInline">else if</code> or nesting multiple <code class="CodeInline">if</code>/<code class="CodeInline">else</code> statements, this isn’t the easiest code to read and understand. There are much better ways of performing multiple comparisons in a single go, and we’ll discuss some of those a little<span class="NoBreak"> later.</span></p>
			<h2 class="AHead"><a id="_idIndexMarker084"></a>COMPARISON OPERATORS</h2>
			<p class="BodyFirstParagraph">We wouldn’t get a lot of use out of conditional statements if all we could do with them is test whether two values are equal. Fortunately—and perhaps expectedly, at this point—there’s a lot more we can do with a few simple conditional statements. You saw a little of this earlier when we used an <code class="CodeInline">if</code> to determine whether an identifier had a <code class="CodeInline">number</code> value greater than five: conditional statements can be used to compare all kinds of values in all kinds of ways, all by replacing the <code class="CodeInline">==</code> we’ve been using in our comparisons so<span class="NoBreak"> far</span><span class="NoBreak">.</span></p>
			<h3 class="BHead"><a id="_idIndexMarker085"></a>Equality</h3>
			<p class="BodyFirstParagraph">I’ve mentioned a couple of times that we should use <code class="CodeInline">==</code> for comparisons, but that isn’t—and this awful pun will only make sense in a little while—<em class="Emphasis">strictly</em><span class="NoBreak"> true.</span></p>
			<p class="Body">JavaScript provides us with two different approaches to comparison: the <code class="CodeInline">==</code> we’ve been using so far, and <code class="CodeInline">===</code>, which is the “strict equals.” Two equals signs together perform a &quot;loose&quot; comparison between two values, which means that typing <code class="CodeInline">2 == &quot;2&quot;</code> into our developer console will give us <span class="CodeConsoleInline">true</span>, even though we’re comparing a number to a string. JavaScript is smart enough to coerce two dissimilar data types to matching ones when a comparison is performed with <code class="CodeInline">==</code>, and make a guess at what we meant to<span class="NoBreak"> compare.</span></p>
			<p class="Body"><code class="CodeInline">2 === &quot;2&quot;</code>, on the other hand, gives us back <span class="CodeConsoleInline">false</span>—no type coercion is performed behind the scenes when a comparison is made using <code class="CodeInline">===</code>. The two values being compared have to be not only equal, but also of the same type—they have to be<span class="NoBreak"> identical.</span></p>
			<p class="Body">If you think that makes <code class="CodeInline">==</code> feel a little too magical for its own good, you’re right—developers have a strong preference for using <code class="CodeInline">===</code> whenever possible, as it does away with any ambiguity that might result from auto-coercion.</p>
			<h4 class="CHead">Truthy and<span class="NoBreak"> falsy</span></h4>
			<p class="BodyFirstParagraph">There’s one potentially useful thing <code class="CodeInline">==</code> gets us that <code class="CodeInline">===</code> doesn’t: the ability to divine “<a id="_idIndexMarker086"></a>truthy” and “<a id="_idIndexMarker087"></a>falsy”<span class="NoBreak"> values.</span></p>
			<p class="Body">Those aren’t strangely consistent typos: everything in JavaScript can be coerced to a <code class="CodeInline">true</code> or <code class="CodeInline">false</code> Boolean value when using the non-strict comparison<span class="NoBreak"> operator.</span></p>
			<p class="Body">This sounds a little confusing, but you won’t have to maintain a spreadsheet of which values are truthy and which are falsy—they follow a clear line of reasoning: “If something, truthy; if nothing, falsy.” For example, <code class="CodeInline">0</code> is a falsy value—likewise <code class="CodeInline">null</code>, <code class="CodeInline">undefined</code>, <a id="_idIndexMarker088"></a><code class="CodeInline">NaN</code>, and an empty string (<code class="CodeInline">&quot;&quot;</code>). Everything else is truthy—a string, a number, and so<span class="NoBreak"> on.</span></p>
			<p class="Body">The uses for this might not be immediately obvious, but imagine a situation where you’re writing a function that outputs a string—like the ones we used when we were first covering string<span class="NoBreak"> concatenation:</span></p>
			<pre class="Code">function greetUser( name ) {</pre>
			<pre class="Code">  console.log( &quot;Welcome, &quot; + name + &quot;!&quot; );</pre>
			<pre class="Code">}</pre>
			<pre class="Code">greetUser( &quot;Muscles McTouchdown&quot; );</pre>
			<pre class="Code"><span class="CodeConsole">Welcome, Muscles McTouchdown!</span></pre>
			<p class="Body">If you remember, omitting the argument containing the user’s name didn’t result in an error since JavaScript is aware that the <code class="CodeInline">name</code> variable <em class="Emphasis">exists</em>, but the <code class="CodeInline">undefined</code> value gets coerced to a<span class="NoBreak"> string.</span></p>
			<pre class="Code">greetUser();</pre>
			<pre class="Code"><span class="CodeConsole">Welcome, undefined!</span></pre>
			<p class="Body">That isn’t particularly desirable behavior; I personally wouldn’t be too keen on being called “undefined.” Fortunately, we can use an <code class="CodeInline">if</code>/<code class="CodeInline">else</code> statement to tailor the output a<span class="NoBreak"> little:</span></p>
			<pre class="Code">function greetUser( name ) {</pre>
			<pre class="Code">  if( name ) {</pre>
			<pre class="Code">    console.log( &quot;Welcome, &quot; + name + &quot;!&quot; );</pre>
			<pre class="Code">  } else {</pre>
			<pre class="Code">    console.log( &quot;Welcome, whoever you are!&quot; );</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">}</pre>
			<p class="Body">By default, JavaScript evaluates the contents of those parentheses in a way that coerces to a <a id="_idIndexMarker089"></a>Boolean value—it looks for truthy and falsy values, and a string is a truthy value. <em class="Emphasis">Now</em> if we try out this new function without passing along a name as an<span class="NoBreak"> argument:</span></p>
			<pre class="Code">greetUser( &quot;Mat&quot; );</pre>
			<pre class="Code"><span class="CodeConsole">Welcome, Mat!</span></pre>
			<pre class="Code">greetUser();</pre>
			<pre class="Code"><span class="CodeConsole">Welcome</span><span class="CodeConsole">, whoever you are!</span></pre>
			<p class="Body">It<span class="NoBreak"> works!</span></p>
			<p class="Body">This function is a little clunky, though. Instead of having two places where this function writes to the console (or later to the page, to another part of our script, etc.), our code would be better organized if we could reduce these two mostly redundant <code class="CodeInline">console.log</code> calls to a single one. For whoever ends up maintaining our code after us—and for our own sanity—it’s a good idea to keep your scripts as terse as possible. You’ll frequently see this concept referred to as <a id="_idIndexMarker090"></a>DRY, which stands for <em class="Emphasis">don’t</em><em class="Emphasis"> repeat yourself</em>. If you have to change something in your code later, you’re better off only needing to do so in one place. In our example, it might be as simple as changing “Welcome” to “Hi,” but, in a sufficiently complex script, it would be impossible to keep a mental inventory of all the places you’d need to make redundant changes. Keeping our code DRY means we’re closer to following a single path through our<span class="NoBreak"> code.</span></p>
			<p class="Body">So in our function, instead of two lines outputting different strings to the console, we’ll conditionally tailor the string itself and output the final result at the<span class="NoBreak"> end.</span></p>
			<pre class="Code">function greetUser( name ) {</pre>
			<pre class="Code">  if( name === undefined ) {</pre>
			<pre class="Code">    name = &quot;whomever you are&quot;;</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">  console.log( &quot;Welcome, &quot; + name + &quot;!&quot; );</pre>
			<pre class="Code">}</pre>
			<p class="Body">Much more succinct. If <code class="CodeInline">name</code> doesn’t have a value, we give it one—rather than relying on truthy/falsy coercion when we already know we’re dealing with a potentially <code class="CodeInline">undefined</code> variable, we check for that specifically. Then, by the time we reach the <code class="CodeInline">console.</code><code class="CodeInline">log</code> statement, we know <code class="CodeInline">name</code> is<span class="NoBreak"> defined.</span></p>
			<p class="Body">One of the ways I keep the complexity of my own code in check is stepping through it in plain English. Previously, our function did the<span class="NoBreak"> following:</span></p>
			<p class="ExtractFirstParagraph">If <code class="CodeInline">name</code> has a truthy value, output a string containing <code class="CodeInline">name</code> to the console, but if <code class="CodeInline">name</code> has a falsy value, output an alternate string to the console. </p>
			<p class="Body">That’s as awkward to say out loud as it is to read in the code itself. Compare that to the way we’d walk through our new<span class="NoBreak"> function:</span></p>
			<p class="ExtractFirstParagraph">If <code class="CodeInline">name</code> is undefined, define it. Output a string containing <code class="CodeInline">name</code> to the<span class="NoBreak"> console.</span></p>
			<p class="Body">Much better—and congratulations on your first JavaScript<span class="NoBreak"> </span><span class="NoBreak"><a id="_idIndexMarker091"></a></span><span class="NoBreak">refactor.</span></p>
			<h3 class="BHead"><a id="_idIndexMarker092"></a>Inequality</h3>
			<p class="BodyFirstParagraph"><code class="CodeInline">!</code> is called a <a id="_idIndexMarker093"></a><em class="Emphasis">logical NOT operator</em>, which means that it negates whatever immediately follows<span class="NoBreak"> it:</span></p>
			<pre class="Code">true</pre>
			<pre class="Code"><span class="CodeConsole">true</span></pre>
			<pre class="Code">false</pre>
			<pre class="Code"><span class="CodeConsole">false</span></pre>
			<pre class="Code">!true</pre>
			<pre class="Code"><span class="CodeConsole">false</span></pre>
			<p class="Body">When we use the logical NOT operator (<code class="CodeInline">!</code>) in front of another data type—like a number or a string—it reverses the truthy/falsy value of that<span class="NoBreak"> data.</span></p>
			<pre class="Code">&quot;string&quot;</pre>
			<pre class="Code"><span class="CodeConsole">&quot;string&quot;</span></pre>
			<pre class="Code">!&quot;string&quot;</pre>
			<pre class="Code"><span class="CodeConsole">false</span></pre>
			<pre class="Code">0</pre>
			<pre class="Code"><span class="CodeConsole">0</span></pre>
			<pre class="Code">!0</pre>
			<pre class="Code"><span class="CodeConsole">true</span></pre>
			<p class="Body">The same way <code class="CodeInline">==</code> and <code class="CodeInline">===</code> return a <code class="CodeInline">true</code> value if the two values being compared are loosely or strictly equal, the <code class="CodeInline">!=</code> and <code class="CodeInline">!==</code> operators return a <code class="CodeInline">true</code> value if the two values being compared <em class="Emphasis">aren’t</em> equal. That’s a little hard to picture in text, but makes a lot more sense in the context of an <code class="CodeInline">if</code><span class="NoBreak"> statement.</span></p>
			<pre class="Code">var foo = 2;</pre>
			<pre class="Code">if( foo != 5 ) {</pre>
			<pre class="Code">  console.log( &quot;`foo` is not equal to five&quot; ); </pre>
			<pre class="Code">}</pre>
			<p class="Body">Just like with <code class="CodeInline">==</code>, <code class="CodeInline">!=</code> attempts to coerce the data types being compared so they match. If we use <code class="CodeInline">!=</code> to compare the number <code class="CodeInline">2</code> to the string <code class="CodeInline">&quot;2&quot;</code>, JavaScript considers the two to be equal—so the result is<span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">false</code></span><span class="NoBreak">.</span></p>
			<pre class="Code">2 != &quot;3&quot;</pre>
			<pre class="Code"><span class="CodeConsoleInline">true</span></pre>
			<pre class="Code">2 != &quot;2&quot;</pre>
			<pre class="Code"><span class="CodeConsoleInline">false</span></pre>
			<h3 class="BHead">Relational<span class="NoBreak"> operators</span></h3>
			<p class="BodyFirstParagraph"><a id="_idIndexMarker094"></a>Relational operators are a little more intuitive than the equality operators (<span class="FigureNumberInline">FIG 3.1</span>).</p>
			
				<div id="_idContainer060" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer057" class="figure grouped">
						<img src="image/6.png" alt="Figure" />
					</div>
					
					<div id="_idContainer059" class="figure">
						<p class="FigureCaption"><span class="FigureNumber"><span class="FigureNumber">FIG 3.1</span></span><span class="FigureNumber">:</span> A quick rundown of relational operators. </p>
					</div>
				</div>
			
			<p class="Body">These work just the way you might expect—no catches, no crazy negation operators to mull over. You’ll use these to compare one number value to<span class="NoBreak"> another:</span></p>
			<pre class="Code">3 &gt; 1</pre>
			<pre class="Code"><span class="CodeConsole">true</span></pre>
			<pre class="Code">3 &lt; 1</pre>
			<pre class="Code"><span class="CodeConsole">false</span></pre>
			<pre class="Code">10 &gt;= 5</pre>
			<pre class="Code"><span class="CodeConsole">true</span></pre>
			<pre class="Code">5 &gt;= 5</pre>
			<pre class="Code"><span class="CodeConsole">true</span></pre>
			<pre class="Code">var bikeName = &quot;Bonneville&quot;;</pre>
			<pre class="Code">if( bikeName.length &lt;= 10 ) {</pre>
			<pre class="Code">  console.log( &quot;There are at least ten characters in   this bike’s name.&quot; );</pre>
			<pre class="Code">}</pre>
			<h2 class="AHead">LOGICAL OPERATORS</h2>
			<p class="BodyFirstParagraph"><code class="CodeInline">if</code>/<code class="CodeInline">else</code> statements can do a lot of work using only what we know so far, but <a id="_idIndexMarker095"></a>logical operators allow us to form even more complex logic by chaining comparisons together in a single expression. You’ve already met one of the logical operators, the logical NOT (<code class="CodeInline">!</code>) that negates any value that follows it, but <code class="CodeInline">!</code> is the odd operator out when compared to the other two: logical OR (<code class="CodeInline">||</code>) and logical AND (<code class="CodeInline">&amp;&amp;</code>).</p>
			<p class="Body"><code class="CodeInline">||</code> and <code class="CodeInline">&amp;&amp;</code> allow you to evaluate multiple values within the same expression: multiple comparisons separated by <code class="CodeInline">||</code> mean the entire expression will return <span class="CodeConsoleInline">true</span> if <em class="Emphasis">any</em> of the expressions evaluate to true, while comparisons separated by <code class="CodeInline">&amp;&amp;</code> mean that the expression will only return <span class="CodeConsoleInline">true</span> if <em class="Emphasis">all</em> the expressions evaluate to true. This is another tough one to visualize without seeing it in action, so back to the dev console we<span class="NoBreak"> go:</span></p>
			<pre class="Code">5 &lt; 2 || 10 &gt; 2</pre>
			<pre class="Code"><span class="CodeConsole">true</span></pre>
			<p class="Body">Five obviously isn’t less than two—that statement alone would never evaluate to <code class="CodeInline">true</code>. Ten <em class="Emphasis">is</em> greater than two, however—and since we’re using a logical OR between the two comparisons, this entire statement evaluates to<span class="NoBreak"> </span><span class="NoBreak"><span class="CodeConsoleInline">true</span></span><span class="NoBreak">.</span></p>
			<pre class="Code">10 &gt; 5 &amp;&amp; &quot;toast&quot; === 2</pre>
			<pre class="Code"><span class="CodeConsole">false</span></pre>
			<p class="Body">Ten is greater than five, sure—that part of the expression is true. But the string <code class="CodeInline">toast</code> clearly has nothing to do with the number two; they’re not equal, and certainly not <em class="Emphasis">strictly</em> equal. Since we’re using the logical AND between these two expressions and one of them returned <span class="CodeConsoleInline">false</span>, this entire statement evaluates to<span class="NoBreak"> </span><span class="NoBreak"><span class="CodeConsoleInline">false</span></span><span class="NoBreak">.</span></p>
			<h3 class="BHead"><a id="_idIndexMarker096"></a>Grouping<span class="NoBreak"> expressions</span></h3>
			<p class="BodyFirstParagraph">Multiple expressions separated by <code class="CodeInline">&amp;&amp;</code> and/or <code class="CodeInline">||</code> (get it? “and/or?”) will be evaluated from left to right. In the following statement, JavaScript never gets as far as evaluating the number of characters in<span class="NoBreak"> <code class="CodeInline">myString</code>.</span></p>
			<pre class="Code">2 + 2 === 9 &amp;&amp; &quot;myString&quot;.length &gt; 2</pre>
			<pre class="Code"><span class="CodeConsole">false</span></pre>
			<p class="Body">Since JavaScript saw an expression that returned <span class="CodeConsoleInline">false</span> followed by a logical AND, the entire statement couldn’t possibly be true. The same goes for a logical<span class="NoBreak"> OR:</span></p>
			<pre class="Code">2 + 2 !== 9 || &quot;myString&quot;.length &gt; 2</pre>
			<pre class="Code"><span class="CodeConsole">true</span></pre>
			<p class="Body">Since the first expression evaluates to <span class="CodeConsoleInline">true</span> and is then followed by a logical OR, there’s no need for JavaScript to continue evaluating the statement—the whole thing evaluates to <span class="CodeConsoleInline">true</span> right<span class="NoBreak"> away.</span></p>
			<p class="Body">We can change the way this evaluation behaves using parentheses, and thus do we creep back toward algebra, in a way. We’ll start with a set of three statements that evaluates to <span class="CodeConsoleInline">true</span> all together, and we’ll use <a id="_idIndexMarker097"></a>Booleans so we can see it all the way JavaScript<span class="NoBreak"> does:</span></p>
			<pre class="Code">false &amp;&amp; true || true  </pre>
			<pre class="Code"><span class="CodeConsole">true</span></pre>
			<p class="Body">The first thing JavaScript looks at here is whether <code class="CodeInline">false &amp;&amp; true</code> evaluates to <span class="CodeConsoleInline">true</span>, which it doesn’t. <code class="CodeInline">true &amp;&amp; true</code> would, sure, but “false AND” means that the statement is certain to return <span class="CodeConsoleInline">false</span>. But following that is a logical OR—so having evaluated the first half of the statement to <span class="CodeConsoleInline">false</span>, JavaScript is now evaluating the second half of the statement<span class="NoBreak"> as </span> <code class="CodeInline">false || true</code>. Since we’re using a logical OR and one of the values is <code class="CodeInline">true</code>, this entire statement—read left to right—is<span class="NoBreak"> </span><span class="NoBreak"><span class="CodeConsoleInline">true</span></span><span class="NoBreak">.</span></p>
			<p class="Body">If we add a set of parentheses around the second part of the statement, however, we change the way they’re<span class="NoBreak"> evaluated:</span></p>
			<pre class="Code">false &amp;&amp; ( true || true )</pre>
			<pre class="Code"><span class="CodeConsole">false</span></pre>
			<p class="Body">Now the first thing JavaScript evaluates is still <code class="CodeInline">false &amp;&amp;</code>, but the parentheses mean everything afterwards is a single expression to be evaluated—not three things to evaluate, but two. Since the left-hand side of the logical AND is <span class="CodeConsoleInline">false</span>, evaluation stops there. “false AND” can never possibly return true, so with a single pair of parenthesis, we’ve changed this statement to<span class="NoBreak"> false.</span></p>
			<p class="Body">Got a headache yet? I’m not far behind you, and I do this stuff all day. That’s why I’m in the habit of <a id="_idIndexMarker098"></a>using parentheses to <em class="Emphasis">clarify</em> how JavaScript evaluates these complex statements as much as I use them to <em class="Emphasis">alter</em> it. Now that we know JavaScript evaluates expressions wrapped in parentheses as a single expression, that first statement—the one that evaluated to <span class="CodeConsoleInline">true</span>—might be a little easier to read when written like<span class="NoBreak"> this:</span></p>
			<pre class="Code">( false &amp;&amp; true ) || true</pre>
			<pre class="Code"><span class="CodeConsole">true</span></pre>
			<p class="Body">Think back to that convoluted <code class="CodeInline">else if</code> example earlier on. Now that we can perform more advanced comparisons within the span of a single <code class="CodeInline">if</code> statement, we can do away with a lot of the complexity, even when we add more functionality—for example,<span class="NoBreak"> tacos:</span></p>
			<pre class="Code">var lunch = &quot;tacos&quot;;</pre>
			<pre class="Code">if( lunch !== &quot;gravel&quot; &amp;&amp; ( lunch === &quot;burrito&quot; || lunch === &quot;tacos&quot; ) ) {</pre>
			<pre class="Code">  console.log( &quot;Delicious.&quot; );</pre>
			<pre class="Code">}</pre>
			<p class="Body">And, for good measure, let’s turn that into a<span class="NoBreak"> function:</span></p>
			<pre class="Code">function mealChecker( lunch ) {</pre>
			<pre class="Code">  if( lunch !== &quot;gravel&quot; &amp;&amp; ( lunch === &quot;burrito&quot; ||   lunch === &quot;tacos&quot; ) ) {</pre>
			<pre class="Code">    console.log( &quot;Delicious.&quot; );</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">}</pre>
			<pre class="Code">mealChecker( &quot;Tacos&quot; );</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">Something has gone horribly wrong! We passed the function a string the way it might expect, but we made one little mistake: we capitalized the <em class="Emphasis">T</em>. Since JavaScript is <a id="_idIndexMarker099"></a>case-sensitive, <code class="CodeInline">Tacos</code> isn’t equal to <code class="CodeInline">tacos</code>—and our script was expecting the<span class="NoBreak"> latter.</span></p>
			<p class="Body">Now, we could make a rule for ourselves that this function should only ever receive an all-lowercase value, but that’s one more thing we have to document—or worse, “just keep in mind from now on.” A better approach would be to plan for both upper- and lowercase values by getting JavaScript to normalize things for<span class="NoBreak"> us.</span></p>
			<p class="Body">If you recall from the previous chapter, even though we don’t define them with methods or properties the way we might define an object from scratch, any string we define will come with a set of built-in properties: <code class="CodeInline">.length</code> gives you the number of characters in the string, for example. Here, we’ll use one of the native methods for transforming a string to make sure we’re comparing apples to apples and tacos to tacos: <code class="CodeInline">.toLowerCase()</code>. Just like the name implies, it returns the all-lowercase value of a<span class="NoBreak"> string:</span></p>
			<pre class="Code">&quot;THIS IS A STRING&quot;.toLowerCase();</pre>
			<pre class="Code"><span class="CodeConsole">this is a string</span></pre>
			<p class="Body">While it returns the lowercase value of a string, it’s important to keep in mind that this—and methods like it—don’t <em class="Emphasis">change</em> a string to lowercase. If we have a string stored in a variable and call <code class="CodeInline">.</code><code class="CodeInline">toLowerCase()</code> on it, the variable remains<span class="NoBreak"> unchanged.</span></p>
			<pre class="Code">var foo = &quot;A String&quot;;</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">foo</pre>
			<pre class="Code"><span class="CodeConsole">&quot;A String&quot;</span></pre>
			<pre class="Code">foo.toLowerCase();</pre>
			<pre class="Code"><span class="CodeConsole">&quot;a</span><span class="CodeConsole"> string&quot;</span></pre>
			<pre class="Code">foo</pre>
			<pre class="Code"><span class="CodeConsole">&quot;A String&quot;</span></pre>
			<p class="Body">That means there are a couple of ways to handle the comparisons in our function. The first way is to call <code class="CodeInline">.toLowerCase()</code> on every instance of the <code class="CodeInline">lunch</code> variable throughout the<span class="NoBreak"> function:</span></p>
			<pre class="Code">function mealChecker( lunch ) {</pre>
			<pre class="Code">  if( lunch.toLowerCase() !== &quot;gravel&quot; &amp;&amp; (   lunch.toLowerCase() === &quot;burrito&quot; ||   lunch.toLowerCase() === &quot;tacos&quot; ) ) {</pre>
			<pre class="Code">    console.log( &quot;Delicious.&quot; );</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">}</pre>
			<pre class="Code">mealChecker( &quot;Tacos&quot; );</pre>
			<pre class="Code"><span class="CodeConsole">Delicious.</span></pre>
			<p class="Body">That <em class="Emphasis">does</em> work, but it isn’t very <a id="_idIndexMarker100"></a>DRY code. I think we can do better. Instead, we’ll only use <code class="CodeInline">.toLowerCase()</code> once—at the top of our function, before we do any string comparison—and use it to change the value of the <code class="CodeInline">lunch</code> variable to the lowercased version of itself that <code class="CodeInline">.toLowerCase()</code><span class="NoBreak"> returns.</span></p>
			<pre class="Code">function mealChecker( lunch ) {</pre>
			<pre class="Code">  lunch = lunch.toLowerCase();</pre>
			<pre class="Code">  if( lunch !== &quot;gravel&quot; &amp;&amp; ( lunch === &quot;burrito&quot; ||   lunch === &quot;tacos&quot; ) ) {</pre>
			<pre class="Code">    console.log( &quot;Delicious.&quot; );</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">}</pre>
			<pre class="Code">mealChecker( &quot;TACOS&quot; );</pre>
			<pre class="Code"><span class="CodeConsole">Delicious.</span></pre>
			<p class="Body">We don’t need <code class="CodeInline">var</code> when we assign a value to <code class="CodeInline">lunch</code>, since using <code class="CodeInline">lunch</code> as an argument means we’ve already defined it as a variable local to the<span class="NoBreak"> function.</span></p>
			<h2 class="AHead"><span class="aHeadCode">switch</span></h2>
			<p class="BodyFirstParagraph">A <a id="_idIndexMarker101"></a><code class="CodeInline">switch</code> statement works a lot like that unwieldy series of <code class="CodeInline">else if</code> statements we tried out, but performs the same sort of comparisons in a more compact, sensible way. The syntax is a little different from the <code class="CodeInline">if</code> syntaxes we’re used to,<span class="NoBreak"> however:</span></p>
			<pre class="Code">var theNumber = 5</pre>
			<pre class="Code">switch( theNumber ) {</pre>
			<pre class="Code">  case 1:</pre>
			<pre class="Code">    console.log( &quot;This is the number one.&quot; );</pre>
			<pre class="Code">    break;</pre>
			<pre class="Code">  case 2:</pre>
			<pre class="Code">    console.log( &quot;This is the number two.&quot; );</pre>
			<pre class="Code">    break;</pre>
			<pre class="Code">  case 3:</pre>
			<pre class="Code">  case 4:</pre>
			<pre class="Code">    console.log( &quot;This is either three or four.&quot; );</pre>
			<pre class="Code">    break;</pre>
			<pre class="Code">  case 5:</pre>
			<pre class="Code">    console.log( &quot;This is the number five.&quot; );</pre>
			<pre class="Code">}</pre>
			<p class="Body">There’s a lot going on in there, so let’s go through this one line by line. Before we do, remember that JavaScript doesn’t care what we use for whitespace—all that indentation is something we’re doing for the sake of readability, but it isn’t<span class="NoBreak"> </span><span class="NoBreak"><em class="Emphasis">required</em></span><span class="NoBreak">.</span></p>
			<p class="Body">The first line is old hat by this point: we’re defining a variable with the identifier <code class="CodeInline">theNumber</code> and giving it a value of the number data type <code class="CodeInline">5</code>—and since we’re just tinkering, we won’t worry about how <code class="CodeInline">theNumber</code> isn’t a very descriptive identifier, accurate though it may<span class="NoBreak"> be.</span></p>
			<p class="Body">The second line looks a little bit like the <code class="CodeInline">if</code> statements we now know and hopefully love: the keyword <code class="CodeInline">switch</code> followed by a set of parentheses and a pair of curly braces. <code class="CodeInline">switch</code> differs from <code class="CodeInline">if</code> in that we’re not performing a comparison between the parentheses, though—instead, we’re just passing along the information we want to compare, the same way we were passing a string to our function a few minutes ago. <code class="CodeInline">switch( theNumber ) {}</code> only says that the variable <code class="CodeInline">theNumber</code> is the value we want to compare within the <code class="CodeInline">switch</code> statement—and that’ll make sense in just a<span class="NoBreak"> moment.</span></p>
			<p class="Body">The third line—<code class="CodeInline">case 1:</code>—is where we perform the actual comparison. The <code class="CodeInline">case</code> keyword is followed by a value that gets compared to the value we passed along in the parentheses after the <code class="CodeInline">switch</code> keyword, followed by a colon. So, the<span class="NoBreak"> line </span> <code class="CodeInline">case 1:</code> is really saying, “If <code class="CodeInline">theNumber</code> is equal to the number one, do the following.” All the comparisons in a <code class="CodeInline">switch</code> are strict—<code class="CodeInline">case &quot;1&quot;:</code> wouldn’t match, since &quot;<code class="CodeInline">1</code>&quot; would be a string type, not a number<span class="NoBreak"> type.</span></p>
			<pre class="Code">switch( &quot;1&quot; ) {</pre>
			<pre class="Code">  case 1:</pre>
			<pre class="Code">    console.log( &quot;This is the number one.&quot; );</pre>
			<pre class="Code">    break;</pre>
			<pre class="Code">  case &quot;1&quot;:</pre>
			<pre class="Code">    console.log( &quot;This is the string &apos;1&apos;&quot; );}<span class="CodeConsole">This is the </span><span class="CodeConsole">string &apos;1&apos;</span></pre>
			<p class="Body">The break statement then says, “We’ve found our match, so stop comparing.” It isn’t always the case that you’d want to stop the comparison right away; if you skip ahead a few lines, you’ll see that we’re checking against <code class="CodeInline">case 3</code> and <code class="CodeInline">case</code><code class="CodeInline"> 4</code>, and if <em class="Emphasis">either</em> of those comparisons match, we’re going on to <code class="CodeInline">console.log</code> that the value is either three or four, then breaking after that. The reason this works is that a matching <code class="CodeInline">case</code> inside <code class="CodeInline">switch</code>, strictly speaking, tells JavaScript, “Run every line of code that follows the matching <code class="CodeInline">case</code> <em class="Emphasis">until you hit a </em><code class="CodeInline">break</code> <em class="Emphasis">keyword</em> (or the end of the <code class="CodeInline">switch</code>’s curly braces).”</p>
			<p class="Body">To illustrate that behavior, let’s say we wanted to put together a function—for whatever reason—that accepts the current numeric day of the week (1–7), and spits out the names of all the days we’ve seen so far this<span class="NoBreak"> </span><span class="NoBreak">week.</span></p>
			<pre class="Code">function daysPassedThisWeek( numericDay ) {</pre>
			<pre class="Code">  console.log( &quot;The following days have already   happened this week:&quot; );</pre>
			<pre class="Code">  switch( numericDay ) {</pre>
			<pre class="Code">    case 7:</pre>
			<pre class="Code">      console.log( &quot;Saturday&quot; );</pre>
			<pre class="Code">    case 6:</pre>
			<pre class="Code">      console.log( &quot;Friday&quot; );</pre>
			<pre class="Code">    case 5:</pre>
			<pre class="Code">      console.log( &quot;Thursday&quot; );</pre>
			<pre class="Code">    case 4:</pre>
			<pre class="Code">      console.log( &quot;Wednesday&quot; );</pre>
			<pre class="Code">    case 3:</pre>
			<pre class="Code">      console.log( &quot;Tuesday&quot; );</pre>
			<pre class="Code">    case 2:</pre>
			<pre class="Code">      console.log( &quot;Monday&quot; );</pre>
			<pre class="Code">    case 1:</pre>
			<pre class="Code">      console.log( &quot;Sunday&quot; );</pre>
			<pre class="Code">      break;</pre>
			<pre class="Code">    default:</pre>
			<pre class="Code">      console.log( &quot;Wait, that isn’t a numbered day       of the week.&quot; );</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">}</pre>
			<pre class="Code">daysPassedThisWeek( 3 ); <span class="CodeComment">/* Today is </span><span class="CodeComment">the third day of the week. */</span></pre>
			<pre class="Code"><span class="CodeConsole">The following days have</span><span class="CodeConsole"> already happened this week:</span></pre>
			<pre class="Code"><span class="CodeConsole">Tuesday</span></pre>
			<pre class="Code"><span class="CodeConsole">Monday</span></pre>
			<pre class="Code"><span class="CodeConsole">Sunday</span></pre>
			<p class="Body">Not the most useful function around, but you get the idea: when <code class="CodeInline">case 3:</code> matches, all the <code class="CodeInline">console.log</code> statements between there and the next <code class="CodeInline">break</code> statement are executed, and we get a list of<span class="NoBreak"> days.</span></p>
			<p class="Body">You’ll also notice something new in this <code class="CodeInline">switch</code> statement: a <code class="CodeInline">default</code><span class="NoBreak"> keyword.</span></p>
			<p class="Body">The <code class="CodeInline">default</code> keyword is the <code class="CodeInline">else</code> of a <code class="CodeInline">switch</code>, if that phrase could possibly make sense: in the event that none of the <code class="CodeInline">case</code> values above it return <code class="CodeInline">true</code>, the code that follows <code class="CodeInline">default</code> will be<span class="NoBreak"> executed.</span></p>
			<pre class="Code">daysPassedThisWeek( 75 );</pre>
			<pre class="Code"><span class="CodeConsole">The following days</span><span class="CodeConsole"> have already happened this week:</span></pre>
			<pre class="Code"><span class="CodeConsole">Wait, that isn’t a</span><span class="CodeConsole"> numbered day of the week.</span></pre>
			<p class="Body">Since we’re putting the <code class="CodeInline">default</code> code last, we don’t need a <code class="CodeInline">break</code> afterwards—but we do need one <em class="Emphasis">before</em> the <code class="CodeInline">default</code>, or else that error will appear with the rest of our list. Though, if you’d prefer, the function above could be written with the <code class="CodeInline">default</code> case coming first, followed by a<span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">break</code></span><span class="NoBreak">.</span></p>
			<pre class="Code">function daysPassedThisWeek( numericDay ) {</pre>
			<pre class="Code">  console.log( &quot;The following days have already   happened this week:&quot; );</pre>
			<pre class="Code">  switch( numericDay ) {</pre>
			<pre class="Code">    default: </pre>
			<pre class="Code">      console.log( &quot;Wait, that isn’t a numbered day       of the week.&quot; );</pre>
			<pre class="Code">      break;</pre>
			<pre class="Code">    case 7:</pre>
			<pre class="Code">      console.log( &quot;Saturday&quot; );</pre>
			<pre class="Code">    case 6:</pre>
			<pre class="Code">      console.log( &quot;Friday&quot; );</pre>
			<pre class="Code">    case 5:</pre>
			<pre class="Code">      console.log( &quot;Thursday&quot; );</pre>
			<pre class="Code">    case 4:</pre>
			<pre class="Code">      console.log( &quot;Wednesday&quot; );</pre>
			<pre class="Code">    case 3:</pre>
			<pre class="Code">      console.log( &quot;Tuesday&quot; );</pre>
			<pre class="Code">    case 2:</pre>
			<pre class="Code">      console.log( &quot;Monday&quot; );</pre>
			<pre class="Code">    case 1:</pre>
			<pre class="Code">      console.log( &quot;Sunday&quot; );</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">}</pre>
			<pre class="Code">daysPassedThisWeek( 5 ); <span class="CodeComment">/* Today </span><span class="CodeComment">is the fifth day of the week. */</span></pre>
			<pre class="Code"><span class="CodeConsole">The following days </span><span class="CodeConsole">have already happened this week:</span></pre>
			<pre class="Code"><span class="CodeConsole">Thursday</span></pre>
			<pre class="Code"><span class="CodeConsole">Wednesday</span></pre>
			<pre class="Code"><span class="CodeConsole">Tuesday</span></pre>
			<pre class="Code"><span class="CodeConsole">Monday</span></pre>
			<pre class="Code"><span class="CodeConsole">Sunday</span></pre>
			<p class="Body"><code class="CodeInline">switch</code> is a weird one, for sure, but there are a few situations where performing a series of comparisons against a single object will make a lot of sense. For instance, imagine a script that accepts keyboard input and uses it to move a sprite—many games ask you to use either the arrow keys or the <em class="Emphasis">A</em> and <em class="Emphasis">D</em> keys to move left and right. In JavaScript, key presses are represented by an event object—which we’ll discuss a little later on—with a property containing a numeric value that corresponds to the key that was<span class="NoBreak"> pressed.</span></p>
			<pre class="Code">function movePlayer( keyCode ) {</pre>
			<pre class="Code">  switch( keyCode ) {</pre>
			<pre class="Code">    case 65: <span class="CodeComment">// Keycode for the</span><span class="CodeComment"> A key</span></pre>
			<pre class="Code"><span class="CodeComment">    </span>case 37: <span class="CodeComment">// Keycode for the left arrow</span></pre>
			<pre class="Code">      moveLeft();</pre>
			<pre class="Code">      break;</pre>
			<pre class="Code">    case 68: <span class="CodeComment">// Keycode for the D key</span></pre>
			<pre class="Code">    case 39: <span class="CodeComment">// Keycode for the right arrow</span></pre>
			<pre class="Code"><span class="CodeComment">      </span>moveRight();</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">}</pre>
			<p class="Body">You could write this as a series of <code class="CodeInline">if</code> statements as well, but adding new controls over time would mean chaining one <code class="CodeInline">if</code> after another, all performing comparisons against the<span class="NoBreak"> same</span><span class="NoBreak"> </span> <code class="CodeInline">keyCode</code> object. <code class="CodeInline">switch</code> ends up being a much more flexible—and <a id="_idIndexMarker102"></a>DRY—way to go about<span class="NoBreak"> it.</span></p>
			<h2 class="AHead">THAT ESCALATED QUICKLY</h2>
			<p class="BodyFirstParagraph">From “if this, do that” to methods of expressing incredibly complex logic, all wrapped up in the humble <code class="CodeInline">if</code> and <code class="CodeInline">switch</code> keywords. It’s a lot to keep in your head, but again: we don’t have to. Instead, we can walk away from this chapter knowing that there’s <em class="Emphasis">some</em> way to express whatever conditional logic we might need—and if you can’t remember the exact syntax off the top of your head, well, this chapter isn’t going<span class="NoBreak"> anywhere.</span></p>
			<p class="Body">Conditional statements allow us to selectively execute code, but there’s more to control flow than that. Programming frequently involves performing a set of tasks over and over again—for example, iterating over all elements of a certain type within a page and checking a common attribute against an expected value, or iterating over all the items in an array and checking their values against a conditional statement. In order to do those kinds of things, we’ll need to learn about<span class="NoBreak"> loops.</span></p>
		</div>
	</body>
</html>
