<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
	<head>
		<title>image-performance_draft-3-6</title>
		<link href="css/aba-image_performance.css" rel="stylesheet" type="text/css" />
	</head>
	<body id="image-performance_draft-3-6" lang="en-US" xml:lang="en-US">
		<div id="_idContainer010" style="page-break-after: always;">
			<a id="_idTextAnchor003"></a><img src="image/ch01.png" alt="Chapter 1. Image Formats and Compression" id="_idParaDest-3"/>
		</div>
		<div id="_idContainer052">
			<p class="BodyFirstParagraph"><span class="ChapterIntro">Over the course of the next few chapters</span>, we’re going to cover a surprising amount of ground. But before digging into responsive image use cases and syntaxes—before combing through the nuances of browsers’ speculative preparsers and how requests for image sources are made—we have to start with a little gr<span class="NoBreak">oundwork. </span></p>
			<p class="Body">Choosing the right image format is a topic I’m betting will be familiar to more than a few of you. It might be a bit of a refresher for some, but I won’t mince words: getting this part right can be far more important than any flashy new “responsive image” technique. An image source that is only a few hundred kilobytes as a JPEG might be several megabytes as a PNG-24, without any discernable difference in quality to the<span class="NoBreak"> end</span><span class="NoBreak"> user.</span></p>
			<p class="Body">In making decisions about formats, encodings, compression levels, and so on, we need to consider the contents of the image: is it a real-world photo or an illustration? We have to decide one level higher than JPEG versus PNG: we have to look at vector versus raste<span class="NoBreak">r</span><span class="NoBreak"> formats.</span></p>
			<h2 class="AHead"><a id="_idIndexMarker000"></a>Vector Formats</h2>
			<p class="BodyFirstParagraph">When we talk about vector images on the web, we’re talking about <a id="_idIndexMarker001"></a>Scalable Vector Graphics (SVG). I don’t mind admitting I was a little resistant to SVG at first, even as it was becoming more and more commonplace. SVGs are made of <em class="Emphasis">math</em>—and that alone was enough to bias me against it conceptually. I lived and breathed raster, and “vector” conjured up images of ill-fated forays out of my Photoshop comfort zone and into the uncanny valley of Illustrator—where my muscle-memory for key commands was just wrong enough to be frustrating, and where there were no comforting little squares to z<span class="NoBreak">oom in</span><span class="NoBreak"> on.</span></p>
			<p class="Body">But upon opening an SVG in my code editor for the first time—by accident, knowing me—I was presented with something immediately recognizable and deeply comfortin<span class="NoBreak">g:</span><span class="NoBreak"> </span><span class="NoBreak"><a id="_idIndexMarker002"></a></span><span class="NoBreak"><em class="Emphasis">markup</em></span><span class="NoBreak">.</span></p>
			<pre class="Code">&lt;?xm<a id="_idTextAnchor004"></a><a id="_idTextAnchor005"></a>l version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</pre>
			<pre class="Code">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;</pre>
			<pre class="Code">  &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;50&quot; fill=&quot;red&quot; /&gt;</pre>
			<pre class="Code">&lt;/svg&gt;</pre>
			<p class="Body">Granted, it isn’t HTML markup—but it’s close enough to make sense at a glance. Those of you who have been in the industry for a while might recognize it as our old fr<span class="NoBreak">iend XML. </span></p>
			<p class="Body">For simple edits, like changing the opacity or color of an icon, we don’t have to fire up Adobe Illustrator—we can make those changes in the SVG itself. We can style them and animate them with real CSS, both in the SVG file and from the page that contains them (<span class="FigureNumberInline">F</span><span class="NoBreak"><span class="FigureNumberInline">ig 1.1</span></span><span class="NoBreak">). </span></p>
			
				<figure id="_idContainer013" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/1-1.png" alt="Figure" /></span></p>
					<figcaption class="FigureCaption"><span class="FigureNumber"><span class="FigureNumberInline">Fig 1.1:</span></span> These three shapes use the same SVG markup—but their fill colors are controlled through CSS, the same way we’d style any other element on the page.</figcaption>
				</figure>
			
			<p class="Body">We can even add custom <a id="_idIndexMarker003"></a><em class="Emphasis">scripting</em> to an SVG, in order to bake behaviors and interactions into the images themselves <span class="NoBreak">(</span><span class="NoBreak"><span class="FigureNumberInline">Fig 1.2</span></span><span class="NoBreak">).</span></p>
			<p class="Body">And as much as that might appeal to us as designers and developers, SVG is also an <em class="Emphasis">incredibly</em> powerful format in terms of the end user experience. It is, by any practical measure, an image format built for the m<span class="NoBreak">odern</span><span class="NoBreak"> web.</span></p>
			<p class="Body">The most critical difference between vector and raster formats is—as the SVG name implies—<em class="Emphasis">scalability</em>. To oversimplify, SVG is a method of communicating a series of coordinates to a browser’s rendering engine, a set of instructions for how shapes should be drawn. The task of connecting these points is left to the browser—so when that set of coordinates is scaled up or down, the lines and shapes connecting them are redrawn to scale <span class="NoBreak">(</span><span class="NoBreak"><span class="FigureNumberInline">Fig 1.3</span></span><span class="NoBreak">).</span></p>
			<p class="Body">Raster images are more fixed: pixel-by-pixel instructions for rendering, with no fill-in-the-blanks for the browser in between. When scaled up—well, odds are you’ve seen the results in the past, possibly by mistake. A raster image source scaled beyond its inherent dimensions tends to appear distorted, blocky, or blurred (<span class="FigureNumberInline">Fi</span><span class="NoBreak"><span class="FigureNumberInline">g 1.4</span></span><span class="NoBreak">).</span></p>
			<figure id="_idContainer015" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/1-2.png" alt="Figure" /></span></p>
					<p class="FigureCaption"><span class="FigureNumber"><span class="FigureNumberInline">Fig 1.2:</span></span> We can use JavaScript to add behaviors and interactions to an embedded SVG—such as toggling this star icon on and off with a click.</p>
				</figure>
			<figure id="_idContainer017" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/1-3.png" alt="Figure" /></span></p>
					<figcaption class="FigureCaption"><span class="FigureNumber"><span class="FigureNumberInline">Fig 1.3:</span></span> A resized vector image will be redrawn with sharp lines.</figcaption>
				</figure>
			<figure id="_idContainer019" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/1-4.png" alt="Figure" /></span></p>
					<figcaption class="FigureCaption"><span class="FigureNumber"><span class="FigureNumberInline">Fig 1.4:</span></span> A raster image scales proportionally, and the result looks blurry at the edges.</figcaption>
				</figure>
			<p class="Body">SVG doesn’t suffer from this issue—a smooth curve between two points, drawn by the browser, will be redrawn just as smoothly at any size. We’re going to spend a lot of time on the topic of ensuring that users receive viewport- and display-density-appropriate raster images—but with SVG, it’s a given. And as you saw in the earlier example, the markup powering an infinitely scalable SVG source can be incredibl<span class="NoBreak">y</span><span class="NoBreak"> compact.</span></p>
			<p class="Body">All that said, though, there are a few caveats to consider. Browser support for SVG is very good, but not guaranteed—not in the way that support for common raster formats can be universally assumed. Leaving a user without images in some contexts could very well mean leaving them with a website they can’t navigate—so, depending on your project and how SVGs are being used, you might need to provide a fallback in the form of a better-supported raster version of the image source. All told, though, this is fairly easy to automate—projects like <a href="http://www.grunticon.com/"><span id="_idIndexMarker004"></span><span class="URL">Grunticon</span></a> handle generation of raster fallbacks for us, and there’s a simple method for serving the correct asset to the end user. We’ll talk more about that in the nex<span class="NoBreak">t</span><span class="NoBreak"> chapter.</span></p>
			<p class="Body">There’s another catch with SVG, and this one is a key part of the decision between raster and vector for a given application: complexity. By nature of its function, the SVG format needs a little more active interpretation from the browser than raster formats—SVG’s “draw a smooth curve connecting this point to that point” involves more thinking than raster’s “draw a blue pixel, then a dark blue pixel, then a darker blue pixel, etc.” For this reason, complex SVGs can be more taxing to render—and potentially larger, over-the-wire, than rast<span class="NoBreak">er</span><span class="NoBreak"> images.</span></p>
			<p class="Body">There’s no hard-and-fast rule there; it may take a little trial and error before you’re able to instantly recognize an image source candidate as better served by SVG versus a conventional raster format. There are a few guidelines, though. For my money, I can say that <a id="_idIndexMarker005"></a>interface elements—such as icons—are almost always better served by SVG than raster image sources. In fact, anywhere the icon fonts of yesteryear might have felt appropriate is likely to be a strong candidat<span class="NoBreak">e for</span><span class="NoBreak"> SVG.</span></p>
			<p class="Body">For artwork containing multiple gradients, photo-realism, or intricate detail, though—when only pixel perfection will do—raster images are still the right tool fo<span class="NoBreak">r the</span><span class="NoBreak"> job.</span></p>
			<h2 class="AHead"><a id="_idIndexMarker006"></a>Raster Formats</h2>
			<p class="BodyFirstParagraph">The lion’s share of your content images—from photographs to animated GIFs—are going to be raster images. There’s plenty more to discuss on this subject—and we will—but for now: think of a raster image as a two-dimensional grid made up of <a id="_idIndexMarker007"></a>pixels, like so many brothe<span class="NoBreak">rs Mario. </span></p>
			<p class="Body">When we break raster images down into formats—JPEG versus GIF versus PNG, and so on—what we’re really talking about are the compression methods (or lack thereof) we’re applying. Ultimately, choosing the appropriate raster-image format is about striking a balance between fidelity and <span class="NoBreak">file</span><span class="NoBreak"> size.</span></p>
			<p class="Body">Now, I’m the first to admit I don’t have much of a mind for algorithms. But as a web developer—or maybe as the product of a Nintendo-centric childhood—I definitely have a mind for little pictures made of squares. So, in thinking about image formats, it helps to keep a pixel grid in mind (<span class="NoBreak"><span class="FigureNumberInline">Fig 1.5</span></span><span class="NoBreak">).</span></p>
			<figure id="_idContainer021" class="figFrame">
					<figcaption class="FigureCaption"><span class="FigureNumber"><img src="image/1-5.png" alt="Figure" />Fig 1.5:</span> Think of this as a close-up view of a raster image’s pixels.</figcaption>
				</figure>
			<p class="Body">Imagine this is the entirety of our source image. Choosing an image format effectively means choosing the method by which we’re describing the contents of the file. For example, the top row of our grid could be des<span class="NoBreak">cribed</span><span class="NoBreak"> as:</span></p>
			<ul>
				<li class="BodyBulletList">Row one, column one<span class="NoBreak"> is blue. </span></li>
				<li class="BodyBulletList">Row one, column two<span class="NoBreak"> is blue. </span></li>
				<li class="BodyBulletList">Row one, column three<span class="NoBreak"> is blue. </span></li>
				<li class="BodyBulletList">Row one, column fo<span class="NoBreak">ur is</span><span class="NoBreak"> red.</span></li>
			</ul>
			<p class="Body">But it could also be des<span class="NoBreak">cribed</span><span class="NoBreak"> as:</span></p>
			<ul>
				<li class="BodyBulletList">Row one, columns one through three <span class="NoBreak">are blue. </span></li>
				<li class="BodyBulletList">Row one, column fo<span class="NoBreak">ur is</span><span class="NoBreak"> red.</span></li>
			</ul>
			<p class="Body">Assume you’re playing the role of a web browser. You’re ready—crayons and paper in hand—to render an image. I’m playing the role of a web server, and as such, I communicate in much the same way I do here in the text: I can’t convey <em class="Emphasis">an image</em>; I can only de<span class="NoBreak">scribe</span><span class="NoBreak"> it.</span></p>
			<p class="Body">If I were to ask you to draw a grid, and I read either of the previous descriptions to you, you’d end up with the same result—the same information is conveyed in either case. The first method does so absent any sort of compression: one “pixel” at a time. The second method, however, manages to describe the same image with far fewer characters. Or, in more practical terms: fewer bytes transferred over the wire, from the server (me) to the rendering eng<span class="NoBreak">ine (you).</span></p>
			<p class="Body">Now, as you’ve probably guessed, this method of “encoding” and “decoding” an image doesn’t resemble most actual formats in a meaningful way—there are often much more efficient ways to describe a grid, computationally speaking, than row-by-row and column-by-column. But it does come pretty close to describing one format: our old friend the GIF, animated or<span class="NoBreak"> </span><span class="NoBreak">otherwise.</span></p>
			<h3 class="BHead"><a id="_idIndexMarker008"></a>GIF</h3>
			<p class="BodyFirstParagraph">Saving an image as a GIF almost always means irrevocably reducing the fidelity of the origi<span class="NoBreak">nal</span><span class="NoBreak"> image.</span></p>
			<p class="Body">That might sound scary on the surface, but it’s worth keeping in mind that our eyes, well, they don’t have the best fidelity either. Fine-tuning image <a id="_idIndexMarker009"></a>compression is about striking a balance between the level of detail we’re able to perceive and the level of detail being passed along to the computer rendering th<span class="NoBreak">at image. </span></p>
			<p class="Body">Think back to our raster image grid, and how that information is passed from server to browser. This time around, let’s add a little more detail: a single darker pixel (<span class="NoBreak"><span class="FigureNumberInline">Fig 1.6</span></span><span class="NoBreak">).</span></p>
			<figure id="_idContainer023" class="figFrame">
					<figcaption class="FigureCaption"><span class="FigureNumber"><img src="image/1-6.png" alt="Figure" />Fig 1.6:</span> Adding a small detail to our pixel grid can add a lot of complexity to its encoding.</figcaption>
				</figure>
			<p class="Body">As simple as this image is, it wouldn’t take many characters to break this down into something human<span class="NoBreak">-readable:</span></p>
			<ul>
				<li class="BodyBulletList">Row one, columns one through three are blue. Row one, column fo<span class="NoBreak">ur is</span><span class="NoBreak"> red.</span></li>
				<li class="BodyBulletList">Row two, column one is blue. Row two, column two is dark blue. Row two, column three is blue. Row two, column fo<span class="NoBreak">ur is</span><span class="NoBreak"> red.</span></li>
				<li class="BodyBulletList">Row three, columns one through three are blue. Row <a id="_idTextAnchor006"></a><a id="_idTextAnchor007"></a>three, column fo<span class="NoBreak">ur is</span><span class="NoBreak"> red.</span></li>
				<li class="BodyBulletList">Row four, columns one through three are blue. Row four, column fo<span class="NoBreak">ur is</span><span class="NoBreak"> red.</span></li>
			</ul>
			<p class="Body">Assuming you and I have the same definition of “blue,” “dark blue,” and “red,” that description would allow you to render a pixel-perfect interpretation of the original image. Think of this as a <em class="Emphasis">lossless</em> method of compressing the image data for transfer from me to you. We’ve managed to condense the pixel-by-pixel description in a few places (“columns one through three are…”), but with no change to the visual<span class="NoBreak"> fidelity.</span></p>
			<p class="Body">Now, suppose we take a <em class="Emphasis">lossy</em> approach to that<span class="NoBreak"> de</span><span class="NoBreak">scription:</span></p>
			<ul>
				<li class="BodyBulletList">Row one, columns one through three are blue. Row one, column fo<span class="NoBreak">ur is</span><span class="NoBreak"> red.</span></li>
				<li class="BodyBulletList">Row two, columns one through three are blue. Row two, column fo<span class="NoBreak">ur is</span><span class="NoBreak"> red.</span></li>
				<li class="BodyBulletList">Row three, columns one through three are blue. Row three, column fo<span class="NoBreak">ur is</span><span class="NoBreak"> red.</span></li>
				<li class="BodyBulletList">Row four, columns one through three are blue. Row four, column fo<span class="NoBreak">ur is</span><span class="NoBreak"> red.</span></li>
			</ul>
			<p class="Body">I’ve simplified the description of our original image, and the end result is that we’ve sacrificed pixel-perfection—as the rendering engine, you’ve rendered the image exactly as I’ve encoded it—but I left out the detail of the darker blue cell in my encoding, for the sake of a smaller transfer size. This specific lossy compression technique is called <a id="_idIndexMarker010"></a><em class="Emphasis">quantization</em>, where a range of values are reduced to a smaller, approximated set of outp<span class="NoBreak">ut</span><span class="NoBreak"> values.</span></p>
			<p class="Body">Reducing three colors to two across the span of a whopping twelve “pixels” makes for an obvious change (<span class="FigureNumberInline">Fig 1.7</span>). Across a larger and more detailed image, however, the effects might not be as noticeable—to a point. As we increase the lossyness of a GIF, the smooth gradients of the original image are replaced by a mottled effect (<span class="FigureNumberInline">Fig 1.8</span>). The file size plummets from around 318 KB to around 54 KB, and it—well—it becomes mor<span class="NoBreak">e pixel-y.</span></p>
			<figure id="_idContainer025" class="figFrame">
					<div>
						<div id="_idContainer024" class="figure">
							<img src="image/1-7.png" alt="Figure" />
						</div>
					</div>
					<figcaption class="FigureCaption"><span class="FigureNumber">Fig 1.7:</span> A lossy approach to compressing the previous image data means we’ve lost the dark blue detail.</figcaption>
				</figure>
			<p class="Body">We can reduce file sizes even further by manually restricting the color palette. What we end up with, then, is an image that retains the basic shape and hue of our original, but in a barely recognizable form (<span class="FigureNumberInline">Fig 1.9</span>). It would be smaller (weighing in at only 23 KB or so), but not terribl<span class="NoBreak">y useful.</span></p>
			<figure id="_idContainer027" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/1-8.png" alt="Figure" /></span></p>
					<p class="FigureCaption"><span class="FigureNumber">Fig 1.8:</span> The more we increase the lossy compression, the more conspicuous it becomes.</p>
				</figure>
			<p class="Body"> In practice, all of this means that GIFs are suited for a slim number of appli<span class="NoBreak">cations:  </span></p>
			<ul>
				<li class="BodyBulletList">limited color palettes and <span class="NoBreak">hard</span><span class="NoBreak"> edges</span></li>
				<li class="BodyBulletList">binary transparency (as in: a pixel is either 100 percent transparent, or 100 perce<span class="NoBreak">nt</span><span class="NoBreak"> opaque)</span></li>
				<li class="BodyBulletList">animation</li>
			</ul>
			<p class="Body">All told, I don’t find much call for an old-fashioned GIF in my day-to-day work, not anymore. Images with limited color palettes and hard edges—icons, line art, stylized flat-color illustrations—are almost always better serve<span class="NoBreak">d by SVG. </span></p>
			<p class="Body">And I don’t have much need for GIF-style binary transparency, either—not when <a id="_idIndexMarker011"></a>PNG-24 handles <a id="_idIndexMarker012"></a>transparency so mu<span class="NoBreak">ch</span><span class="NoBreak"> better.</span></p>
			<p class="Body">As for animation, well…that’s where I can’t help but feel a little conflicted. I am, I don’t mind admitting, something of an animated GIF<span class="NoBreak"> e</span><span class="NoBreak">nthusiast.</span></p>
			<h4 class="CHead"><a id="_idIndexMarker013"></a>An<span class="NoBreak">imated</span><span class="NoBreak"> GIF</span></h4>
			<figure id="_idContainer029" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/1-9.png" alt="Figure" /></span></p>
					<figcaption class="FigureCaption"><span class="FigureNumber">Fig 1.9:</span> Taken to its extreme, we have a barely recognizable—if much smaller—image.</figcaption>
				</figure>
			<p class="BodyFirstParagraph">For all intents and purposes, animated GIFs behave like self-contained flipbooks of individual GI<span class="NoBreak">F stills. </span></p>
			<p class="Body">They’re refreshingly simple, in both composition and use. If you see an animated GIF you like, you can grab it and throw it in a <a href="https://bukk.it/"><span class="URL">bukkit</span></a>. You can open it up in an image editor, edit it, remix it, and resave it as a new GIF—Photoshop, for example, opens an animated GIF as a set of layers, each of which contains one frame of the animation. You can upload it to an incredible number of venues, with a click or a drag: chat clients, social media networks, text message conversations, whatever—and the process<span class="NoBreak"> repeats. </span></p>
			<p class="Body">Animated GIF <em class="Emphasis">feels</em> almost analog, harkening back to the early days of the web itself—a little clunky, but made to be pulled apart and<span class="NoBreak"> u</span><span class="NoBreak">nderstood.</span></p>
			<p class="Body">In every user-facing way, though, animated GIFs are practically<span class="NoBreak"> ind</span><span class="NoBreak">efensible.</span></p>
			<p class="Body">They’re slow to render, and excruciating in terms of file size. From an accessibility standpoint, it’s difficult—at times, impossible—to sum up the contents of a complex animation in a single, terse <code class="CodeInline">alt</code> attribute. The role of animated GIFs is almost invariably better served by short video clips—and video formats have the potential for richer accessibility features, like captioning and audio description tracks, more than an <code class="CodeInline">alt</code> could ever hope t<span class="NoBreak">o</span><span class="NoBreak"> provide.</span></p>
			<p class="Body">As such, animated GIFs are becoming less common. In fact, in order to retain the long-honed performance optimizations of the <code class="CodeInline">img</code> element <em class="Emphasis">and</em> make use of the reduced file sizes of video formats, several browsers have expanded the <code class="CodeInline">img</code> element’s <code class="CodeInline">src</code> attribute to accept <a id="_idIndexMarker014"></a>video source files—you can see this in Safari, at the time of writing, and <a href="http://bkaprt.com/ip/01-01/"><span class="URL">Chrome isn’t far behind</span></a>. By any measurable metric, that’s a win. Services like Twitter now convert animated GIF uploads to <a id="_idIndexMarker015"></a><span class="LiningFigures">MP4</span> video, behind the scenes, before the associated tweet is posted, and that’s a win too—it’s great for performance and<span class="NoBreak"> </span><span class="NoBreak">usability.</span></p>
			<p class="Body">At my least generous, though, I can’t help but notice that it provides Twitter with fertile new ground for advertisements. And those animations are now siloed—the generated files aren’t something that a layperson can easily save, edit, or share on other services. Users can, of course, share a link to the tweet on Twitter dot com, and boost those engagemen<span class="NoBreak">t</span><span class="NoBreak"> numbers.</span></p>
			<p class="Body">Animated GIF—and maybe the GIF format itself—might just end up going the way of the carburetor and the record player. They’re impractical, sure; nobody would argue that a record beats an <span class="LiningFigures">MP3</span> for portability, or that an electronic fuel injection system is less reliable than a ca<span class="NoBreak">rburetor. </span></p>
			<p class="Body">But still. There’s just something warmer abo<span class="NoBreak">ut</span><span class="NoBreak"> analog.</span></p>
			<h3 class="BHead">PNG</h3>
			<p class="BodyFirstParagraph"><a id="_idIndexMarker016"></a>PNG (Portable Network Graphics) comes in three <span class="NoBreak">variants: </span></p>
			<ul>
				<li class="BodyBulletList"><em class="Emphasis">grayscale</em> PNG, which is limited to black and white (or shade<span class="NoBreak">s of</span><span class="NoBreak"> gray)</span></li>
				<li class="BodyBulletList"><em class="Emphasis">indexed color</em> PNG (Photoshop calls it “PNG-8”), which can contain up to 2<span class="NoBreak">56</span><span class="NoBreak"> colors </span></li>
				<li class="BodyBulletList"><em class="Emphasis">truecolor</em> PNG (a.k.a. “PNG-24”), which can contain many, many more colors—up to <span class="NoBreak">16</span><span class="NoBreak"> million</span></li>
			</ul>
			<p class="Body">There are a few things that set PNG apart from other formats. First, it was built for <a id="_idIndexMarker017"></a><em class="Emphasis">lossless compression</em>, meaning that the encoding <em class="Emphasis">itself</em> can be compressed—the way you might convert a huge text file to a <a id="_idIndexMarker018"></a>ZIP to shave off a few bytes—but none of the actual image data will be reduced. In practical terms, that means that saving a source image as a lossless, truecolor PNG will never result in a drop in visual quality—but it <em class="Emphasis">will</em> result in much larg<span class="NoBreak">er files. </span></p>
			<p class="Body">Second, while GIF handles transparency as sort of a binary proposition—either a pixel is 100 percent transparent or 100 percent opaque—PNG supports semi-tra<span class="NoBreak">nsparency.</span></p>
			<p class="Body">Between its large color palettes and its lossless compression methods, <a id="_idIndexMarker019"></a>PNG-24 is a good choice for the canonical source version of an image—but rarely, if ever, the right choice. The use cases for PNG are similar to those of GIF: images with limited color palettes and sharp lines—cases where, more often than not, an SVG is the bette<span class="NoBreak">r choice. </span></p>
			<p class="Body">You’ll really only require a PNG when you need one specific feature: a raster-formatted image with transparency. Because PNG was designed to solve use cases that are now better served by SVG, you’ll often see PNG used as the fallback version of UI elements in browsers that don’t support SVG. Truth be told, that’s almost the only time I use PNG<span class="NoBreak">s</span><span class="NoBreak"> anymore.</span></p>
			<h3 class="BHead"><a id="_idIndexMarker020"></a>JPEG</h3>
			<p class="BodyFirstParagraph">JPEG is far and away the most common image format used throughout the web, and with good reason: it’s almost invariably the right choice for photographs. In fact, the use case is right there in the name, if a little obscured—“JPEG” itself stands for Joint Photographic Experts Group, the committee responsible for issuing the standard way back in 1992. You’ll see the file extension for a JPEG as either <span class="digitalName">.jpg</span> or <span class="digitalName">.jpeg</span>,<span class="NoBreak"> interc</span><span class="NoBreak">hangeably.</span></p>
			<p class="Body">JPEG is the poster format for lossy compression. Just like GIF, saving an image as JPEG means reducing the quality of that image. But unlike GIF, JPEG compression operates in a number of ways beyond<span class="NoBreak"> qua</span><span class="NoBreak">ntization.</span></p>
			<p class="Body">Let me get this out of the way right up front: unlike the refreshingly simple pixel-by-pixel encoding that GIF uses, JPEG compression is based on algorithms with names like “discrete cosine transform,” which—<a href="http://bkaprt.com/ip/01-02/"><span class="URL">to quote Wikipedia directly</span></a>—“expresses a finite sequence of data points in terms of a sum of cosine functions oscillating at different fre<span class="NoBreak">quencies.”</span></p>
			<p class="Body">Now, if this sentence has awakened in you a burning need to learn more about the dark and arcane math that powers images on the web, you have my blessing. However—and I cannot stress this enough—you <em class="Emphasis">also</em> have my blessing to forget this information forever. Personally, I’ve never met an MIT URL that made a whole lot of sen<span class="NoBreak">se to me. </span></p>
			<p class="Body">So, in this section, I’m going to take a few liberties with the way a JPEG might be encoded into human-readable language. As you might expect from a format built around one computer communicating to another as efficiently as possible, it doesn’t translate well to the wri<span class="NoBreak">tten</span><span class="NoBreak"> word.</span></p>
			<h4 class="CHead"><a id="_idIndexMarker021"></a>Do<span class="NoBreak">wnsampling</span></h4>
			<p class="BodyFirstParagraph">Remember when I said our eyes are a little lossy in and of themselves? In terms of processing visual information, there’s a lot we humans can’t do very well. We’re not great at processing “high-frequency detail”—we’re able to recognize a tree, tell it apart from other trees, and even see a forest for said trees on a good day. But what we don’t see—or we do <em class="Emphasis">see</em>, I suppose, but don’t fully <em class="Emphasis">process</em> at a glance—are the positions of each leaf on the tree. We can seek out this information, for sure—but driving past a row of trees, we’re not looking for each individual leaf in relation to those ar<span class="NoBreak">ound</span><span class="NoBreak"> them.</span></p>
			<p class="Body">Likewise, come autumn, we see that the leaves on that tree have turned yellow—we can quickly absorb that there are different shades of yellow, the colors changing along gradients, the ambient lighting and shadow. We don’t capture the precise hue of each individual leaf in comparison to the one beside it. To put it in what I hope are increasingly familiar terms: we just don’t have that kind of bandwidth. Mentally, we round things off, so we’re not constantly overwhelmed b<span class="NoBreak">y</span><span class="NoBreak"> details.</span></p>
			<p class="Body">JPEG compression attempts to compress an image source in a way that (loosely) matches the way our own psychovisual systems “compress” an image source. In effect, JPEG tries to throw away details we weren’t likely to notice anyway so it can sneak the compression<span class="NoBreak"> past us. </span></p>
			<p class="Body">At its core, that isn’t too different from a GIF; simply reducing the fidelity of a photograph ever so slightly might not register to our eyes, but it does reduce file size. With a GIF, removing a few colors from a photograph can mean a big reduction in quality for a relatively minor reduction in file size. With a JPEG, we can round down the level of detail in a way that might not register at all to our lossy eyes, if done within reason—<em class="Emphasis">and</em> introduce far more opportunities for bandwidth<span class="NoBreak"> savings. </span></p>
			<p class="Body">JPEG does that rounding down—<em class="Emphasis">downsampling</em>, it’s called—in a particularly interesting way. It takes advantage of the fact that humans are more sensitive to differences in brightness than to differences in hue. As with GIF, color details (or <a id="_idIndexMarker022"></a><em class="Emphasis">chroma</em>) can be reduced. Unlike with GIF, though, luminance details (or <a id="_idIndexMarker023"></a><em class="Emphasis">luma</em>) are <span class="NoBreak">retained.</span></p>
			<figure id="_idContainer031" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/1-10.png" alt="Figure" /></span></p>
					<figcaption class="FigureCaption"><span class="FigureNumber">Fig 1.10:</span> A photograph separated into luma (luminance) and chroma (color) layers.</figcaption>
				</figure>
			<p class="Body">You can think of luma as a separate light/dark layer superimposed over our colors. For example, this photograph of a handsome dog—one who could <em class="Emphasis">never&#173;</em> be mistaken for a deer—has been broken down into its luma and chroma layers (<span class="FigureNumberInline">Fig 1.10</span>). Superimpose those two layers again, and you have your source image (<span class="FigureNumberInline">F</span><span class="NoBreak"><span class="FigureNumberInline">ig 1.11</span></span><span class="NoBreak">).</span></p>
			<figure id="_idContainer033" class="figFrame">
					<div>
						<div id="_idContainer032" class="figure">
							<img src="image/1-11.png" alt="Figure" />
						</div>
					</div>
					<p class="figHolder"><span class="FigureNumber">Fig 1.11:</span> While not explicitly encoded in the image, it can be assumed that the subject of the photograph is a <a id="_idIndexMarker024"></a>very<span class="NoBreak"> good</span><span class="NoBreak"> boy.</span></p>
				</figure>
			<p class="Body">It might seem like an academic distinction, as though GIF describes part of an image as “dark blue,” while JPEG describes part of an image as “blue, dark.” But by separating chroma and luma, JPEG is able to leverage one of our major psychovisual weaknesses: our eyes aren’t as good at noticing slight differences in chroma as they are at noticing slight differences in luma. By throwing away detail from the layer we can’t process as well but leaving the luma layer untouched, more opportunities for compression are created without causing noticeable degradation in the result. Slight differences in the <a id="_idIndexMarker025"></a><em class="Emphasis">hue</em> of blue might be rounded down, but its brightness will be retained—and we likely won<span class="NoBreak">’t</span><span class="NoBreak"> notice.</span></p>
			<p class="Body">Now, I mentioned before that JPEG has complicated, math-heavy methods of encoding images—we’re not going to dig into those, but suffice to say that JPEG encoding doesn’t encode images one pixel at a time the way GIF does. While “one pixel at a time, left to right, top to bottom” is easy for us humans to understand, it isn’t a terribly efficient way to describe a source. So, instead, JPEG encodes the image as eight-by-eight blocks of pixels and describes the <em class="Emphasis">blocks</em>—not the individual pixels inside them—algorit<span class="NoBreak">hmically. </span></p>
			<p class="Body">Consider that an image transfer is a computer communicating to another computer, and that sorting through information is something <a href="http://bkaprt.com/ip/01-03/"><span class="URL">computers excel at doing efficiently</span></a>, but in ways that aren’t necessarily scrutable in writing. So, a grain of salt: I’m taking a few liberties as I convert aspects of JPEG encoding into human-readable<span class="NoBreak"> language.</span></p>
			<p class="Body">In terms of relayed instructions, you can think of JPEG downsampling as turning an image source into two sets of instructions. One encod<span class="NoBreak">es</span><span class="NoBreak"> chroma:</span></p>
			<ul>
				<li class="BodyBulletList">All blocks<span class="NoBreak"> are</span><span class="NoBreak"> blue.</span></li>
			</ul>
			<p class="Body">The other enco<span class="NoBreak">des luma: </span></p>
			<ul>
				<li class="BodyBulletList">The first half of the block at row two, column two is darker (<span class="NoBreak"><span class="FigureNumberInline">Fig 1.12</span></span><span class="NoBreak">).</span></li>
			</ul>
			<figure id="_idContainer035" class="figFrame">
					<p class="FigureCaption"><span class="FigureNumber"><img src="image/1-12.png" alt="Figure" />Fig 1.12:</span> Rather than describing each individual pixel, JPEG encoding describes blocks of pixels.</p>
				</figure>
			<p class="Body">This may not seem like much of a win over GIF-style encoding, especially with this example—an image with flat colors and sharp lines. But JPEG is well suited to a much more common use case for images: gradients (<span class="FigureNumberInline">F</span><span class="NoBreak"><span class="FigureNumberInline">ig 1.13</span></span><span class="NoBreak">).</span></p>
			<figure id="_idContainer037" class="figFrame">
					<p class="FigureCaption"><span class="FigureNumber"><img src="image/1-13.png" alt="Figure" />Fig 1.13:</span> A pixel grid showing a light-to-dark-blue gradient.</p>
				</figure>
			<p class="Body">Describing a gradient using GIF-style encoding would be extremely verbose. Compressing it using GIF-style lossy compression would reduce the transfer size—but not without a pretty noticeable change in the rendered result. In restricting the color palette, we’d lose detail; the resulting image would have a sharp line between the light and dark shades of blue (<span class="FigureNumberInline">F</span><span class="NoBreak"><span class="FigureNumberInline">ig 1.14</span></span><span class="NoBreak">).</span></p>
			<figure id="_idContainer039" class="figFrame">
					<p class="FigureCaption"><span class="FigureNumber"><img src="image/1-14.png" alt="Figure" /><a id="_idTextAnchor008"></a><a id="_idTextAnchor009"></a>Fig 1.14:</span> Our gradient pixel grid with GIF-style lossy compression applied.</p>
				</figure>
			<p class="Body">A <a id="_idIndexMarker026"></a>gradient isn’t a strong use case for GIF, no matter how you look at it. But using JPEG’s method of encoding our blue gradient source image would give us a very simp<span class="NoBreak">le</span><span class="NoBreak"> chroma:</span></p>
			<ul>
				<li class="BodyBulletList">All blocks<span class="NoBreak"> are</span><span class="NoBreak"> blue.</span></li>
			</ul>
			<p class="Body">It would yield a similarly te<span class="NoBreak">rse luma: </span></p>
			<ul>
				<li class="BodyBulletList">All blocks in column one <span class="NoBreak">are</span><span class="NoBreak"> light.</span></li>
				<li class="BodyBulletList">All blocks in column two follow a gradient from ligh<span class="NoBreak">t to</span><span class="NoBreak"> dark.</span></li>
				<li class="BodyBulletList">All blocks in column three<span class="NoBreak"> are</span><span class="NoBreak"> dark.</span></li>
			</ul>
			<p class="Body"><em class="Emphasis">Before</em> we apply any compression, JPEG-style encoding gives us a small transfer for a pixel-perfect representation of our image source—so we know JPEG is the rig<span class="NoBreak">ht</span><span class="NoBreak"> choice.</span></p>
			<p class="Body">Now, imagine this writ much, much larger—for example, with a photograph of the sky (<span class="FigureNumberInline">Fig 1.15</span>). GIF-style encoding barely halves the file size and creates perceptible stripes of blue across the sky (<span class="FigureNumberInline">Fig 1.16</span>). But with JPEG encoding, and a little quantization of the details—something our lossy psychovisual systems might not even recognize—the savings potential is huge (<span class="FigureNumberInline">Fig</span><span class="NoBreak"><span class="FigureNumberInline"> 1.17</span></span><span class="NoBreak">).</span></p>
			<figure id="_idContainer041" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/1-15.png" alt="Figure" /></span></p>
					<figcaption class="FigureCaption"><span class="FigureNumber">Fig 1.15:</span> An uncompressed image of the White Mountains in Vermont, weighing in at 1.54 MB.</figcaption>
				</figure>
			<figure id="_idContainer043" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/1-16.png" alt="Figure" /></span></p>
					<p class="FigureCaption"><span class="FigureNumber">Fig 1.16:</span> Encoded as GIF and using a high level of compression, our file size is reduced to 38 KB, with a marked drop in quality. Notice the streaks across the sky, and the lack of detail in the foreground trees.</p>
				</figure>
			<figure id="_idContainer045" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/1-17.png" alt="Figure" /></span></p>
					<p class="FigureCaption"><span class="FigureNumber">Fig 1.17:</span> With moderate JPEG compression, the reduction in detail isn’t apparent—and the file size is reduced all the way down to 26 KB.</p>
				</figure>
			<p class="Body">Even if we only factored in this one approach to compression, you can see where JPEG is almost invariably the right choice for photographs: the real world is made up of gradients. You can likely also see where it isn’t as well suited to the pixel-perfect use cases for GIF, like sharp text and hard lines—situations where pixel-perfection is necessary, even if it means sacrificing some algorithmic<span class="NoBreak"> e</span><span class="NoBreak">fficiency.</span></p>
			<h4 class="CHead"><a id="_idIndexMarker027"></a>Artifacts</h4>
			<p class="BodyFirstParagraph">We could quite literally spend the remainder of this book going over JPEG alone. It would make for some dry reading, though, and steer us way into academic territory. I’d be remiss, however, if I didn’t take a moment to mention the most infamous side effect of JPEG compression:<span class="NoBreak"> </span><span class="NoBreak">artifacts.</span></p>
			<p class="Body">You may not know them by name, but you almost certainly know them by appearance (<span class="FigureNumberInline">Fig 1.18</span>). JPEG <em class="Emphasis">artifacts</em> result from JPEG compression taken to the extreme. Because JPEG compression samples and applies high-frequency detail-reduction in eight-by-eight pixel squares, we get—in strict technical terms—a blocky, glitchy version of o<span class="NoBreak">ur image.</span></p>
			<figure id="_idContainer047" class="figFrame">
					<figcaption class="FigureCaption"><span class="FigureNumber"><img src="image/1-18.png" alt="Figure" />Fig 1.18:</span> A heavily compressed JPEG. The blurry, blocky, discolored effects are artifacts of the compression process.</figcaption>
				</figure>
			<p class="Body">Determining the ideal level of compression for your images is a finesse game, given the complexity involved in JPEG compression. When we’re compressing images individually, we might be able to trust our gut—and our eyes. But summing up such a complex set of instructions with a single “quality” or “compression” number can be a fraught prospect. When it comes to setting sensible defaults—for example, automatically applying compression to user-uploaded images, the way WordPress does—what might work invisibly for one image <em class="Emphasis">could</em> be noticeable i<span class="NoBreak">n</span><span class="NoBreak"> another.</span></p>
			<p class="Body">There are tools that help remove some of the guesswork from the process—for instance, <a href="http://bkaprt.com/ip/01-04/"><span id="_idIndexMarker028"></span><span class="URL">DSSIM</span></a><span class="URL"> </span>allows us to introduce an intermediary step in our build or upload processes, analyzing each of our images for the optimal balance of perceptual fidelity and file size. That comes at the cost of higher processing overhead—paving the way for hyperoptimized content delivery services like<span class="NoBreak"> </span><a href="https://cloudinary.com/"><span class="NoBreak"><span id="_idIndexMarker029"></span></span><span class="NoBreak"><span class="URL">C</span></span><span class="NoBreak"><span class="URL">loudinary</span></span></a><span class="NoBreak">.</span></p>
			<p class="Body">But don’t let that potential source of overhead discourage you. With a sensible default level of JPEG compression applied to all of our images, you and I might still be able to spot an artifact here and there. We know what we’re looking for, after all, and we’re focused on it—we’re looking for the individual leaves on the tree, so to speak. But most users will just see a tree, with any faint artifacts blending in with the tiny details that their lossy psychovisual systems gl<span class="NoBreak">oss over. </span></p>
			<p class="Body">In fact, odds are you and I won’t notice most of them either, even though we’re wise to the tricks JPEG tries to play on us. For that reason, it’s almost always a safe bet to nudge JPEG compression just a <em class="Emphasis">little</em> lower than you think might be noticeable. You’ll see it when you’re looking for it, there in the JPEG compression options dialog, but when you’re not—when <em class="Emphasis">you’re</em> the user—you’ll likely fall for<span class="NoBreak"> it, too. </span></p>
			<h4 class="CHead"><a id="_idIndexMarker030"></a>Progre<span class="NoBreak">ssive</span><span class="NoBreak"> JPEG</span></h4>
			<p class="BodyFirstParagraph"><em class="Emphasis">Progressive JPEG</em> (PJPEG) effectively parallelizes the process of rendering a JPEG. Rather than the incremental rendering of a baseline JPEG (<span class="FigureNumberInline">Fig 1.19</span>), progressive JPEG breaks rendering into a set of full-sized “scans,” with each scan increasing the quality of the image (<span class="NoBreak"><span class="FigureNumberInline">Fig 1.20</span></span><span class="NoBreak">).</span></p>
			<p class="Body">The benefit is mostly perceptual. By delivering a full-size version of the image right away—albeit a blurry one—instead of empty space, PJPEG can <em class="Emphasis">feel</em> faster to the <span class="NoBreak">end user. </span></p>
			<p class="Body">That said, PJPEG isn’t <em class="Emphasis">strictly</em> a matter of user-facing smoke and mirrors. With the exception of <em class="Emphasis">very</em> small image sources, PJPEG often means a smaller file siz<span class="NoBreak">e as</span><span class="NoBreak"> well.</span></p>
			<p class="Body">Browser support for rendering PJPEG isn’t guaranteed, but it’s very good. Worst-case scenario, the PJPEG renders all at once rather than, well, progressively. You’d lose the perceptual performance gains, but at no user-fa<span class="NoBreak">cing</span><span class="NoBreak"> cost.</span></p>
			<p class="Body">There is one trade-off: decoding PJPEG is more complex than plain ol’ JPEG, and that means putting more strain on the browser—and a device’s hardware—during rendering. That rendering overhead is difficult—<a href="http://bkaprt.com/ip/01-05/"><span class="URL">but not impossible</span></a>—to quantify in exact terms, but suffice to say that it likely won’t be noticeable outside of severely underpowered devices. So, as in countless other web-development matters, I can’t leave you with much more than a hearty “it depends”—but I will say I reach for PJPEG more often than not in my o<span class="NoBreak">wn work.</span></p>
			<figure id="_idContainer049" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/1-19.png" alt="Figure" /></span></p>
					<p class="FigureCaption"><span class="FigureNumber">Fig 1.19:</span> A baseline JPEG loads in gradually. </p>
				</figure>
			<figure id="_idContainer051" class="figFrame">
					<p class="figHolder"><span class="FigureNumber"><img src="image/1-20.png" alt="Figure" /></span></p>
					<figcaption class="FigureCaption"><span class="FigureNumber">Fig 1.20:</span> In modern browsers, PJPEG renders a low-quality version of an image first, then makes multiple passes at sharpening it.</figcaption>
				</figure>
			<h2 class="AHead">Formats of the Future</h2>
			<p class="BodyFirstParagraph">Given that JPEG approaches compression in a handful of algorithmically intensive ways, you can probably see where there’s nearly endless potential for improvement. The humble JPEG has given way to a number of slight variations, all of which aim to improve both image quality and transfer size by tweaking encoding and compressio<span class="NoBreak">n</span><span class="NoBreak"> methods.</span></p>
			<p class="Body">Once we start tinkering with encoding, however, there be dragons: even though some of these formats share the JPEG name, they’re as fundamentally dissimilar as Java is to JavaScript. In order for those files to render, the browser has to be able to “speak” that new encoding. If we’re not careful about how they’re used, we run the risk of serving users an image file their browser can’<span class="NoBreak">t render. </span></p>
			<p class="Body">Some formats, like JPEG 2000—currently only supported in Safari—are intended to fulfill all of the same use cases as a baseline JPEG, but improve on the standard compression methods to deliver a visually similar but much smaller image. Other formats, like <a href="http://flif.info/"><span class="URL">FLIF</span></a>—not yet supported in any browser—aim to provide more efficient solutions to GIF-like animation and PNG-like<span class="NoBreak"> tra</span><span class="NoBreak">nsparency.</span></p>
			<p class="Body"><a id="_idIndexMarker031"></a>WebP is one of the more exciting formats, thanks in part to the level of interest it’s seeing from browsers. This smaller, better-featured version of JPEG is currently only supported in Chrome and Opera, but Safari, Firefox, and Edge have all started experimenting with it as well—and, thanks to the responsive image patterns we’ll discuss in the next chapter, we can use it responsibly r<span class="NoBreak">ight</span><span class="NoBreak"> away.</span></p>
		</div>
	</body>
</html>
