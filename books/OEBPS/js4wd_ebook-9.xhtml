<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
	<head>
		<title>js4wd_ebook-9</title>
		<link href="css/ABA.css" rel="stylesheet" type="text/css" />
	</head>
	<body id="js4wd_ebook-9" lang="en-US" xml:lang="en-US">
		<div id="_idContainer080">
			<h1 id="_idParaDest-6" class="chTitle"><a id="_idTextAnchor006"></a>Chapter 5. DOM<span class="NoBreak"> Scripting</span></h1>
			
				<div id="_idContainer064" class="ch_open_img _idGenObjectStyle-Disabled">
					<img src="image/9.png" alt="" />
				</div>
			
			<p class="BodyFirstParagraph"><span class="ChapterIntro">BEFORE WE CAN DO ANYTHING</span> with a page, we have to first revisit something we touched on near the start: the Document Object Model. There are two purposes to the <a id="_idIndexMarker118"></a>DOM: providing JavaScript with a map of all the elements on our page, and providing us with a set of methods for accessing those elements, their attributes, and their<span class="NoBreak"> contents.</span></p>
			<p class="Body">The “object” part of Document Object Model should make a lot more sense now than it did the first time the DOM came up, though: the DOM is a representation of a web page in the form of an object, made up of properties that represent each of the document’s child elements and subproperties representing each of those elements’ child elements, and so on. It’s objects all the way<span class="NoBreak"> down.</span></p>
			<h2 class="AHead"><span class="aHeadCode">window</span>: THE GLOBAL CONTEXT</h2>
			<p class="BodyFirstParagraph">Everything we do with JavaScript falls within the scope of a single object: <a id="_idIndexMarker119"></a><code class="CodeInline">window</code>. The <code class="CodeInline">window</code> object represents, predictably enough, the entire browser window. It contains the entire DOM, as well as—and this is the tricky part—the whole of<span class="NoBreak"> JavaScript.</span></p>
			<p class="Body">When we first talked about variable scope, we touched on the concept of there being “global” and “local” scopes, meaning that a variable could be made available either to every part of our scripts or to their enclosing function<span class="NoBreak"> alone.</span></p>
			<p class="Body">The <code class="CodeInline">window</code> object <em class="Emphasis">is</em> that global scope. All of the functions and methods built into JavaScript are built off of the <code class="CodeInline">window</code> object. We don’t have to reference <code class="CodeInline">window</code> constantly, of course, or you would’ve seen a lot of it before now—since <code class="CodeInline">window</code> is the global scope, JavaScript checks <code class="CodeInline">window</code> for any variables we haven’t defined ourselves. In fact, the <code class="CodeInline">console</code> object that you’ve hopefully come to know and love is a method of the <code class="CodeInline">window</code><span class="NoBreak"> object:</span></p>
			<pre class="Code">window.console.log</pre>
			<pre class="Code"><span class="CodeConsole">function </span><span class="CodeConsole">log() { [native code] }</span></pre>
			<p class="Body">It’s hard to visualize globally vs. locally scoped variables before knowing about <code class="CodeInline">window</code>, but much easier after: when we introduce a variable to the global scope, we’re making it a property of <code class="CodeInline">window</code>—and since we don’t explicitly have to reference <code class="CodeInline">window</code> whenever we’re accessing one of its properties or methods, we can call that variable anywhere in our scripts by just using its identifier. When we access an identifier, what we’re really doing is<span class="NoBreak"> this:</span></p>
			<pre class="Code">function ourFunction() {</pre>
			<pre class="Code">  var localVar = &quot;I’m local.&quot;;</pre>
			<pre class="Code">  globalVar = &quot;I’m global.&quot;;</pre>
			<pre class="Code">  return &quot;I’m global too!&quot;;</pre>
			<pre class="Code">};</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">window.ourFunction();</pre>
			<pre class="Code"><span class="CodeConsole">I’m global too!</span></pre>
			<pre class="Code">window.localVar;</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">window.globalVar;</pre>
			<pre class="Code"><span class="CodeConsole">I’m global.</span></pre>
			<p class="Body">The DOM’s entire representation of the page is a property of <code class="CodeInline">window</code>: specifically, <code class="CodeInline">window.document</code>. Just<span class="NoBreak"> entering </span> <code class="CodeInline">window.document</code> in your developer console will return all of the markup on the current page in one enormous string, which isn’t particularly useful—but everything on the page can be accessed as subproperties of <code class="CodeInline">window.document</code> the exact same way. Remember that we don’t need to specify <code class="CodeInline">window</code> in order to access its <code class="CodeInline">document</code> property—<code class="CodeInline">window</code> is the only game in town, after<span class="NoBreak"> all.</span></p>
			<pre class="Code">document.head</pre>
			<pre class="Code"><span class="CodeConsole">&lt;head&gt;...&lt;/head&gt;</span></pre>
			<pre class="Code">document.body</pre>
			<pre class="Code"><span class="CodeConsole">&lt;body&gt;...&lt;/body&gt;</span></pre>
			<p class="Body">Those two properties are themselves objects that contain properties that are objects, and so on down the chain. (“Everything is an object, kinda.”)</p>
			<h2 class="AHead">USING THE DOM</h2>
			<p class="BodyFirstParagraph">The objects in <code class="CodeInline">window.document</code> make up JavaScript’s map of the document, but it isn’t terribly useful for us—at least, not when we’re trying to access DOM nodes the way we’d access any other object. Winding our way through<span class="NoBreak"> the </span> <code class="CodeInline">document</code> object manually would be a huge headache for us, and that means our scripts would completely fall apart as soon as any markup<span class="NoBreak"> changed.</span></p>
			<p class="Body">But <code class="CodeInline">window.document</code> isn&apos;t just a representation of the page; it also provides us with a smarter API for accessing that information. For instance, if we want to find every <code class="CodeInline">p</code> element on a page, we don’t have to write out a string of property keys—we use a helper method built into <code class="CodeInline">document</code> that gathers them all into an array-like list for us. Open up any site you want—so long as it likely has a paragraph element or two in it—and try this out in your<span class="NoBreak"> console:</span></p>
			<pre class="Code">document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code"><span class="CodeConsole">[&lt;p&gt;...&lt;/p&gt;, &lt;p</span><span class="CodeConsole">&gt;...&lt;/p&gt;, &lt;p&gt;...&lt;/p&gt;, &lt;p&gt;...&lt;/p&gt;]</span></pre>
			<p class="Body">Since we’re dealing with such familiar data types, we already have some idea how to work with<span class="NoBreak"> them:</span></p>
			<pre class="Code">var paragraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<pre class="Code">paragraphs.length</pre>
			<pre class="Code"><span class="CodeConsole">4</span></pre>
			<pre class="Code">paragraphs[ 0 ];</pre>
			<pre class="Code"><span class="CodeConsole">&lt;p&gt;...&lt;/p&gt;</span></pre>
			<p class="Body">But DOM methods don’t give us arrays, strictly speaking. Methods like <code class="CodeInline">getElementsByTagName</code> return “<a id="_idIndexMarker120"></a>node lists,” which behave a lot like arrays. Each item in a <code class="CodeInline">nodeList</code> refers to an individual node in the DOM—like a <code class="CodeInline">p</code> or a <code class="CodeInline">div</code>—and will come with a number of DOM-specific methods built in. For example, the <code class="CodeInline">innerHTML</code> method will return any markup a node contains—elements, text, and so on—as a<span class="NoBreak"> string:</span></p>
			<pre class="Code">var paragraphs = document.getElementsByTagName( &quot;p&quot; ),lastIndex = paragraphs.length - 1, <span class="CodeComment">/* Use the length of the `paragraphs` node list</span><span class="CodeComment"> minus 1 (because of zero-indexing) to get the last</span><span class="CodeComment"> paragraph on the page */</span></pre>
			<pre class="Code">  lastParagraph = paragraphs[ lastIndex ]; </pre>
			<pre class="Code">lastParagraph.innerHTML;</pre>
			<pre class="Code"><span class="CodeConsole">And</span><span class="CodeConsole"> that’s how I spent my summer vacation.</span></pre>
			<p class="Body">The same way these methods give us access to information on the rendered page, they allow us to <em class="Emphasis">alter</em> that information, as well. For example, the <code class="CodeInline">innerHTML</code> method does this the same way we’d change the value of any other object: a single equals sign, followed by the new<span class="NoBreak"> value.</span></p>
			<pre class="Code">var paragraphs = document.getElementsByTagName( &quot;p&quot; ),</pre>
			<pre class="Code">  firstParagraph = paragraphs[ 0 ];</pre>
			<pre class="Code">firstParagraph.innerHTML = &quot;Listen up, chumps:&quot;;</pre>
			<pre class="Code"><span class="CodeConsole">&quot;Listen up, chumps:&quot;</span></pre>
			<p class="Body">JavaScript’s map of the DOM works both ways: <code class="CodeInline">document</code> is updated whenever any markup changes, and our markup is updated whenever anything within <code class="CodeInline">document</code> changes (<span class="FigureNumberInline">FIG 5.1</span>).</p>
			<p class="Body">Likewise, the <a id="_idIndexMarker121"></a>DOM API gives us a number of methods for creating, adding, and removing elements. They’re all more or less spelled out in plain English, so even though things can seem a little verbose, it isn’t too hard to break down.</p>
			
				<div id="_idContainer067" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer065" class="figure">
						<img src="image/Fig_5.1.png" alt="Figure" />
					</div>
					<div id="_idContainer066" class="figure">
						<p class="FigureCaption"><span class="FigureNumber"><span class="FigureNumber">FIG 5.1</span></span><span class="FigureNumber">:</span> First drafts are always tough. </p>
					</div>
				</div>
			
			<h2 class="AHead"><a id="_idIndexMarker122"></a>DOM SCRIPTING</h2>
			<p class="BodyFirstParagraph">Before we get started, let’s abandon our developer console for a bit. Ages ago now, we walked through setting up a bare-bones HTML template that pulls in a remote script, and we’re going to revisit that setup now. Between the knowledge you’ve gained about JavaScript so far and an introduction to the DOM, we’re done with just telling our console to parrot things back to us—it’s time to build<span class="NoBreak"> something.</span></p>
			<p class="Body">We’re going to add a “cut” to an index page full of text—a teaser paragraph followed by a link to reveal the full text. We’re not going to make the user navigate to another page, though. Instead, we’ll use JavaScript to show the full text on the same<span class="NoBreak"> </span><span class="NoBreak">page.</span></p>
			<p class="Body">Let’s start by setting up an HTML document that links out to an external stylesheet and external script file—nothing fancy. Both our <a id="_idIndexMarker123"></a>stylesheet and script files are empty with <span class="digName">.css</span> and <span class="digName">.js</span> extensions, for now—I like to keep my CSS in a <span class="digName">/css</span> subdirectory and my JavaScript in a <span class="digName">/js</span> subdirectory, but do whatever makes you most<span class="NoBreak"> comfortable.</span></p>
			<pre class="Code">&lt;!DOCTYPE html&gt;</pre>
			<pre class="Code">&lt;html&gt;</pre>
			<pre class="Code">  &lt;head&gt;</pre>
			<pre class="Code">    &lt;meta charset=&quot;utf-8&quot;&gt;</pre>
			<pre class="Code">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;     href=&quot;css/style.css&quot;&gt;</pre>
			<pre class="Code">  &lt;/head&gt;</pre>
			<pre class="Code">  &lt;body&gt;</pre>
			<pre class="Code">    &lt;script src=&quot;js/script.js&quot;&gt;&lt;/script&gt;</pre>
			<pre class="Code">  &lt;/body&gt;</pre>
			<pre class="Code">&lt;/html&gt;</pre>
			<p class="Body">We’re going to populate that page with several paragraphs of text. Any ol’ text you can find laying around will do, including—with apologies to the content strategists in the audience—a little old-fashioned lorem ipsum. We’re just mocking up a quick article page, like a blog<span class="NoBreak"> post.</span></p>
			<pre class="Code">&lt;!DOCTYPE html&gt;</pre>
			<pre class="Code">&lt;html&gt;</pre>
			<pre class="Code">  &lt;head&gt;</pre>
			<pre class="Code">    &lt;meta charset=&quot;utf-8&quot;&gt;</pre>
			<pre class="Code">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;     href=&quot;css/style.css&quot;&gt;</pre>
			<pre class="Code">  &lt;/head&gt;</pre>
			<pre class="Code">  &lt;body&gt;</pre>
			<pre class="Code">    &lt;h1&gt;JavaScript for Web Designers&lt;/h1&gt;</pre>
			<pre class="Code">    &lt;p&gt;In all fairness, I should start this book     with an apology—not to you, reader, though I     don’t doubt that I’ll owe you at least one by     the time we get to the end. I owe JavaScript a     number of apologies for the things I’ve said     to it during the early years of my career,     some of which were strong enough to etch     glass.&lt;/p&gt;</pre>
			<pre class="Code">    &lt;p&gt;This is my not-so-subtle way of saying that     JavaScript can be a tricky thing to learn.&lt;/p&gt;</pre>
			<pre class="Code">    [ … ]</pre>
			<pre class="Code">    &lt;script src=&quot;js/script.js&quot;&gt;&lt;/script&gt;</pre>
			<pre class="Code">  &lt;/body&gt;</pre>
			<pre class="Code">&lt;/html&gt;</pre>
			<p class="Body">Feel free to open up the stylesheet and play with the typography, but don’t get too distracted. We’ll need to write a little CSS later, but for now: we’ve got scripting to<span class="NoBreak"> do.</span></p>
			<p class="Body">We can break this script down into a few discrete tasks: we need to add a Read More link to the first paragraph, we need to hide all the <code class="CodeInline">p</code> elements apart from the first one, and we need to reveal those hidden elements when the user interacts with the Read More<span class="NoBreak"> link.</span></p>
			<p class="Body">We’ll start by adding that Read More link to the end of the first paragraph. Open up your still-empty <span class="digName">script.js</span> file and enter the<span class="NoBreak"> following:</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<p class="Body">First, we’re intializing the variable <code class="CodeInline">newLink</code>, which uses <code class="CodeInline">document.createElement( &quot;a&quot; )</code> to—just like it says on the tin—create a new <code class="CodeInline">a</code> element. This element doesn’t really exist anywhere yet—to get it to appear on the page we’ll need to add it manually. First, though, <code class="CodeInline">&lt;a&gt;&lt;/a&gt;</code> without any attributes or contents isn’t very useful. Before adding it to the page, let’s populate it with whatever information it<span class="NoBreak"> </span><span class="NoBreak">needs.</span></p>
			<p class="Body">We could do this <em class="Emphasis">after</em> adding the link to the DOM, of course, but there’s no sense in making multiple updates to the element on the page instead of one update that adds the final result—doing all the work on that element before dropping it into the page helps keep our code<span class="NoBreak"> predictable.</span></p>
			<p class="Body">Making a single trip to the DOM whenever possible is also better for performance—but performance micro-optimization is easy to obsess over. As you’ve seen, JavaScript frequently offers us multiple ways to do the same thing, and one of those methods may <em class="Emphasis">technically</em> outperform the other. This invariably leads to “excessively clever” code—convoluted loops that require in-person explanations to make any sense at all, just for the sake of shaving off precious picoseconds of load time. I’ve done it; I still catch myself doing it; but you should try not to. So while making as few round-trips to the DOM as possible is a good habit to be in for the sake of performance, the main reason is that it keeps our code readable and predictable. By only making trips to the DOM when we really need to, we avoid repeating ourselves and we make our interaction points with the DOM more obvious for future maintainers of our<span class="NoBreak"> scripts.</span></p>
			<p class="Body">So. Back to our empty, attribute-less <code class="CodeInline">&lt;</code><code class="CodeInline">a&gt;&lt;/a&gt;</code> floating in the JavaScript ether, totally independent of our<span class="NoBreak"> document.</span></p>
			<p class="Body">Now we can use two other DOM interfaces to make that link more useful: <code class="CodeInline">setAttribute</code> to give it attributes, and <code class="CodeInline">innerHTML</code> to populate it with text. These have a slightly different syntax. We can just assign a string using <code class="CodeInline">innerHTML</code>, the way we’d assign a value to any other object. <code class="CodeInline">setAttribute</code>, on the other hand, expects two arguments: the attribute <em class="Emphasis">and</em> the value we want for that attribute, in that order. Since we don’t actually plan to have this link go anywhere, we’ll just set a hash as the <code class="CodeInline">href</code>—a link to the page you’re already<span class="NoBreak"> on.</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code"><em class="CodeEmphasis">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</em></pre>
			<pre class="Code"><em class="CodeEmphasis">newLink.innerHTML = &quot;Read more&quot;;</em></pre>
			<p class="Body">You’ll notice we’re using these interfaces on our stored reference to the element instead of on <code class="CodeInline">document</code> itself. <em class="Emphasis">All</em> the DOM’s nodes have access to methods like the ones we’re using here—we only use <code class="CodeInline">document.getElementsByTagName( &quot;p&quot; )</code> because we want to get all the paragraph<span class="NoBreak"> elements </span> in the document. If we only wanted to get all the paragraph elements inside a certain <code class="CodeInline">div</code>, we could do the same thing with a reference to that <code class="CodeInline">div</code>—something<span class="NoBreak"> like</span><span class="NoBreak"> </span> <code class="CodeInline">ourSpecificDiv.getElementsByTagName( &quot;p&quot; );</code>. And since we’ll want to set the <code class="CodeInline">href</code> attribute and the inner HTML of the link we’ve created, we reference these properties using <code class="CodeInline">newLink.</code><code class="CodeInline">setAttribute</code> and <code class="CodeInline">newLink.innerHTML</code>.</p>
			<p class="Body">Next: we want this link to come at the end of our first paragraph, so our script will need a way to reference that first paragraph. We already know that <code class="CodeInline">document.getElementsByTagName( &quot;p&quot; )</code> gives us a node list of all the paragraphs in the page. Since node lists behave like arrays, we can reference the first item in the node list one by using the index<span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">0</code></span><span class="NoBreak">.</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code"><em class="CodeEmphasis">var allParagraphs = document</em><em class="CodeEmphasis">.getElementsByTagName( &quot;p&quot; );</em></pre>
			<pre class="Code"><em class="CodeEmphasis">var firstParagraph = allParagraphs[ 0 ];</em></pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<p class="Body">For the sake of keeping our code readable, it’s a good idea to initialize our variables up at the top of a script—even if only by initializing them as <code class="CodeInline">undefined</code> (by giving them an identifier but no value)—if we plan to assign them a value later on. This way we know all the identifiers in<span class="NoBreak"> play.</span></p>
			<p class="Body">So now we have everything we need in order to append a link to the end of the first paragraph: the element that we want to append (<code class="CodeInline">newLink</code>) and the element we want to append it to (<code class="CodeInline">firstParagraph</code>). </p>
			<p class="Body">One of the built-in methods on all DOM nodes<span class="NoBreak"> is </span> <code class="CodeInline">appendChild</code>, which—as the name implies—allows us to append a child element to that DOM node. We’ll call that <code class="CodeInline">appendChild</code> method on our saved reference to the first paragraph in the document, passing it <code class="CodeInline">newLink</code> as an<span class="NoBreak"> argument.</span> </p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code"><em class="CodeEmphasis">firstParagraph.appendChild( newLink );</em></pre>
			<p class="Body">Now—finally—we have something we can point at when we reload the page. If everything has gone according to plan, you’ll now have a Read More link at the end of the first paragraph on the page. If everything hasn’t gone according to plan—because of a misplaced semicolon or mismatched parentheses, for example—your developer console will give you a heads-up that something has gone wrong, so be sure to keep it<span class="NoBreak"> open.</span></p>
			<p class="Body">Pretty close, but a little janky-looking—our link is crashing into the paragraph above it, since that link is <code class="CodeInline">display: inline</code> by default (<span class="FigureNumberInline">FIG 5.2</span>).</p>
			<p class="Body">We have a couple of options for dealing with this: I won’t get into all the various syntaxes here, but the DOM also gives us access to <em class="Emphasis">styling</em> information about elements—though, in its most basic form, it will only allow us to read and change styling information associated with a <code class="CodeInline">style</code> attribute. Just to get a feel for how that works, let’s change the link<span class="NoBreak"> to </span> <code class="CodeInline">display</code><code class="CodeInline">: inline-block</code> and add a few pixels of margin to the left side, so it isn’t colliding with our text. Just like setting attributes, we’ll do this before we add the link to the<span class="NoBreak"> page:</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code"><em class="CodeEmphasis">newLink.</em><em class="CodeEmphasis">style.display = &quot;inline-block&quot;;</em></pre>
			<pre class="Code"><em class="CodeEmphasis">newLink.style.marginLeft = &quot;10px&quot;;</em></pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">Well, adding those lines <em class="Emphasis">worked</em>, but not without a couple of catches. First, let’s talk about that syntax (<span class="FigureNumberInline">FIG 5.3</span>).</p>
			
				<div id="_idContainer070" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer068" class="figure">
						<img src="image/Fig_5.2.png" alt="Figure" />
					</div>
					<div id="_idContainer069" class="figure">
						<p class="FigureCaption"><span class="FigureNumber"><span class="FigureNumber">FIG 5.2</span></span><span class="FigureNumber">:</span> Well, it’s a<span class="NoBreak"> start.</span></p>
					</div>
				</div>
			
			
				<div id="_idContainer073" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer071" class="figure">
						<img src="image/Fig_5.3.png" alt="Figure" />
					</div>
					<div id="_idContainer072" class="figure">
						<p class="FigureCaption"><span class="FigureNumber"><span class="FigureNumber">FIG 5.3</span></span><span class="FigureNumber">:</span> Now we’re<span class="NoBreak"> talking.</span></p>
					</div>
				</div>
			
			<p class="Body">Remember that <a id="_idIndexMarker124"></a>identifiers can’t contain hyphens, and since everything is an object (sort of), the DOM references styles in object format as well. Any CSS property that contains a hyphen instead gets camel-cased: <code class="CodeInline">margin-left</code> becomes <code class="CodeInline">marginLeft</code>, <code class="CodeInline">border</code><code class="CodeInline">-radius-top-left</code> becomes <code class="CodeInline">borderRadiusTopLeft</code>, and so on. Since the <em class="Emphasis">value</em> we set for those properties is a string, however, hyphens are just fine. A little awkward and one more thing to remember, but this is manageable enough—certainly no reason to avoid styling in JavaScript, if the situation makes it absolutely<span class="NoBreak"> necessary.</span></p>
			<p class="Body">A better reason to avoid styling in JavaScript is to maintain a separation of behavior and presentation. JavaScript is our “behavioral” layer the way CSS is our “presentational” layer, and seldom the twain should meet. Changing styles on a page shouldn’t mean rooting through line after line of functions and variables, the same way we wouldn’t want to bury styles in our markup. The people who might end up maintaining the styles for the site may not be completely comfortable editing JavaScript—and since changing styles in JavaScript means we’re indirectly adding styles via <code class="CodeInline">style</code> attributes, whatever we write in a script is going to override the contents of a stylesheet by<span class="NoBreak"> default.</span></p>
			<p class="Body">We can maintain that separation of concerns by instead using <code class="CodeInline">setAttribute</code> again to give our link a class. So, let’s scratch out those two styling lines and add one setting a class in their<span class="NoBreak"> place.</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code"><em class="CodeEmphasis">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</em></pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">Now we can style <code class="CodeInline">.more-link</code> in our stylesheets as<span class="NoBreak"> usual:</span></p>
			<pre class="Code">.more-link {</pre>
			<pre class="Code">  display: inline-block;</pre>
			<pre class="Code">  margin-left: 10px;</pre>
			<pre class="Code">}</pre>
			<p class="Body">Much better (<span class="FigureNumberInline">FIG 5.4</span>). It’s worth keeping in mind for the future that using <code class="CodeInline">setAttribute</code> this way on a node in the DOM would mean overwriting any classes already on the element, but that’s not a concern where we’re putting this element together from scratch. </p>
			
				<div id="_idContainer076" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer074" class="figure">
						<img src="image/Fig_5.3.png" alt="Figure" />
					</div>
					<div id="_idContainer075" class="figure">
						<p class="FigureCaption"><span class="FigureNumber"><span class="FigureNumber">FIG 5.4</span></span><span class="FigureNumber">:</span> No visible changes, but this change keeps our styling decisions in our CSS and our behavioral decisions in<span class="NoBreak"> JavaScript.</span></p>
					</div>
				</div>
			
			<p class="Body">Now we’re ready to move on to the second item on our to-do list: hiding all the other<span class="NoBreak"> paragraphs.</span></p>
			<p class="Body">Since we’ve made changes to code we know already worked, be sure to reload the page to make sure everything is still working as expected. We don’t want to introduce a bug here and continue on writing code, or we’ll eventually get stuck digging back through all the changes we made. If everything has gone according to plan, the page should look the same when we reload it<span class="NoBreak"> now.</span></p>
			<p class="Body">Now we have a list of all the paragraphs on the page, and we need to act on each of them. We need a loop—and since we’re iterating over an array-like <a id="_idIndexMarker125"></a>node list, we need a <code class="CodeInline">for</code> loop. Just to make sure we have our loop in order, we’ll log each paragraph to the console before we go any<span class="NoBreak"> further:</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">  console.log( allParagraphs[ i ] );</pre>
			<pre class="Code">}</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">Your Read More link should still be kicking around in the first paragraph as usual, and your console should be rich with filler text (<span class="FigureNumberInline">FIG 5.5</span>).</p>
			
				<div id="_idContainer079" class="figure _idGenObjectStyle-Disabled">
					<div id="_idContainer077" class="figure">
						<img src="image/Fig_5.5.png" alt="Figure" />
					</div>
					<div id="_idContainer078" class="figure">
						<p class="FigureCaption"><span class="FigureNumber"><span class="FigureNumber">FIG 5.5</span></span><span class="FigureNumber">:</span> Looks like our loop is doing what we<span class="NoBreak"> expect.</span></p>
					</div>
				</div>
			
			<p class="Body">Now we have to hide those paragraphs with <code class="CodeInline">display: none</code>, and we have a couple of options: we could use a class the way we did before, but it wouldn’t be a terrible idea to use styles in JavaScript for this. We’re controlling all the hiding and showing from our script, and there’s no chance we’ll want that behavior to be overridden by something in a stylesheet. In this case, it makes sense to use the DOM’s built-in methods for applying<span class="NoBreak"> styles:</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">  <em class="CodeEmphasis">allParagraphs[ i ].style</em><em class="CodeEmphasis">.display = &quot;none&quot;;</em></pre>
			<pre class="Code">}</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">If we reload the page now, everything is gone: our JavaScript <a id="_idIndexMarker126"></a>loops through the entire list of paragraphs and hides them all. We need to make an exception for the first paragraph, and that means conditional logic—an <code class="CodeInline">if</code> statement, and the <code class="CodeInline">i</code> variable gives us an easy value to check<span class="NoBreak"> against:</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code"><em class="CodeEmphasis">  if( i === 0 ) {</em></pre>
			<pre class="Code"><em class="CodeEmphasis">    continue;</em></pre>
			<pre class="Code">  }</pre>
			<pre class="Code">  allParagraphs[ i ].style.display = &quot;none&quot;;</pre>
			<pre class="Code">}</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">If this is the first time through of the loop, the <a id="_idIndexMarker127"></a><code class="CodeInline">continue</code> keyword skips the rest of the current iteration and then—unlike if we’d used <a id="_idIndexMarker128"></a><code class="CodeInline">break</code>—the loop continues on to the next<span class="NoBreak"> iteration.</span></p>
			<p class="Body">If you reload the page now, we’ll have a single paragraph with a Read More link at the end, but all the others will be hidden. Things are looking good so far—and if things aren’t looking quite so good for you, double-check your console to make sure nothing is<span class="NoBreak"> amiss.</span></p>
			<h2 class="AHead"><a id="_idIndexMarker129"></a>DOM EVENTS</h2>
			<p class="BodyFirstParagraph">Okay, one last thing to do: we need our Read More link to <em class="Emphasis">do</em> something. If you click on it now, it just jumps you back to the top of the page and adds a hash to the<span class="NoBreak"> URL.</span></p>
			<p class="Body">In terms of failure-proofing, we’re in a pretty safe situation with this script. No matter what kinds of mishaps might take place down the road—an error in one of our scripts, an error in a third-party script that we can’t control, or even an error in a user’s browser—the full text will be<span class="NoBreak"> </span><span class="NoBreak">available.</span></p>
			<p class="Body">We’re inserting the View More link with JavaScript instead of hard-coding it into the markup, so if JavaScript is unavailable to a user for any reason, there&#160;won’t be a useless link floating at the end of the first paragraph. We’re also relying on JavaScript to add the class that hides the other paragraphs, rather than hard-coding a class and hiding them through our stylesheets—because then, if a script should break, the content is still available to the<span class="NoBreak"> user.</span></p>
			<p class="Body">The idea of starting with something usable and layering JavaScript enhancements over that baseline is called <a id="_idIndexMarker130"></a><em class="Emphasis">progressive enhancement</em>, and we’ll talk more about that in a bit. Right now, we have a script to<span class="NoBreak"> finish.</span></p>
			<p class="Body">DOM events are effectively an API for the activity taking place in a browser. This includes the user’s actions, CSS animations, and internal browser events like the point where an image is completely loaded, just to name a<span class="NoBreak"> few.</span></p>
			<p class="Body">We’re squarely in user event territory—we just need to be able to write some behavior for users who click our generated link. We don’t need to make a second trip to the DOM, or root through every link on the page—we already have a reference to our link, and we’ll use a built-in DOM method to listen for events:<span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">addEventListener</code></span><span class="NoBreak">.</span></p>
			<p class="Body">So, let’s start by writing our function: when the link is clicked, what do we want to<span class="NoBreak"> happen?</span></p>
			<p class="Body">Well, first we want to show all the hidden paragraphs on the page, so we’ll need to change their styles back<span class="NoBreak"> to </span> <code class="CodeInline">display: block</code>. Once we’ve shown all those paragraphs, a Read More link won’t make sense to the user—so after we show the full text, we’ll want remove that link from the<span class="NoBreak"> DOM.</span></p>
			<p class="Body">We’ll create a new function with the<span class="NoBreak"> identifier </span> <code class="CodeInline">revealCopy</code>, and for now we’ll just put a <code class="CodeInline">console.log</code> in that function so we know everything is working. Then we’ll<span class="NoBreak"> use </span> <code class="CodeInline">addEventListener</code> on <code class="CodeInline">newLink</code> to listen for a click event. <code class="CodeInline">addEventListener</code> accepts two arguments: a string with the event type we want to listen for—in this case <code class="CodeInline">&quot;</code><code class="CodeInline">click&quot;</code>—and the function to be executed when that event takes<span class="NoBreak"> place.</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code"><em class="CodeEmphasis">function revealCopy() {</em></pre>
			<pre class="Code"><em class="CodeEmphasis">  console.</em><em class="CodeEmphasis">log( &quot;Clicked!&quot; );</em></pre>
			<pre class="Code"><em class="CodeEmphasis">}</em></pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code"><em class="CodeEmphasis">newLink.addEventListener( &quot;click&quot;, revealCopy );</em></pre>
			<pre class="Code">for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">  if( i === 0 ) {</pre>
			<pre class="Code">    continue;</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">  allParagraphs[ i ].style.display = &quot;none&quot;;</pre>
			<pre class="Code">}</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">So far, so good! Click on our generated link and you’ll get a <code class="CodeInline">Clicked!</code> in your<span class="NoBreak"> console.</span></p>
			<p class="Body">The browser is still following that link, though. That isn’t really a big deal now—since we’re setting that link’s <code class="CodeInline">href</code> to a hash—but there might be times where we’re adding custom behaviors to real links, and we don’t want the browser jumping the user to a new page instead of showing any of our<span class="NoBreak"> behavior</span><span class="NoBreak">.</span></p>
			<p class="Body">Luckily, <code class="CodeInline">addEventListener</code> gives us information about the user’s click event in the form of—you guessed it—an object. And just as you might expect, that object contains a number of properties <em class="Emphasis">about</em> the event, and methods we can use to control the browser’s behavior. That event object is passed along as an argument, but we can’t use it until we give it an identifier—the common convention is <code class="CodeInline">e</code>, short for “event.” Let’s add that as an argument, and change our <code class="CodeInline">console.log</code> to show us that<span class="NoBreak"> object:</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">function revealCopy( e ) {</pre>
			<pre class="Code"><em class="CodeEmphasis">  console.log( e );</em></pre>
			<pre class="Code">}</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">newLink.addEventListener( &quot;click&quot;, revealCopy );</pre>
			<pre class="Code">for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">  if( i === 0 ) {</pre>
			<pre class="Code">    continue;</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">  allParagraphs[ i ].style.display = &quot;none&quot;;</pre>
			<pre class="Code">}</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">Now we’ll get a cryptic looking object in our console when we click on that generated<span class="NoBreak"> link:</span></p>
			<pre class="Code"><span class="CodeConsole">MouseEvent {dataTransfer: null, which: 1, toElement: a.more-link, fromElement</span><span class="CodeConsole">: null, y: 467…}</span></pre>
			<p class="Body">There’s a lot going on in there, but we’re only going to need one method from that event object: <code class="CodeInline">e.preventDefault()</code>, which prevents the browser’s default behavior when an event takes place—in this case, following a link. That function can appear <em class="Emphasis">anywhere</em> in the function that’s bound to an event—as long as it exists in <code class="CodeInline">revealCopy</code> somewhere, the browser won’t attempt to follow our<span class="NoBreak"> link.</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">function revealCopy( e ) {</pre>
			<pre class="Code"><em class="CodeEmphasis">  e.preventDefault();</em></pre>
			<pre class="Code">};</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">newLink.addEventListener( &quot;click&quot;, revealCopy );</pre>
			<pre class="Code">for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">  if( i === 0 ) {</pre>
			<pre class="Code">    continue;</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">  allParagraphs[ i ].style.display = &quot;none&quot;;</pre>
			<pre class="Code">}</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">Now the hash in the link’s <code class="CodeInline">href</code> will be ignored completely. Even if we were to change <code class="CodeInline">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; )</code> to point to a real URL, clicking on the link wouldn’t take you anywhere. Perfect—now we just need our function to…y’know, do<span class="NoBreak"> things.</span></p>
			<p class="Body">Since we’ll need to change the <code class="CodeInline">display</code> property of each hidden paragraph back to a visible <code class="CodeInline">display</code> value—like <code class="CodeInline">block</code>—we’ll need to loop through them again. For now, we can just copy and paste our <code class="CodeInline">allParagraphs</code> variable and corresponding loop into the function, and change the <code class="CodeInline">display</code> value to <code class="CodeInline">&quot;block&quot;</code>.</p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">function revealCopy( e ) {</pre>
			<pre class="Code"><em class="CodeEmphasis">  var allParagraphs = document</em><em class="CodeEmphasis">.getElementsByTagName(   &quot;p&quot; );</em></pre>
			<pre class="Code"><em class="CodeEmphasis">  for( var i = 0; i &lt; allParagraphs.length; i</em><em class="CodeEmphasis">++ ) {</em></pre>
			<pre class="Code"><em class="CodeEmphasis">    if( i === 0 ) {</em></pre>
			<pre class="Code"><em class="CodeEmphasis">      continue;</em></pre>
			<pre class="Code"><em class="CodeEmphasis">    }</em></pre>
			<pre class="Code"><em class="CodeEmphasis">    allParagraphs[ i ].style.display = &quot;block&quot;;</em></pre>
			<pre class="Code"><em class="CodeEmphasis">  }</em></pre>
			<pre class="Code"><em class="CodeEmphasis">  e</em><em class="CodeEmphasis">.preventDefault();</em></pre>
			<pre class="Code">}</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">newLink.addEventListener( &quot;click&quot;, revealCopy );</pre>
			<pre class="Code">for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">  if( i === 0 ) {</pre>
			<pre class="Code">    continue;</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">  allParagraphs[ i ].style.display = &quot;none&quot;;</pre>
			<pre class="Code">}</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">Copying and pasting code that way isn’t very <a id="_idIndexMarker131"></a>DRY, but it does work—and we can clean things up a little once we’ve got everything working. Give this a try now, and we’re almost done: all paragraphs but the first one are hidden once the page finishes loading, and they’re all revealed again when we click on that link. </p>
			<p class="Body">We have one more thing to do: we should remove the Read More link from the DOM once clicked, since it won’t do anything anymore. This is pretty painless: there’s a <code class="CodeInline">remove</code> method built into to each DOM node, and it does exactly what you might<span class="NoBreak"> </span><span class="NoBreak">expect.</span></p>
			<p class="Body">First, though, we need a reference to the Read More link we’re removing. We won’t need to make another trip to the DOM for that: the <code class="CodeInline">this</code> keyword inside a function that’s attached to an event refers to the element that initiated the event. Inside <code class="CodeInline">revealCopy</code>, <code class="CodeInline">this</code> refers to our Read More node, and we’ll call <code class="CodeInline">remove()</code> on<span class="NoBreak"> it:</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">function revealCopy( e ) {</pre>
			<pre class="Code">  var allParagraphs = document.getElementsByTagName(   &quot;p&quot; );</pre>
			<pre class="Code">  for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">    if( i === 0 ) {</pre>
			<pre class="Code">      continue;</pre>
			<pre class="Code">    }</pre>
			<pre class="Code">    allParagraphs[ i ].style.display = &quot;block&quot;;</pre>
			<pre class="Code">  }</pre>
			<pre class="Code"><em class="CodeEmphasis">  this.remove();</em></pre>
			<pre class="Code">  e.preventDefault();</pre>
			<pre class="Code">}</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">newLink.addEventListener( &quot;click&quot;, revealCopy );</pre>
			<pre class="Code">for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">  if( i === 0 ) {</pre>
			<pre class="Code">    continue;</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">  allParagraphs[ i ].style.display = &quot;none&quot;;</pre>
			<pre class="Code">}</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">It works! We have reached <em class="Emphasis">minimum viable product</em>, here—this isn’t the neatest code ever, but we’ve built exactly what we were aiming to build. No gold stars awarded just yet, but at least we’re all getting a participant<span class="NoBreak"> ribbon.</span></p>
			<p class="Body"><em class="Emphasis">Now</em> we can<span class="NoBreak"> optimize.</span></p>
			<p class="Body">Remember how we copied and pasted that loop? There’s some room for improvement there: we already have a function that loops through all our paragraphs and changes the <code class="CodeInline">display</code> property on all but the first one, and functions are all about reuse. Since there are two situations where we’ll need to change that <code class="CodeInline">display</code> property—to <code class="CodeInline">none</code> initially, and to <code class="CodeInline">block</code> when our link is clicked—we’ll refactor that function to serve both<span class="NoBreak"> </span><span class="NoBreak">cases.</span></p>
			<p class="Body">First things first: we should change the name of that function. We won’t just be using it to <em class="Emphasis">reveal</em> our paragraphs; we’ll be using it to hide them as well. Since we’re toggling those paragraphs’ visibility, we’ll change the identifier and update the reference inside <code class="CodeInline">addEventListener</code> to match—<code class="CodeInline">toggleCopy</code> makes sense to me. Then, let’s try calling that function in place of our original<span class="NoBreak"> loop:</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">function <em class="CodeEmphasis">toggleCopy</em>( e ) {</pre>
			<pre class="Code">  var allParagraphs = document.getElementsByTagName(   &quot;p&quot; );</pre>
			<pre class="Code">  for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">    if( i === 0 ) {</pre>
			<pre class="Code">      continue;</pre>
			<pre class="Code">    }</pre>
			<pre class="Code">    allParagraphs[ i ].style.display = &quot;block&quot;;</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">  this.remove();</pre>
			<pre class="Code">  e.preventDefault();</pre>
			<pre class="Code">}</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">newLink.addEventListener( &quot;click&quot;, <em class="CodeEmphasis">toggleCopy</em> );</pre>
			<pre class="Code">toggleCopy();</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">Uh<span class="NoBreak"> oh.</span></p>
			<pre class="Code"><span class="CodeConsole">Uncaught TypeError: </span><span class="CodeConsole">this.remove is not a function</span></pre>
			<p class="Body">We’ve built a few assumptions into our function. JavaScript is expecting <code class="CodeInline">this</code> to reference a DOM node that has a <code class="CodeInline">remove()</code> method—that won’t apply outside of our event. Our script didn’t get as far as the line after, but that would cause an error too—again, the function assumed an <code class="CodeInline">e</code> argument with<span class="NoBreak"> a </span> <code class="CodeInline">preventDefault</code> method attached, which won’t exist if we’re not calling this function in response to an event. <code class="CodeInline">e</code> has an identifier, but without <code class="CodeInline">addEventListener</code> to give it an object, it’s just an identifier that contains<span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">undefined</code></span><span class="NoBreak">.</span></p>
			<p class="Body">First we’ll deal with the error in our console. We need to make sure <code class="CodeInline">this</code> is a reference to the link we’ve conjured up, and if so, remove it. That’s an easy one: we already have a reference to the Read More—the <code class="CodeInline">newLink</code> identifier. We’ll just make sure <code class="CodeInline">this</code> and <code class="CodeInline">newLink</code> are<span class="NoBreak"> equal.</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">function toggleCopy( e ) {</pre>
			<pre class="Code">  var allParagraphs = document.getElementsByTagName(   &quot;p&quot; );</pre>
			<pre class="Code">  for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">    if( i === 0 ) {</pre>
			<pre class="Code">      continue;</pre>
			<pre class="Code">    }</pre>
			<pre class="Code">    allParagraphs[ i ].style.display = &quot;block&quot;;</pre>
			<pre class="Code">    }</pre>
			<pre class="Code"><em class="CodeEmphasis">    if( this === newLink ) {</em></pre>
			<pre class="Code"><em class="CodeInlineEmphasis">      </em>this.remove();</pre>
			<pre class="Code">    }</pre>
			<pre class="Code">  e.preventDefault();</pre>
			<pre class="Code">}</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">newLink.addEventListener( &quot;click&quot;, toggleCopy );</pre>
			<pre class="Code">toggleCopy();</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">That’s one error down, but here’s that <code class="CodeInline">preventDefault</code> issue we’ve been<span class="NoBreak"> expecting:</span></p>
			<pre class="Code"><span class="CodeConsole">Uncaught TypeError: Cannot read</span><span class="CodeConsole"> property &apos;preventDefault&apos; of undefined</span></pre>
			<p class="Body">When we invoke <code class="CodeInline">toggleCopy</code> without an argument, <code class="CodeInline">e</code> gets a value of <code class="CodeInline">undefined</code>—and <code class="CodeInline">undefined </code>definitely doesn’t have a <code class="CodeInline">preventDefault </code>method. That <code class="CodeInline">undefined </code>default value means that the <code class="CodeInline">e</code> identifier gives us just what we need to get our function back in working order: a condition we can test for. We’ll only invoke <code class="CodeInline">e.preventDefault </code>if <code class="CodeInline">e</code> doesn’t have a value of<span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">undefined</code></span><span class="NoBreak">:</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">function toggleCopy( e ) {</pre>
			<pre class="Code">  var allParagraphs = document.getElementsByTagName(   &quot;p&quot; );</pre>
			<pre class="Code">  for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">    if( i === 0 ) {</pre>
			<pre class="Code">      continue;</pre>
			<pre class="Code">    }</pre>
			<pre class="Code">    allParagraphs[ i ].style.display = &quot;block&quot;;</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">  if( this === newLink ) {</pre>
			<pre class="Code">    this.remove();</pre>
			<pre class="Code">  }</pre>
			<pre class="Code"><em class="CodeEmphasis">  if( e !== undefined ) {</em></pre>
			<pre class="Code">    e.preventDefault();</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">}</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">newLink.addEventListener( &quot;click&quot;, toggleCopy );</pre>
			<pre class="Code">toggleCopy();</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">Now we’re error-free, but we’re still making a big assumption here—if we were to pass this function an argument when invoking it outside of an event, <code class="CodeInline">e</code> wouldn’t be <code class="CodeInline">undefined</code>. <code class="CodeInline">e</code> would take on the value of the argument, which very likely wouldn’t have a <code class="CodeInline">preventDefault</code> method, and then we’d have an error on our hands. <em class="Emphasis">We</em> know better than to chuck a stray argument into <code class="CodeInline">toggleCopy</code> because, well, we built the thing—we know it wouldn’t do anything of value. There’s certainly no harm in doing a little error-proofing for the sake of whomever ends up maintaining our code after<span class="NoBreak"> us.</span></p>
			<p class="Body">Just to be extra safe, we’ll make our conditional a little more explicit: first, see if there’s an argument at all. If there is, see if that argument has a <code class="CodeInline">preventDefault</code> method. Since we’re checking against two values that both need to evaluate to <code class="CodeInline">true</code>, we’ll use <code class="CodeInline">&amp;&amp;</code>.</p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">function toggleCopy( e ) {</pre>
			<pre class="Code">  var allParagraphs = document.getElementsByTagName(   &quot;p&quot; );</pre>
			<pre class="Code">  for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">    if( i === 0 ) {</pre>
			<pre class="Code">      continue;</pre>
			<pre class="Code">    }</pre>
			<pre class="Code">    allParagraphs[ i ].style.display = &quot;block&quot;;</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">  if( this === newLink ) {</pre>
			<pre class="Code">    this.remove();</pre>
			<pre class="Code">  }</pre>
			<pre class="Code"><em class="CodeEmphasis">  if( e !== undefined &amp;&amp; e.preventDefault !==   undefined ) {</em></pre>
			<pre class="Code">    e.preventDefault();</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">}</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">newLink.addEventListener( &quot;click&quot;, toggleCopy );</pre>
			<pre class="Code">toggleCopy();</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">Still no errors; all is<span class="NoBreak"> well.</span></p>
			<p class="Body">Nothing is hidden either, though—we’re still just setting <code class="CodeInline">display</code> to <code class="CodeInline">block</code>. What we need to do is set those elements to <code class="CodeInline">block</code> <em class="Emphasis">only</em> if they’re already hidden—we’ll need one more <code class="CodeInline">if</code> that checks to see if the paragraph’s display property is set to <code class="CodeInline">none</code> and, if so, set it to <code class="CodeInline">block</code>. For any other value, we’ll set that value to<span class="NoBreak"> </span><span class="NoBreak"><code class="CodeInline">none</code></span><span class="NoBreak">.</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">function toggleCopy( e ) {</pre>
			<pre class="Code">  var allParagraphs = document.getElementsByTagName(   &quot;p&quot; );</pre>
			<pre class="Code">  for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">    if( i === 0 ) {</pre>
			<pre class="Code">      continue;</pre>
			<pre class="Code">    }</pre>
			<pre class="Code">    if( allParagraphs[ i ].style.display === &quot;none&quot; ) {</pre>
			<pre class="Code">      allParagraphs[ i ].style.display = &quot;block&quot;;</pre>
			<pre class="Code">    } else {</pre>
			<pre class="Code">      allParagraphs[ i ].style.display = &quot;none&quot;;</pre>
			<pre class="Code">    }</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">  if( this === newLink ) {</pre>
			<pre class="Code">    this.remove();</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">  if( e !== undefined &amp;&amp; e.preventDefault !==   undefined ) {</pre>
			<pre class="Code">    e.preventDefault();</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">}</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">newLink.addEventListener( &quot;click&quot;, toggleCopy );</pre>
			<pre class="Code">toggleCopy();</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">Working again! One more little thing, though: we’re repeating <code class="CodeInline">allParagraphs[ i ]</code> over and over when we could just be referencing it by a single<span class="NoBreak"> identifier.</span></p>
			<p class="Body">We’re nit-picking a little now, but what could it<span class="NoBreak"> </span><span class="NoBreak">hurt?</span></p>
			<pre class="Code">var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">var allParagraphs = document.getElementsByTagName( &quot;p&quot; );</pre>
			<pre class="Code">var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">function toggleCopy( e ) {</pre>
			<pre class="Code">  var allParagraphs = document.getElementsByTagName(   &quot;p&quot; );</pre>
			<pre class="Code">  for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">    var para = allParagraphs[ i ];</pre>
			<pre class="Code">    if( i === 0 ) {</pre>
			<pre class="Code">      continue;</pre>
			<pre class="Code">    }</pre>
			<pre class="Code">    if( para.style.display === &quot;none&quot; ) {</pre>
			<pre class="Code">    para.style.display = &quot;block&quot;;</pre>
			<pre class="Code">    } else {</pre>
			<pre class="Code">    para.style.display = &quot;none&quot;;</pre>
			<pre class="Code">    }</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">  if( this === newLink ) {</pre>
			<pre class="Code">    this.remove();</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">  if( e !== undefined &amp;&amp; e.preventDefault !==   undefined ) {</pre>
			<pre class="Code">    e.preventDefault();</pre>
			<pre class="Code">  }</pre>
			<pre class="Code">}</pre>
			<pre class="Code">newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">newLink.addEventListener( &quot;click&quot;, toggleCopy );</pre>
			<pre class="Code">toggleCopy();</pre>
			<pre class="Code">firstParagraph.appendChild( newLink );</pre>
			<p class="Body">And while we’re at it, we’re polluting the <a id="_idIndexMarker132"></a>global scope a little—all of these variables are getting added to <code class="CodeInline">window</code>, since they’re not in an enclosing function. Try it out for yourself in the<span class="NoBreak"> console:</span></p>
			<pre class="Code">window.newLink</pre>
			<pre class="Code"><span class="CodeConsole">&lt;a&gt;&lt;/</span><span class="CodeConsole">a&gt;</span></pre>
			<p class="Body">We don’t want to clutter up the global scope. Let’s wrap this whole thing in a function; and since we don’t to reference it outside of the moment the page is loaded, we don’t need to give it an identifier—we’ll wrap all of our JavaScript in an anonymous function that executes it right away, called an <em class="Emphasis">immediately-invoked functional expression</em> or <a id="_idIndexMarker133"></a>IIFE. The syntax is a little strange and can be written in a couple of different ways, but the usual gist is this: by wrapping an anonymous function in parentheses, we tell JavaScript that any instance of the <code class="CodeInline">function</code> keyword is an expression, not a declaration—<em class="Emphasis">invoking</em> a function, not potentially <em class="Emphasis">defining</em> one with an identifier. We then follow that up with a matched set of parentheses—<code class="CodeInline">()</code>—to kick that newly created function off right<span class="NoBreak"> away.</span></p>
			<p class="Body">We’re into slightly academic territory here, truth be told: the IIFE pattern is important for sure, but we don’t need to know how JavaScript feels about parentheses to make use of it. For now, we can take it at face<span class="NoBreak"> value.</span></p>
			<pre class="Code">(function() {</pre>
			<pre class="Code">  var newLink = document.createElement( &quot;a&quot; );</pre>
			<pre class="Code">  var allParagraphs = document.getElementsByTagName(   &quot;p&quot; );</pre>
			<pre class="Code">  var firstParagraph = allParagraphs[ 0 ];</pre>
			<pre class="Code">  function toggleCopy( e ) {</pre>
			<pre class="Code">    var allParagraphs = document.getElementsByTagName(     &quot;p&quot; );</pre>
			<pre class="Code">    for( var i = 0; i &lt; allParagraphs.length; i++ ) {</pre>
			<pre class="Code">      var para = allParagraphs[ i ];</pre>
			<pre class="Code">      if( i === 0 ) {</pre>
			<pre class="Code">        continue;</pre>
			<pre class="Code">      }</pre>
			<pre class="Code">      if( para.style.display === &quot;none&quot; ) {</pre>
			<pre class="Code">        para.style.display = &quot;block&quot;;</pre>
			<pre class="Code">      } else {</pre>
			<pre class="Code">        para.style.display = &quot;none&quot;;</pre>
			<pre class="Code">      }</pre>
			<pre class="Code">    }</pre>
			<pre class="Code">    if( this === newLink ) {</pre>
			<pre class="Code">      this.remove();</pre>
			<pre class="Code">    }</pre>
			<pre class="Code">    if( e !== undefined &amp;&amp; e.preventDefault !==     undefined ) {</pre>
			<pre class="Code">      e.preventDefault();</pre>
			<pre class="Code">    }</pre>
			<pre class="Code">  };</pre>
			<pre class="Code">  newLink.setAttribute( &quot;href&quot;, &quot;#&quot; );</pre>
			<pre class="Code">  newLink.setAttribute( &quot;class&quot;, &quot;more-link&quot; );</pre>
			<pre class="Code">  newLink.innerHTML = &quot;Read more&quot;;</pre>
			<pre class="Code">  newLink.addEventListener( &quot;click&quot;, toggleCopy );</pre>
			<pre class="Code">  toggleCopy();</pre>
			<pre class="Code">  firstParagraph.appendChild( newLink );</pre>
			<pre class="Code">}());</pre>
			<p class="Body">Now, if we punch <code class="CodeInline">window.newLink</code> into our developer console, we get back <span class="CodeConsoleInline">undefined</span>—we’re not polluting the global scope with identifiers we’ll never need to access outside the scope of our<span class="NoBreak"> IIFE.</span></p>
			<pre class="Code">window.newLink</pre>
			<pre class="Code"><span class="CodeConsole">undefined</span></pre>
			<p class="Body">Perfect.</p>
			<p class="Body">Well, okay. Not <em class="Emphasis">perfect</em>—in fact, probably never <em class="Emphasis">perfect</em>. There are always more tweaks we can make to a script, tiny optimization after tiny optimization and so on unto infinity. But this is pretty damn good, if I do say so myself: we’re being responsible about polluting the global scope, we’re being DRY throughout our code, and we’ve written something that will be easy to read and maintain long after we’ve moved on to bigger and better<span class="NoBreak"> scripts.</span></p>
			<h2 class="AHead"><a id="_idIndexMarker134"></a>PROGRESSIVE ENHANCEMENT</h2>
			<p class="BodyFirstParagraph">Scripting behavior in a responsible way isn’t always easy. We’re standing in for the browser, taking over the user’s experience of something as common and predictable as clicking on a link. Done in an unobtrusive way, we’re able to create a completely fluid experience—better, in many ways, than the browser itself could. </p>
			<p class="Body">If we don&apos;t do it responsibly, though, we’ve done something far worse than simply presenting the user with a misaligned <code class="CodeInline">div</code>—we’ve built something they might not be able to use at all. The web is an unpredictable medium, and we have to plan for that—when writing JavaScript more so than HTML or CSS, by a wide<span class="NoBreak"> margin.</span></p>
			<p class="Body">We could have cut some corners in the paragraph-toggling script we built today, for example. We could have hidden those paragraphs at the outset using CSS and relied on JavaScript to show them again, or hard-coded the Read More link and assumed the functionality in our script would always be available. The latter case would be a nuisance if anything went wrong—an error elsewhere in a script causing ours to fail, for example. The user would be left with a Read More link that didn’t <em class="Emphasis">do</em> anything. The former case would be far more dire: in the event that JavaScript failed in any way, the user would be left with no way to access the contents of the<span class="NoBreak"> page.</span></p>
			<p class="Body">A site that fully relies on JavaScript for critical functionality—a website built on the expectation that JavaScript will always run, no matter what—is a fragile one. Users’ browsing conditions can change minute to minute, and we can’t plan for—we can’t <em class="Emphasis">know</em>—the ways that our scripts might break<span class="NoBreak"> down.</span></p>
			<p class="Body">A handful of years ago I worked on the responsive <a id="_idIndexMarker135"></a><em class="Emphasis">Boston Globe</em> site with <a id="_idIndexMarker136"></a>Ethan Marcotte, <a id="_idIndexMarker137"></a>Scott Jehl, and the whole crew at <a id="_idIndexMarker138"></a>Filament Group. It was built with progressive enhancement in mind, which didn’t hold us back in the least—there are some incredible features on that site, if you don’t mind my saying so (<a href="https://www.bostonglobe.com/"><span class="URL">https://www.</span><span class="URL">bostonglobe.com/</span></a>).</p>
			<p class="Body">We got to solve some tricky problems on that project, but made sure we were doing so with progressive enhancement squarely in mind—“If and when this feature fails, how do we ensure the user still has access to the underlying information?” On the surface, that may seem like an exercise in edge cases. The tiny decisions that go into building a website don’t necessarily feel like a big deal at the<span class="NoBreak"> time.</span></p>
			<p class="Body">The <a id="_idIndexMarker139"></a>Boston Marathon bombings happened a few years later. Being able to reach up-to-date information on what was happening throughout the city was tremendously important to a huge number of people that day, and many of them looked to the <em class="Emphasis">Boston Globe</em> for that. Due to the increased traffic, the <em class="Emphasis">Boston Globe</em>’s CDN—the server that delivers assets like CSS and JavaScript—was overwhelmed, and went down. For a period of time that afternoon, the <em class="Emphasis">Boston Globe</em>’s website was HTML-only.</p>
			<p class="Body">The website <em class="Emphasis">looked</em> broken, and none of our advanced JavaScript features were there consistently: no offline reading, no dropdown menus in the navigation. Sometimes the whole site was just black Times New Roman on a white background. Sometimes only the CSS would come through, or some part of it—likewise with the JavaScript. Rarely did any of our scripts run without errors, through no fault of our<span class="NoBreak"> own.</span></p>
			<p class="Body">But visitors to BostonGlobe.com that afternoon could still navigate the site. They could still read the news. The website <em class="Emphasis">worked</em>. If we’d relied on CSS to hide parts of the navigation and assumed JavaScript would always be there to reveal them again, some users wouldn’t have been able to navigate that day. If we’d relied on JavaScript to fetch and render critical parts of the page, that content might never have appeared. If we’d hard-coded controls that required JavaScript in order to do anything at all, they would have been useless—confusing and frustrating for the site’s users at the worst imaginable<span class="NoBreak"> time.</span></p>
			<p class="Body">Progressive enhancement is yet another thing we’ll need to factor in when we’re writing our JavaScript. To be honest, progressive enhancement will sometimes mean doing more work—but that’s the craft. The decisions that went into writing the JavaScript for BostonGlobe.com could have seemed inconsequential in the grand scheme of things, but on that day—for tens of thousands of users—those decisions added up to something huge. For those users, progressive enhancement meant the difference between finding the information they needed right away, or being forced to keep searching for it—between knowing and not<span class="NoBreak"> knowing.</span></p>
		</div>
	</body>
</html>
